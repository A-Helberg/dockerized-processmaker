/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

// wrapper for non-node envs
;(function (sax) {

    sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
    sax.SAXParser = SAXParser
    sax.SAXStream = SAXStream
    sax.createStream = createStream

// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
// since that's the earliest that a buffer overrun could occur.  This way, checks are
// as rare as required, but as often as necessary to ensure never crossing this bound.
// Furthermore, buffers are only tested at most once per write(), so passing a very
// large string into write() might have undesirable effects, but this is manageable by
// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
// edge case, result in creating at most one complete copy of the string passed in.
// Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 64 * 1024

    var buffers = [
        "comment", "sgmlDecl", "textNode", "tagName", "doctype",
        "procInstName", "procInstBody", "entity", "attribName",
        "attribValue", "cdata", "script"
    ]

    sax.EVENTS = // for discoverability.
        [ "text"
            , "processinginstruction"
            , "sgmldeclaration"
            , "doctype"
            , "comment"
            , "attribute"
            , "opentag"
            , "closetag"
            , "opencdata"
            , "cdata"
            , "closecdata"
            , "error"
            , "end"
            , "ready"
            , "script"
            , "opennamespace"
            , "closenamespace"
        ]

    function SAXParser (strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)

        var parser = this
        clearBuffers(parser)
        parser.q = parser.c = ""
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
        parser.opt = opt || {}
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
        parser.tags = []
        parser.closed = parser.closedRoot = parser.sawRoot = false
        parser.tag = parser.error = null
        parser.strict = !!strict
        parser.noscript = !!(strict || parser.opt.noscript)
        parser.state = S.BEGIN
        parser.ENTITIES = Object.create(sax.ENTITIES)
        parser.attribList = []

        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS)

        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false
        if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0
        }
        emit(parser, "onready")
    }

    if (!Object.create) Object.create = function (o) {
        function f () { this.__proto__ = o }
        f.prototype = o
        return new f
    }

    if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
        return o.__proto__
    }

    if (!Object.keys) Object.keys = function (o) {
        var a = []
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
        return a
    }

    function checkBufferLength (parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
            , maxActual = 0
        for (var i = 0, l = buffers.length; i < l; i ++) {
            var len = parser[buffers[i]].length
            if (len > maxAllowed) {
                // Text/cdata nodes can get big, and since they're buffered,
                // we can get here under normal conditions.
                // Avoid issues by emitting the text node now,
                // so at least it won't get any bigger.
                switch (buffers[i]) {
                    case "textNode":
                        closeText(parser)
                        break

                    case "cdata":
                        emitNode(parser, "oncdata", parser.cdata)
                        parser.cdata = ""
                        break

                    case "script":
                        emitNode(parser, "onscript", parser.script)
                        parser.script = ""
                        break

                    default:
                        error(parser, "Max buffer length exceeded: "+buffers[i])
                }
            }
            maxActual = Math.max(maxActual, len)
        }
        // schedule the next check for the earliest possible buffer overrun.
        parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
        + parser.position
    }

    function clearBuffers (parser) {
        for (var i = 0, l = buffers.length; i < l; i ++) {
            parser[buffers[i]] = ""
        }
    }

    function flushBuffers (parser) {
        closeText(parser)
        if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata)
            parser.cdata = ""
        }
        if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script)
            parser.script = ""
        }
    }

    SAXParser.prototype =
    { end: function () { end(this) }
        , write: write
        , resume: function () { this.error = null; return this }
        , close: function () { return this.write(null) }
        , flush: function () { flushBuffers(this) }
    }

    try {
        var Stream = require("stream").Stream
    } catch (ex) {
        var Stream = function () {}
    }


    var streamWraps = sax.EVENTS.filter(function (ev) {
        return ev !== "error" && ev !== "end"
    })

    function createStream (strict, opt) {
        return new SAXStream(strict, opt)
    }

    function SAXStream (strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)

        Stream.apply(this)

        this._parser = new SAXParser(strict, opt)
        this.writable = true
        this.readable = true


        var me = this

        this._parser.onend = function () {
            me.emit("end")
        }

        this._parser.onerror = function (er) {
            me.emit("error", er)

            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null
        }

        this._decoder = null;

        streamWraps.forEach(function (ev) {
            Object.defineProperty(me, "on" + ev, {
                get: function () { return me._parser["on" + ev] },
                set: function (h) {
                    if (!h) {
                        me.removeAllListeners(ev)
                        return me._parser["on"+ev] = h
                    }
                    me.on(ev, h)
                },
                enumerable: true,
                configurable: false
            })
        })
    }

    SAXStream.prototype = Object.create(Stream.prototype,
        { constructor: { value: SAXStream } })

    SAXStream.prototype.write = function (data) {
        if (typeof Buffer === 'function' &&
            typeof Buffer.isBuffer === 'function' &&
            Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require('string_decoder').StringDecoder
                this._decoder = new SD('utf8')
            }
            data = this._decoder.write(data);
        }

        this._parser.write(data.toString())
        this.emit("data", data)
        return true
    }

    SAXStream.prototype.end = function (chunk) {
        if (chunk && chunk.length) this.write(chunk)
        this._parser.end()
        return true
    }

    SAXStream.prototype.on = function (ev, handler) {
        var me = this
        if (!me._parser["on"+ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on"+ev] = function () {
                var args = arguments.length === 1 ? [arguments[0]]
                    : Array.apply(null, arguments)
                args.splice(0, 0, ev)
                me.emit.apply(me, args)
            }
        }

        return Stream.prototype.on.call(me, ev, handler)
    }



// character classes and tokens
    var whitespace = "\r\n\t "
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
        , number = "0124356789"
        , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    // (Letter | "_" | ":")
        , quote = "'\""
        , entity = number+letter+"#"
        , attribEnd = whitespace + ">"
        , CDATA = "[CDATA["
        , DOCTYPE = "DOCTYPE"
        , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
        , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
        , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

// turn all the string character sets into character class objects.
    whitespace = charClass(whitespace)
    number = charClass(number)
    letter = charClass(letter)

// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
// This implementation works on strings, a single character at a time
// as such, it cannot ever support astral-plane characters (10000-EFFFF)
// without a significant breaking change to either this  parser, or the
// JavaScript language.  Implementation of an emoji-capable xml parser
// is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

    quote = charClass(quote)
    entity = charClass(entity)
    attribEnd = charClass(attribEnd)

    function charClass (str) {
        return str.split("").reduce(function (s, c) {
            s[c] = true
            return s
        }, {})
    }

    function isRegExp (c) {
        return Object.prototype.toString.call(c) === '[object RegExp]'
    }

    function is (charclass, c) {
        return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
    }

    function not (charclass, c) {
        return !is(charclass, c)
    }

    var S = 0
    sax.STATE =
    { BEGIN                     : S++
        , TEXT                      : S++ // general stuff
        , TEXT_ENTITY               : S++ // &amp and such.
        , OPEN_WAKA                 : S++ // <
        , SGML_DECL                 : S++ // <!BLARG
        , SGML_DECL_QUOTED          : S++ // <!BLARG foo "bar
        , DOCTYPE                   : S++ // <!DOCTYPE
        , DOCTYPE_QUOTED            : S++ // <!DOCTYPE "//blah
        , DOCTYPE_DTD               : S++ // <!DOCTYPE "//blah" [ ...
        , DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE "//blah" [ "foo
        , COMMENT_STARTING          : S++ // <!-
        , COMMENT                   : S++ // <!--
        , COMMENT_ENDING            : S++ // <!-- blah -
        , COMMENT_ENDED             : S++ // <!-- blah --
        , CDATA                     : S++ // <![CDATA[ something
        , CDATA_ENDING              : S++ // ]
        , CDATA_ENDING_2            : S++ // ]]
        , PROC_INST                 : S++ // <?hi
        , PROC_INST_BODY            : S++ // <?hi there
        , PROC_INST_ENDING          : S++ // <?hi "there" ?
        , OPEN_TAG                  : S++ // <strong
        , OPEN_TAG_SLASH            : S++ // <strong /
        , ATTRIB                    : S++ // <a
        , ATTRIB_NAME               : S++ // <a foo
        , ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _
        , ATTRIB_VALUE              : S++ // <a foo=
        , ATTRIB_VALUE_QUOTED       : S++ // <a foo="bar
        , ATTRIB_VALUE_CLOSED       : S++ // <a foo="bar"
        , ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar
        , ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar="&quot;"
        , ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;
        , CLOSE_TAG                 : S++ // </a
        , CLOSE_TAG_SAW_WHITE       : S++ // </a   >
        , SCRIPT                    : S++ // <script> ...
        , SCRIPT_ENDING             : S++ // <script> ... <
    }

    sax.ENTITIES =
    { "amp" : "&"
        , "gt" : ">"
        , "lt" : "<"
        , "quot" : "\""
        , "apos" : "'"
        , "AElig" : 198
        , "Aacute" : 193
        , "Acirc" : 194
        , "Agrave" : 192
        , "Aring" : 197
        , "Atilde" : 195
        , "Auml" : 196
        , "Ccedil" : 199
        , "ETH" : 208
        , "Eacute" : 201
        , "Ecirc" : 202
        , "Egrave" : 200
        , "Euml" : 203
        , "Iacute" : 205
        , "Icirc" : 206
        , "Igrave" : 204
        , "Iuml" : 207
        , "Ntilde" : 209
        , "Oacute" : 211
        , "Ocirc" : 212
        , "Ograve" : 210
        , "Oslash" : 216
        , "Otilde" : 213
        , "Ouml" : 214
        , "THORN" : 222
        , "Uacute" : 218
        , "Ucirc" : 219
        , "Ugrave" : 217
        , "Uuml" : 220
        , "Yacute" : 221
        , "aacute" : 225
        , "acirc" : 226
        , "aelig" : 230
        , "agrave" : 224
        , "aring" : 229
        , "atilde" : 227
        , "auml" : 228
        , "ccedil" : 231
        , "eacute" : 233
        , "ecirc" : 234
        , "egrave" : 232
        , "eth" : 240
        , "euml" : 235
        , "iacute" : 237
        , "icirc" : 238
        , "igrave" : 236
        , "iuml" : 239
        , "ntilde" : 241
        , "oacute" : 243
        , "ocirc" : 244
        , "ograve" : 242
        , "oslash" : 248
        , "otilde" : 245
        , "ouml" : 246
        , "szlig" : 223
        , "thorn" : 254
        , "uacute" : 250
        , "ucirc" : 251
        , "ugrave" : 249
        , "uuml" : 252
        , "yacute" : 253
        , "yuml" : 255
        , "copy" : 169
        , "reg" : 174
        , "nbsp" : 160
        , "iexcl" : 161
        , "cent" : 162
        , "pound" : 163
        , "curren" : 164
        , "yen" : 165
        , "brvbar" : 166
        , "sect" : 167
        , "uml" : 168
        , "ordf" : 170
        , "laquo" : 171
        , "not" : 172
        , "shy" : 173
        , "macr" : 175
        , "deg" : 176
        , "plusmn" : 177
        , "sup1" : 185
        , "sup2" : 178
        , "sup3" : 179
        , "acute" : 180
        , "micro" : 181
        , "para" : 182
        , "middot" : 183
        , "cedil" : 184
        , "ordm" : 186
        , "raquo" : 187
        , "frac14" : 188
        , "frac12" : 189
        , "frac34" : 190
        , "iquest" : 191
        , "times" : 215
        , "divide" : 247
        , "OElig" : 338
        , "oelig" : 339
        , "Scaron" : 352
        , "scaron" : 353
        , "Yuml" : 376
        , "fnof" : 402
        , "circ" : 710
        , "tilde" : 732
        , "Alpha" : 913
        , "Beta" : 914
        , "Gamma" : 915
        , "Delta" : 916
        , "Epsilon" : 917
        , "Zeta" : 918
        , "Eta" : 919
        , "Theta" : 920
        , "Iota" : 921
        , "Kappa" : 922
        , "Lambda" : 923
        , "Mu" : 924
        , "Nu" : 925
        , "Xi" : 926
        , "Omicron" : 927
        , "Pi" : 928
        , "Rho" : 929
        , "Sigma" : 931
        , "Tau" : 932
        , "Upsilon" : 933
        , "Phi" : 934
        , "Chi" : 935
        , "Psi" : 936
        , "Omega" : 937
        , "alpha" : 945
        , "beta" : 946
        , "gamma" : 947
        , "delta" : 948
        , "epsilon" : 949
        , "zeta" : 950
        , "eta" : 951
        , "theta" : 952
        , "iota" : 953
        , "kappa" : 954
        , "lambda" : 955
        , "mu" : 956
        , "nu" : 957
        , "xi" : 958
        , "omicron" : 959
        , "pi" : 960
        , "rho" : 961
        , "sigmaf" : 962
        , "sigma" : 963
        , "tau" : 964
        , "upsilon" : 965
        , "phi" : 966
        , "chi" : 967
        , "psi" : 968
        , "omega" : 969
        , "thetasym" : 977
        , "upsih" : 978
        , "piv" : 982
        , "ensp" : 8194
        , "emsp" : 8195
        , "thinsp" : 8201
        , "zwnj" : 8204
        , "zwj" : 8205
        , "lrm" : 8206
        , "rlm" : 8207
        , "ndash" : 8211
        , "mdash" : 8212
        , "lsquo" : 8216
        , "rsquo" : 8217
        , "sbquo" : 8218
        , "ldquo" : 8220
        , "rdquo" : 8221
        , "bdquo" : 8222
        , "dagger" : 8224
        , "Dagger" : 8225
        , "bull" : 8226
        , "hellip" : 8230
        , "permil" : 8240
        , "prime" : 8242
        , "Prime" : 8243
        , "lsaquo" : 8249
        , "rsaquo" : 8250
        , "oline" : 8254
        , "frasl" : 8260
        , "euro" : 8364
        , "image" : 8465
        , "weierp" : 8472
        , "real" : 8476
        , "trade" : 8482
        , "alefsym" : 8501
        , "larr" : 8592
        , "uarr" : 8593
        , "rarr" : 8594
        , "darr" : 8595
        , "harr" : 8596
        , "crarr" : 8629
        , "lArr" : 8656
        , "uArr" : 8657
        , "rArr" : 8658
        , "dArr" : 8659
        , "hArr" : 8660
        , "forall" : 8704
        , "part" : 8706
        , "exist" : 8707
        , "empty" : 8709
        , "nabla" : 8711
        , "isin" : 8712
        , "notin" : 8713
        , "ni" : 8715
        , "prod" : 8719
        , "sum" : 8721
        , "minus" : 8722
        , "lowast" : 8727
        , "radic" : 8730
        , "prop" : 8733
        , "infin" : 8734
        , "ang" : 8736
        , "and" : 8743
        , "or" : 8744
        , "cap" : 8745
        , "cup" : 8746
        , "int" : 8747
        , "there4" : 8756
        , "sim" : 8764
        , "cong" : 8773
        , "asymp" : 8776
        , "ne" : 8800
        , "equiv" : 8801
        , "le" : 8804
        , "ge" : 8805
        , "sub" : 8834
        , "sup" : 8835
        , "nsub" : 8836
        , "sube" : 8838
        , "supe" : 8839
        , "oplus" : 8853
        , "otimes" : 8855
        , "perp" : 8869
        , "sdot" : 8901
        , "lceil" : 8968
        , "rceil" : 8969
        , "lfloor" : 8970
        , "rfloor" : 8971
        , "lang" : 9001
        , "rang" : 9002
        , "loz" : 9674
        , "spades" : 9824
        , "clubs" : 9827
        , "hearts" : 9829
        , "diams" : 9830
    }

    Object.keys(sax.ENTITIES).forEach(function (key) {
        var e = sax.ENTITIES[key]
        var s = typeof e === 'number' ? String.fromCharCode(e) : e
        sax.ENTITIES[key] = s
    })

    for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S

// shorthand
    S = sax.STATE

    function emit (parser, event, data) {
        parser[event] && parser[event](data)
    }

    function emitNode (parser, nodeType, data) {
        if (parser.textNode) closeText(parser)
        emit(parser, nodeType, data)
    }

    function closeText (parser) {
        parser.textNode = textopts(parser.opt, parser.textNode)
        if (parser.textNode) emit(parser, "ontext", parser.textNode)
        parser.textNode = ""
    }

    function textopts (opt, text) {
        if (opt.trim) text = text.trim()
        if (opt.normalize) text = text.replace(/\s+/g, " ")
        return text
    }

    function error (parser, er) {
        closeText(parser)
        if (parser.trackPosition) {
            er += "\nLine: "+parser.line+
            "\nColumn: "+parser.column+
            "\nChar: "+parser.c
        }
        er = new Error(er)
        parser.error = er
        emit(parser, "onerror", er)
        return parser
    }

    function end (parser) {
        if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
        if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, "Unexpected end")
        closeText(parser)
        parser.c = ""
        parser.closed = true
        emit(parser, "onend")
        SAXParser.call(parser, parser.strict, parser.opt)
        return parser
    }

    function strictFail (parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser))
            throw new Error('bad call to strictFail');
        if (parser.strict) error(parser, message)
    }

    function newTag (parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
        var parent = parser.tags[parser.tags.length - 1] || parser
            , tag = parser.tag = { name : parser.tagName, attributes : {} }

        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) tag.ns = parent.ns
        parser.attribList.length = 0
    }

    function qname (name, attribute) {
        var i = name.indexOf(":")
            , qualName = i < 0 ? [ "", name ] : name.split(":")
            , prefix = qualName[0]
            , local = qualName[1]

        // <x "xmlns"="http://foo">
        if (attribute && name === "xmlns") {
            prefix = "xmlns"
            local = ""
        }

        return { prefix: prefix, local: local }
    }

    function attrib (parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()

        if (parser.attribList.indexOf(parser.attribName) !== -1 ||
            parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            return parser.attribName = parser.attribValue = ""
        }

        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true)
                , prefix = qn.prefix
                , local = qn.local

            if (prefix === "xmlns") {
                // namespace binding attribute; push the binding into scope
                if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                    strictFail( parser
                        , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
                        + "Actual: " + parser.attribValue )
                } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                    strictFail( parser
                        , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
                        + "Actual: " + parser.attribValue )
                } else {
                    var tag = parser.tag
                        , parent = parser.tags[parser.tags.length - 1] || parser
                    if (tag.ns === parent.ns) {
                        tag.ns = Object.create(parent.ns)
                    }
                    tag.ns[local] = parser.attribValue
                }
            }

            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect; preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([parser.attribName, parser.attribValue])
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue
            emitNode( parser
                , "onattribute"
                , { name: parser.attribName
                    , value: parser.attribValue } )
        }

        parser.attribName = parser.attribValue = ""
    }

    function openTag (parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag

            // add namespace info to tag
            var qn = qname(parser.tagName)
            tag.prefix = qn.prefix
            tag.local = qn.local
            tag.uri = tag.ns[qn.prefix] || ""

            if (tag.prefix && !tag.uri) {
                strictFail(parser, "Unbound namespace prefix: "
                + JSON.stringify(parser.tagName))
                tag.uri = qn.prefix
            }

            var parent = parser.tags[parser.tags.length - 1] || parser
            if (tag.ns && parent.ns !== tag.ns) {
                Object.keys(tag.ns).forEach(function (p) {
                    emitNode( parser
                        , "onopennamespace"
                        , { prefix: p , uri: tag.ns[p] } )
                })
            }

            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for (var i = 0, l = parser.attribList.length; i < l; i ++) {
                var nv = parser.attribList[i]
                var name = nv[0]
                    , value = nv[1]
                    , qualName = qname(name, true)
                    , prefix = qualName.prefix
                    , local = qualName.local
                    , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
                    , a = { name: name
                        , value: value
                        , prefix: prefix
                        , local: local
                        , uri: uri
                    }

                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix != "xmlns" && !uri) {
                    strictFail(parser, "Unbound namespace prefix: "
                    + JSON.stringify(prefix))
                    a.uri = prefix
                }
                parser.tag.attributes[name] = a
                emitNode(parser, "onattribute", a)
            }
            parser.attribList.length = 0
        }

        parser.tag.isSelfClosing = !!selfClosing

        // process the tag
        parser.sawRoot = true
        parser.tags.push(parser.tag)
        emitNode(parser, "onopentag", parser.tag)
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                parser.state = S.SCRIPT
            } else {
                parser.state = S.TEXT
            }
            parser.tag = null
            parser.tagName = ""
        }
        parser.attribName = parser.attribValue = ""
        parser.attribList.length = 0
    }

    function closeTag (parser) {
        if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.")
            parser.textNode += "</>"
            parser.state = S.TEXT
            return
        }

        if (parser.script) {
            if (parser.tagName !== "script") {
                parser.script += "</" + parser.tagName + ">"
                parser.tagName = ""
                parser.state = S.SCRIPT
                return
            }
            emitNode(parser, "onscript", parser.script)
            parser.script = ""
        }

        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length
        var tagName = parser.tagName
        if (!parser.strict) tagName = tagName[parser.looseCase]()
        var closeTo = tagName
        while (t --) {
            var close = parser.tags[t]
            if (close.name !== closeTo) {
                // fail the first time in strict mode
                strictFail(parser, "Unexpected close tag")
            } else break
        }

        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, "Unmatched closing tag: "+parser.tagName)
            parser.textNode += "</" + parser.tagName + ">"
            parser.state = S.TEXT
            return
        }
        parser.tagName = tagName
        var s = parser.tags.length
        while (s --> t) {
            var tag = parser.tag = parser.tags.pop()
            parser.tagName = parser.tag.name
            emitNode(parser, "onclosetag", parser.tagName)

            var x = {}
            for (var i in tag.ns) x[i] = tag.ns[i]

            var parent = parser.tags[parser.tags.length - 1] || parser
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
                // remove namespace bindings introduced by tag
                Object.keys(tag.ns).forEach(function (p) {
                    var n = tag.ns[p]
                    emitNode(parser, "onclosenamespace", { prefix: p, uri: n })
                })
            }
        }
        if (t === 0) parser.closedRoot = true
        parser.tagName = parser.attribValue = parser.attribName = ""
        parser.attribList.length = 0
        parser.state = S.TEXT
    }

    function parseEntity (parser) {
        var entity = parser.entity
            , entityLC = entity.toLowerCase()
            , num
            , numStr = ""
        if (parser.ENTITIES[entity])
            return parser.ENTITIES[entity]
        if (parser.ENTITIES[entityLC])
            return parser.ENTITIES[entityLC]
        entity = entityLC
        if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
                entity = entity.slice(2)
                num = parseInt(entity, 16)
                numStr = num.toString(16)
            } else {
                entity = entity.slice(1)
                num = parseInt(entity, 10)
                numStr = num.toString(10)
            }
        }
        entity = entity.replace(/^0+/, "")
        if (numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity")
            return "&"+parser.entity + ";"
        }

        return String.fromCodePoint(num)
    }

    function write (chunk) {
        var parser = this
        if (this.error) throw this.error
        if (parser.closed) return error(parser,
            "Cannot write after close. Assign an onready handler.")
        if (chunk === null) return end(parser)
        var i = 0, c = ""
        while (parser.c = c = chunk.charAt(i++)) {
            if (parser.trackPosition) {
                parser.position ++
                if (c === "\n") {
                    parser.line ++
                    parser.column = 0
                } else parser.column ++
            }
            switch (parser.state) {

                case S.BEGIN:
                    if (c === "<") {
                        parser.state = S.OPEN_WAKA
                        parser.startTagPosition = parser.position
                    } else if (not(whitespace,c)) {
                        // have to process this as a text node.
                        // weird, but happens.
                        strictFail(parser, "Non-whitespace before first tag.")
                        parser.textNode = c
                        parser.state = S.TEXT
                    }
                    continue

                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i-1
                        while (c && c!=="<" && c!=="&") {
                            c = chunk.charAt(i++)
                            if (c && parser.trackPosition) {
                                parser.position ++
                                if (c === "\n") {
                                    parser.line ++
                                    parser.column = 0
                                } else parser.column ++
                            }
                        }
                        parser.textNode += chunk.substring(starti, i-1)
                    }
                    if (c === "<") {
                        parser.state = S.OPEN_WAKA
                        parser.startTagPosition = parser.position
                    } else {
                        if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
                            strictFail(parser, "Text data outside of root node.")
                        if (c === "&") parser.state = S.TEXT_ENTITY
                        else parser.textNode += c
                    }
                    continue

                case S.SCRIPT:
                    // only non-strict
                    if (c === "<") {
                        parser.state = S.SCRIPT_ENDING
                    } else parser.script += c
                    continue

                case S.SCRIPT_ENDING:
                    if (c === "/") {
                        parser.state = S.CLOSE_TAG
                    } else {
                        parser.script += "<" + c
                        parser.state = S.SCRIPT
                    }
                    continue

                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === "!") {
                        parser.state = S.SGML_DECL
                        parser.sgmlDecl = ""
                    } else if (is(whitespace, c)) {
                        // wait for it...
                    } else if (is(nameStart,c)) {
                        parser.state = S.OPEN_TAG
                        parser.tagName = c
                    } else if (c === "/") {
                        parser.state = S.CLOSE_TAG
                        parser.tagName = ""
                    } else if (c === "?") {
                        parser.state = S.PROC_INST
                        parser.procInstName = parser.procInstBody = ""
                    } else {
                        strictFail(parser, "Unencoded <")
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition
                            c = new Array(pad).join(" ") + c
                        }
                        parser.textNode += "<" + c
                        parser.state = S.TEXT
                    }
                    continue

                case S.SGML_DECL:
                    if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {
                        emitNode(parser, "onopencdata")
                        parser.state = S.CDATA
                        parser.sgmlDecl = ""
                        parser.cdata = ""
                    } else if (parser.sgmlDecl+c === "--") {
                        parser.state = S.COMMENT
                        parser.comment = ""
                        parser.sgmlDecl = ""
                    } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE
                        if (parser.doctype || parser.sawRoot) strictFail(parser,
                            "Inappropriately located doctype declaration")
                        parser.doctype = ""
                        parser.sgmlDecl = ""
                    } else if (c === ">") {
                        emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
                        parser.sgmlDecl = ""
                        parser.state = S.TEXT
                    } else if (is(quote, c)) {
                        parser.state = S.SGML_DECL_QUOTED
                        parser.sgmlDecl += c
                    } else parser.sgmlDecl += c
                    continue

                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL
                        parser.q = ""
                    }
                    parser.sgmlDecl += c
                    continue

                case S.DOCTYPE:
                    if (c === ">") {
                        parser.state = S.TEXT
                        emitNode(parser, "ondoctype", parser.doctype)
                        parser.doctype = true // just remember that we saw it.
                    } else {
                        parser.doctype += c
                        if (c === "[") parser.state = S.DOCTYPE_DTD
                        else if (is(quote, c)) {
                            parser.state = S.DOCTYPE_QUOTED
                            parser.q = c
                        }
                    }
                    continue

                case S.DOCTYPE_QUOTED:
                    parser.doctype += c
                    if (c === parser.q) {
                        parser.q = ""
                        parser.state = S.DOCTYPE
                    }
                    continue

                case S.DOCTYPE_DTD:
                    parser.doctype += c
                    if (c === "]") parser.state = S.DOCTYPE
                    else if (is(quote,c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED
                        parser.q = c
                    }
                    continue

                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD
                        parser.q = ""
                    }
                    continue

                case S.COMMENT:
                    if (c === "-") parser.state = S.COMMENT_ENDING
                    else parser.comment += c
                    continue

                case S.COMMENT_ENDING:
                    if (c === "-") {
                        parser.state = S.COMMENT_ENDED
                        parser.comment = textopts(parser.opt, parser.comment)
                        if (parser.comment) emitNode(parser, "oncomment", parser.comment)
                        parser.comment = ""
                    } else {
                        parser.comment += "-" + c
                        parser.state = S.COMMENT
                    }
                    continue

                case S.COMMENT_ENDED:
                    if (c !== ">") {
                        strictFail(parser, "Malformed comment")
                        // allow <!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += "--" + c
                        parser.state = S.COMMENT
                    } else parser.state = S.TEXT
                    continue

                case S.CDATA:
                    if (c === "]") parser.state = S.CDATA_ENDING
                    else parser.cdata += c
                    continue

                case S.CDATA_ENDING:
                    if (c === "]") parser.state = S.CDATA_ENDING_2
                    else {
                        parser.cdata += "]" + c
                        parser.state = S.CDATA
                    }
                    continue

                case S.CDATA_ENDING_2:
                    if (c === ">") {
                        if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
                        emitNode(parser, "onclosecdata")
                        parser.cdata = ""
                        parser.state = S.TEXT
                    } else if (c === "]") {
                        parser.cdata += "]"
                    } else {
                        parser.cdata += "]]" + c
                        parser.state = S.CDATA
                    }
                    continue

                case S.PROC_INST:
                    if (c === "?") parser.state = S.PROC_INST_ENDING
                    else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
                    else parser.procInstName += c
                    continue

                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && is(whitespace, c)) continue
                    else if (c === "?") parser.state = S.PROC_INST_ENDING
                    else parser.procInstBody += c
                    continue

                case S.PROC_INST_ENDING:
                    if (c === ">") {
                        emitNode(parser, "onprocessinginstruction", {
                            name : parser.procInstName,
                            body : parser.procInstBody
                        })
                        parser.procInstName = parser.procInstBody = ""
                        parser.state = S.TEXT
                    } else {
                        parser.procInstBody += "?" + c
                        parser.state = S.PROC_INST_BODY
                    }
                    continue

                case S.OPEN_TAG:
                    if (is(nameBody, c)) parser.tagName += c
                    else {
                        newTag(parser)
                        if (c === ">") openTag(parser)
                        else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                        else {
                            if (not(whitespace, c)) strictFail(
                                parser, "Invalid character in tag name")
                            parser.state = S.ATTRIB
                        }
                    }
                    continue

                case S.OPEN_TAG_SLASH:
                    if (c === ">") {
                        openTag(parser, true)
                        closeTag(parser)
                    } else {
                        strictFail(parser, "Forward-slash in opening tag not followed by >")
                        parser.state = S.ATTRIB
                    }
                    continue

                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (is(whitespace, c)) continue
                    else if (c === ">") openTag(parser)
                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                    else if (is(nameStart, c)) {
                        parser.attribName = c
                        parser.attribValue = ""
                        parser.state = S.ATTRIB_NAME
                    } else strictFail(parser, "Invalid attribute name")
                    continue

                case S.ATTRIB_NAME:
                    if (c === "=") parser.state = S.ATTRIB_VALUE
                    else if (c === ">") {
                        strictFail(parser, "Attribute without value")
                        parser.attribValue = parser.attribName
                        attrib(parser)
                        openTag(parser)
                    }
                    else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
                    else if (is(nameBody, c)) parser.attribName += c
                    else strictFail(parser, "Invalid attribute name")
                    continue

                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === "=") parser.state = S.ATTRIB_VALUE
                    else if (is(whitespace, c)) continue
                    else {
                        strictFail(parser, "Attribute without value")
                        parser.tag.attributes[parser.attribName] = ""
                        parser.attribValue = ""
                        emitNode(parser, "onattribute",
                            { name : parser.attribName, value : "" })
                        parser.attribName = ""
                        if (c === ">") openTag(parser)
                        else if (is(nameStart, c)) {
                            parser.attribName = c
                            parser.state = S.ATTRIB_NAME
                        } else {
                            strictFail(parser, "Invalid attribute name")
                            parser.state = S.ATTRIB
                        }
                    }
                    continue

                case S.ATTRIB_VALUE:
                    if (is(whitespace, c)) continue
                    else if (is(quote, c)) {
                        parser.q = c
                        parser.state = S.ATTRIB_VALUE_QUOTED
                    } else {
                        strictFail(parser, "Unquoted attribute value")
                        parser.state = S.ATTRIB_VALUE_UNQUOTED
                        parser.attribValue = c
                    }
                    continue

                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
                        else parser.attribValue += c
                        continue
                    }
                    attrib(parser)
                    parser.q = ""
                    parser.state = S.ATTRIB_VALUE_CLOSED
                    continue

                case S.ATTRIB_VALUE_CLOSED:
                    if (is(whitespace, c)) {
                        parser.state = S.ATTRIB
                    } else if (c === ">") openTag(parser)
                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                    else if (is(nameStart, c)) {
                        strictFail(parser, "No whitespace between attributes")
                        parser.attribName = c
                        parser.attribValue = ""
                        parser.state = S.ATTRIB_NAME
                    } else strictFail(parser, "Invalid attribute name")
                    continue

                case S.ATTRIB_VALUE_UNQUOTED:
                    if (not(attribEnd,c)) {
                        if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
                        else parser.attribValue += c
                        continue
                    }
                    attrib(parser)
                    if (c === ">") openTag(parser)
                    else parser.state = S.ATTRIB
                    continue

                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (is(whitespace, c)) continue
                        else if (not(nameStart, c)) {
                            if (parser.script) {
                                parser.script += "</" + c
                                parser.state = S.SCRIPT
                            } else {
                                strictFail(parser, "Invalid tagname in closing tag.")
                            }
                        } else parser.tagName = c
                    }
                    else if (c === ">") closeTag(parser)
                    else if (is(nameBody, c)) parser.tagName += c
                    else if (parser.script) {
                        parser.script += "</" + parser.tagName
                        parser.tagName = ""
                        parser.state = S.SCRIPT
                    } else {
                        if (not(whitespace, c)) strictFail(parser,
                            "Invalid tagname in closing tag")
                        parser.state = S.CLOSE_TAG_SAW_WHITE
                    }
                    continue

                case S.CLOSE_TAG_SAW_WHITE:
                    if (is(whitespace, c)) continue
                    if (c === ">") closeTag(parser)
                    else strictFail(parser, "Invalid characters in closing tag")
                    continue

                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    switch(parser.state) {
                        case S.TEXT_ENTITY:
                            var returnState = S.TEXT, buffer = "textNode"
                            break

                        case S.ATTRIB_VALUE_ENTITY_Q:
                            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
                            break

                        case S.ATTRIB_VALUE_ENTITY_U:
                            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
                            break
                    }
                    if (c === ";") {
                        parser[buffer] += parseEntity(parser)
                        parser.entity = ""
                        parser.state = returnState
                    }
                    else if (is(entity, c)) parser.entity += c
                    else {
                        strictFail(parser, "Invalid character entity")
                        parser[buffer] += "&" + parser.entity + c
                        parser.entity = ""
                        parser.state = returnState
                    }
                    continue

                default:
                    throw new Error(parser, "Unknown state: " + parser.state)
            }
        } // while
        // cdata blocks can get very big under normal conditions. emit and move on.
        // if (parser.state === S.CDATA && parser.cdata) {
        //   emitNode(parser, "oncdata", parser.cdata)
        //   parser.cdata = ""
        // }
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
        return parser
    }

    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
        (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
                var MAX_SIZE = 0x4000;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                    return '';
                }
                var result = '';
                while (++index < length) {
                    var codePoint = Number(arguments[index]);
                    if (
                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                        codePoint < 0 || // not a valid Unicode code point
                        codePoint > 0x10FFFF || // not a valid Unicode code point
                        floor(codePoint) != codePoint // not an integer
                    ) {
                        throw RangeError('Invalid code point: ' + codePoint);
                    }
                    if (codePoint <= 0xFFFF) { // BMP code point
                        codeUnits.push(codePoint);
                    } else { // Astral code point; split in surrogate halves
                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint -= 0x10000;
                        highSurrogate = (codePoint >> 10) + 0xD800;
                        lowSurrogate = (codePoint % 0x400) + 0xDC00;
                        codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                    }
                }
                return result;
            };
            if (Object.defineProperty) {
                Object.defineProperty(String, 'fromCodePoint', {
                    'value': fromCodePoint,
                    'configurable': true,
                    'writable': true
                });
            } else {
                String.fromCodePoint = fromCodePoint;
            }
        }());
    }

})(typeof exports === "undefined" ? sax = {} : exports)
/**
 * Tiny stack for browser or server
 *
 * @author Jason Mulligan <jason.mulligan@avoidwork.com>
 * @copyright 2014 Jason Mulligan
 * @license BSD-3 <https://raw.github.com/avoidwork/tiny-stack/master/LICENSE>
 * @link http://avoidwork.github.io/tiny-stack
 * @module tiny-stack
 * @version 0.1.0
 */

;( function ( global ) {

"use strict";

/**
 * TinyStack
 *
 * @constructor
 */
function TinyStack () {
	this.data = [null];
	this.top  = 0;
}

/**
 * Clears the stack
 *
 * @method clear
 * @memberOf TinyStack
 * @return {Object} {@link TinyStack}
 */
TinyStack.prototype.clear = function clear () {
	this.data = [null];
	this.top  = 0;

	return this;
};

/**
 * Gets the size of the stack
 *
 * @method length
 * @memberOf TinyStack
 * @return {Number} Size of stack
 */
TinyStack.prototype.length = function length () {
	return this.top;
};

/**
 * Gets the item at the top of the stack
 *
 * @method peek
 * @memberOf TinyStack
 * @return {Mixed} Item at the top of the stack
 */
TinyStack.prototype.peek = function peek () {
	return this.data[this.top];
};

/**
 * Gets & removes the item at the top of the stack
 *
 * @method pop
 * @memberOf TinyStack
 * @return {Mixed} Item at the top of the stack
 */
TinyStack.prototype.pop = function pop () {
	if ( this.top > 0 ) {
		this.top--;

		return this.data.pop();
	}
	else {
		return undefined;
	}
};

/**
 * Pushes an item onto the stack
 *
 * @method push
 * @memberOf TinyStack
 * @return {Object} {@link TinyStack}
 */
TinyStack.prototype.push = function push ( arg ) {
	this.data[++this.top] = arg;

	return this;
};

/**
 * TinyStack factory
 *
 * @method factory
 * @return {Object} {@link TinyStack}
 */
function factory () {
	return new TinyStack();
}

// Node, AMD & window supported
if ( typeof exports != "undefined" ) {
	module.exports = factory;
}
else if ( typeof define == "function" ) {
	define( function () {
		return factory;
	} );
}
else {
	global.stack = factory;
}
} )( this );

'use strict';

function Base() { }

Base.prototype.get = function(name) {
    return this.$model.properties.get(this, name);
};

Base.prototype.set = function(name, value) {
    this.$model.properties.set(this, name, value);
};

//
//module.exports = Base;
var parseName = function(name, defaultPrefix) {
    var parts = name.split(/:/),
        localName, prefix;

    // no prefix (i.e. only local name)
    if (parts.length === 1) {
        localName = name;
        prefix = defaultPrefix;
    } else
    // prefix + local name
    if (parts.length === 2) {
        localName = parts[1];
        prefix = parts[0];
    } else {
        throw new Error('expected <prefix:localName> or <localName>, got ' + name);
    }

    name = (prefix ? prefix + ':' : '') + localName;

    return {
        name: name,
        prefix: prefix,
        localName: localName
    };
};




'use strict';


/**
 * A utility that gets and sets properties of model elements.
 *
 * @param {Model} model
 */
function Properties(model) {
    this.model = model;
}

//module.exports = Properties;


/**
 * Sets a named property on the target element
 *
 * @param {Object} target
 * @param {String} name
 * @param {Object} value
 */
Properties.prototype.set = function(target, name, value) {

    var property = this.model.getPropertyDescriptor(target, name);

    if (!property) {
        target.$attrs[name] = value;
    } else {
        Object.defineProperty(target, property.name, {
            enumerable: !property.isReference,
            writable: true,
            value: value
        });
    }
};

/**
 * Returns the named property of the given element
 *
 * @param  {Object} target
 * @param  {String} name
 *
 * @return {Object}
 */
Properties.prototype.get = function(target, name) {

    var property = this.model.getPropertyDescriptor(target, name);

    if (!property) {
        return target.$attrs[name];
    }

    var propertyName = property.name;

    // check if access to collection property and lazily initialize it
    if (!target[propertyName] && property.isMany) {
        Object.defineProperty(target, propertyName, {
            enumerable: !property.isReference,
            writable: true,
            value: []
        });
    }

    return target[propertyName];
};


/**
 * Define a property on the target element
 *
 * @param  {Object} target
 * @param  {String} name
 * @param  {Object} options
 */
Properties.prototype.define = function(target, name, options) {
    Object.defineProperty(target, name, options);
};


/**
 * Define the descriptor for an element
 */
Properties.prototype.defineDescriptor = function(target, descriptor) {
    this.define(target, '$descriptor', { value: descriptor });
};

/**
 * Define the model for an element
 */
Properties.prototype.defineModel = function(target, model) {
    this.define(target, '$model', { value: model });
};
'use strict';

//var _ = require('lodash');
//
//var Base = require('./base');


function Factory(model, properties) {
    this.model = model;
    this.properties = properties;
}

//module.exports = Factory;


Factory.prototype.createType = function(descriptor) {

    var model = this.model;

    var props = this.properties,
        prototype = Object.create(Base.prototype);

    // initialize default values
    _.forEach(descriptor.properties, function(p) {
        if (!p.isMany && p.default !== undefined) {
            prototype[p.name] = p.default;
        }
    });

    props.defineModel(prototype, model);
    props.defineDescriptor(prototype, descriptor);

    var name = descriptor.ns.name;

    /**
     * The new type constructor
     */
    function ModdleElement(attrs) {
        props.define(this, '$type', { value: name, enumerable: true });
        props.define(this, '$attrs', { value: {} });
        props.define(this, '$parent', { writable: true });

        _.forEach(attrs, function(val, key) {
            this.set(key, val);
        }, this);
    }

    ModdleElement.prototype = prototype;

    ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

    // static links
    props.defineModel(ModdleElement, model);
    props.defineDescriptor(ModdleElement, descriptor);

    return ModdleElement;
};

/**
 * Built-in moddle types
 */
var BUILTINS = {
    String: true,
    Boolean: true,
    Integer: true,
    Real: true,
    Element: true
};

/**
 * Converters for built in types from string representations
 */
var TYPE_CONVERTERS = {
    String: function(s) { return s; },
    Boolean: function(s) { return s === 'true'; },
    Integer: function(s) { return parseInt(s, 10); },
    Real: function(s) { return parseFloat(s, 10); }
};

/**
 * Convert a type to its real representation
 */
var coerceType = function(type, value) {

    var converter = TYPE_CONVERTERS[type];

    if (converter) {
        return converter(value);
    } else {
        return value;
    }
};

/**
 * Return whether the given type is built-in
 */
var isBuiltIn = function(type) {
    return !!BUILTINS[type];
};

/**
 * Return whether the given type is simple
 */
var isSimple = function(type) {
    return !!TYPE_CONVERTERS[type];
};
'use strict';

//var _ = require('lodash');
//
//var Types = require('./types');
//    DescriptorBuilder = require('./descriptor-builder');
//
//var this.parseName = parseName;


function Registry(packages, properties, options) {
    this.options = _.extend({ generateId: 'id' }, options || {});

    this.packageMap = {};
    this.typeMap = {};

    this.packages = [];

    this.properties = properties;

    _.forEach(packages, this.registerPackage, this);
}

//module.exports = Registry;


Registry.prototype.getPackage = function(uriOrPrefix) {
    return this.packageMap[uriOrPrefix];
};

Registry.prototype.getPackages = function() {
    return this.packages;
};


Registry.prototype.registerPackage = function(pkg) {

    // register types
    _.forEach(pkg.types, function(descriptor) {
        this.registerType(descriptor, pkg);
    }, this);

    this.packageMap[pkg.uri] = this.packageMap[pkg.prefix] = pkg;
    this.packages.push(pkg);
};


/**
 * Register a type from a specific package with us
 */
Registry.prototype.registerType = function(type, pkg) {

    var ns = this.parseName(type.name, pkg.prefix),
        name = ns.name,
        propertiesByName = {};

    // parse properties
    _.forEach(type.properties, function(p) {

        // namespace property names
        var propertyNs = this.parseName(p.name, ns.prefix),
            propertyName = propertyNs.name;

        // namespace property types
        if (!isBuiltIn( p.type)) {
            p.type = this.parseName(p.type, propertyNs.prefix).name;
        }

        _.extend(p, {
            ns: propertyNs,
            name: propertyName
        });

        propertiesByName[propertyName] = p;
    },this);

    // update ns + name
    _.extend(type, {
        ns: ns,
        name: name,
        propertiesByName: propertiesByName
    });

    // link to package
    this.definePackage(type, pkg);

    // register
    this.typeMap[name] = type;
};


/**
 * Traverse the type hierarchy from bottom to top.
 */
Registry.prototype.mapTypes = function(nsName, iterator) {

    var type = this.typeMap[nsName.name];

    if (!type) {
        throw new Error('unknown type <' + nsName.name + '>');
    }

    _.forEach(type.superClass, function(cls) {
        var parentNs = this.parseName(cls, nsName.prefix);
        this.mapTypes(parentNs, iterator);
    }, this);

    iterator(type);
};


/**
 * Returns the effective descriptor for a type.
 *
 * @param  {String} type the namespaced name (ns:localName) of the type
 *
 * @return {Descriptor} the resulting effective descriptor
 */
Registry.prototype.getEffectiveDescriptor = function(name) {

    var options = this.options,
        nsName = this.parseName(name);

    var builder = new DescriptorBuilder(nsName);

    this.mapTypes(nsName, function(type) {
        builder.addTrait(type);
    });

    // check we have an id assigned
    var id = this.options.generateId;
    if (id && !builder.hasProperty(id)) {
        builder.addIdProperty(id);
    }

    var descriptor = builder.build();

    // define package link
    this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

    return descriptor;
};


Registry.prototype.definePackage = function(target, pkg) {
    this.properties.define(target, '$pkg', { value: pkg });
};

Registry.prototype.parseName = function(name, defaultPrefix) {
    var parts = name.split(/:/),
        localName, prefix;

    // no prefix (i.e. only local name)
    if (parts.length === 1) {
        localName = name;
        prefix = defaultPrefix;
    } else
    // prefix + local name
    if (parts.length === 2) {
        localName = parts[1];
        prefix = parts[0];
    } else {
        throw new Error('expected <prefix:localName> or <localName>, got ' + name);
    }

    name = (prefix ? prefix + ':' : '') + localName;

    return {
        name: name,
        prefix: prefix,
        localName: localName
    };
};





'use strict';

//var _ = require('lodash');
//
//var parseNameNs = require('./ns').parseName;


function DescriptorBuilder(nameNs) {
    this.ns = nameNs;
    this.name = nameNs.name;
    this.allTypes = [];
    this.properties = [];
    this.propertiesByName = {};
}

//module.exports = DescriptorBuilder;


DescriptorBuilder.prototype.build = function() {
    return _.pick(this, [ 'ns', 'name', 'allTypes', 'properties', 'propertiesByName', 'bodyProperty' ]);
};

DescriptorBuilder.prototype.addProperty = function(p, idx) {
    this.addNamedProperty(p, true);

    var properties = this.properties;

    if (idx !== undefined) {
        properties.splice(idx, 0, p);
    } else {
        properties.push(p);
    }
};


DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty) {
    var oldNameNs = oldProperty.ns;

    var props = this.properties,
        propertiesByName = this.propertiesByName;

    if (oldProperty.isBody) {

        if (!newProperty.isBody) {
            throw new Error(
                'property <' + newProperty.ns.name + '> must be body property ' +
                'to refine <' + oldProperty.ns.name + '>');
        }

        // TODO: Check compatibility
        this.setBodyProperty(newProperty, false);
    }

    this.addNamedProperty(newProperty, true);

    // replace old property at index with new one
    var idx = props.indexOf(oldProperty);
    if (idx === -1) {
        throw new Error('property <' + oldNameNs.name + '> not found in property list');
    }

    props[idx] = newProperty;

    // replace propertiesByName entry with new property
    propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};


DescriptorBuilder.prototype.redefineProperty = function(p) {

    var nsPrefix = p.ns.prefix;
    var parts = p.redefines.split('#');

    var name = parseNameNs(parts[0], nsPrefix);
    var attrName = parseNameNs(parts[1], name.prefix).name;

    var redefinedProperty = this.propertiesByName[attrName];
    if (!redefinedProperty) {
        throw new Error('refined property <' + attrName + '> not found');
    } else {
        this.replaceProperty(redefinedProperty, p);
    }

    delete p.redefines;
};

DescriptorBuilder.prototype.addNamedProperty = function(p, validate) {
    var ns = p.ns,
        propsByName = this.propertiesByName;

    if (validate) {
        this.assertNotDefined(p, ns.name);
        this.assertNotDefined(p, ns.localName);
    }

    propsByName[ns.name] = propsByName[ns.localName] = p;
};

DescriptorBuilder.prototype.removeNamedProperty = function(p) {
    var ns = p.ns,
        propsByName = this.propertiesByName;

    delete propsByName[ns.name];
    delete propsByName[ns.localName];
};

DescriptorBuilder.prototype.setBodyProperty = function(p, validate) {

    if (validate && this.bodyProperty) {
        throw new Error(
            'body property defined multiple times ' +
            '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
    }

    this.bodyProperty = p;
};

DescriptorBuilder.prototype.addIdProperty = function(name) {
    var nameNs = parseNameNs(name, this.ns.prefix);

    var p = {
        name: nameNs.localName,
        type: 'String',
        isAttr: true,
        ns: nameNs
    };

    // ensure that id is always the first attribute (if present)
    this.addProperty(p, 0);
};

DescriptorBuilder.prototype.assertNotDefined = function(p, name) {
    var propertyName = p.name,
        definedProperty = this.propertiesByName[propertyName];

    if (definedProperty) {
        throw new Error(
            'property <' + propertyName + '> already defined; ' +
            'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +
            '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
    }
};

DescriptorBuilder.prototype.hasProperty = function(name) {
    return this.propertiesByName[name];
};

DescriptorBuilder.prototype.addTrait = function(t) {

    var allTypes = this.allTypes;

    if (allTypes.indexOf(t) !== -1) {
        return;
    }

    _.forEach(t.properties, function(p) {

        // clone property to allow extensions
        p = _.extend({}, p, {
            name: p.ns.localName
        });

        Object.defineProperty(p, 'definedBy', {
            value: t
        });

        // add redefine support
        if (p.redefines) {
            this.redefineProperty(p);
        } else {
            if (p.isBody) {
                this.setBodyProperty(p);
            }
            this.addProperty(p);
        }
    }, this);

    allTypes.push(t);
};
'use strict';

//var _ = require('lodash');
//
//var Types = require('./types'),
//    Factory = require('./factory'),
//    Registry = require('./registry'),
//    Properties = require('./properties');
//
//var parseNameNs = require('./ns').parseName;


//// Moddle implementation /////////////////////////////////////////////////

/**
 * @class Moddle
 *
 * A model that can be used to create elements of a specific type.
 *
 * @example
 *
 * var Moddle = require('moddle');
 *
 * var pkg = {
 *   name: 'mypackage',
 *   prefix: 'my',
 *   types: [
 *     { name: 'Root' }
 *   ]
 * };
 *
 * var moddle = new Moddle([pkg]);
 *
 * @param {Array<Package>} packages  the packages to contain
 * @param {Object} options  additional options to pass to the model
 */
function Moddle(packages, options) {

    options = options || {};

    this.properties = new Properties(this);

    this.factory = new Factory(this, this.properties);
    this.registry = new Registry(packages, this.properties, options);

    this.typeCache = {};
}

//module.exports = Moddle;


/**
 * Create an instance of the specified type.
 *
 * @method Moddle#create
 *
 * @example
 *
 * var foo = moddle.create('my:Foo');
 * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @param  {Object} attrs   a number of attributes to initialize the model instance with
 * @return {Object}         model instance
 */
Moddle.prototype.create = function(descriptor, attrs) {
    var Type = this.getType(descriptor);

    if (!Type) {
        throw new Error('unknown type <' + descriptor + '>');
    }

    return new Type(attrs);
};


/**
 * Returns the type representing a given descriptor
 *
 * @method Moddle#getType
 *
 * @example
 *
 * var Foo = moddle.getType('my:Foo');
 * var foo = new Foo({ 'id' : 'FOO_1' });
 *
 * @param  {String|Object} descriptor the type descriptor or name know to the model
 * @return {Object}         the type representing the descriptor
 */
Moddle.prototype.getType = function(descriptor) {

    var cache = this.typeCache;

    var name = _.isString(descriptor) ? descriptor : descriptor.ns.name;

    var type = cache[name];

    if (!type) {
        descriptor = this.registry.getEffectiveDescriptor(name);
        type = cache[descriptor.name] = this.factory.createType(descriptor);
    }

    return type;
};


/**
 * Creates an any-element type to be used within model instances.
 *
 * This can be used to create custom elements that lie outside the meta-model.
 * The created element contains all the meta-data required to serialize it
 * as part of meta-model elements.
 *
 * @method Moddle#createAny
 *
 * @example
 *
 * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
 *   value: 'bar'
 * });
 *
 * var container = moddle.create('my:Container', 'http://my', {
 *   any: [ foo ]
 * });
 *
 * // go ahead and serialize the stuff
 *
 *
 * @param  {String} name  the name of the element
 * @param  {String} nsUri the namespace uri of the element
 * @param  {Object} [properties] a map of properties to initialize the instance with
 * @return {Object} the any type instance
 */
Moddle.prototype.createAny = function(name, nsUri, properties) {

    var nameNs = parseNameNs(name);

    var element = {
        $type: name
    };

    var descriptor = {
        name: name,
        isGeneric: true,
        ns: {
            prefix: nameNs.prefix,
            localName: nameNs.localName,
            uri: nsUri
        }
    };

    this.properties.defineDescriptor(element, descriptor);
    this.properties.defineModel(element, this);
    this.properties.define(element, '$parent', { enumerable: false, writable: true });

    _.forEach(properties, function(a, key) {
        if (_.isObject(a) && a.value !== undefined) {
            element[a.name] = a.value;
        } else {
            element[key] = a;
        }
    });

    return element;
};

/**
 * Returns a registered package by uri or prefix
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackage = function(uriOrPrefix) {
    return this.registry.getPackage(uriOrPrefix);
};

/**
 * Returns a snapshot of all known packages
 *
 * @return {Object} the package
 */
Moddle.prototype.getPackages = function() {
    return this.registry.getPackages();
};

/**
 * Returns the descriptor for an element
 */
Moddle.prototype.getElementDescriptor = function(element) {
    return element.$descriptor;
};

/**
 * Returns true if the given descriptor or instance
 * represents the given type.
 *
 * May be applied to this, if element is omitted.
 */
Moddle.prototype.hasType = function(element, type) {
    if (type === undefined) {
        type = element;
        element = this;
    }

    var descriptor = element.$model.getElementDescriptor(element);

    return !!_.find(descriptor.allTypes, function(t) {
        return t.name === type;
    });
};


/**
 * Returns the descriptor of an elements named property
 */
Moddle.prototype.getPropertyDescriptor = function(element, property) {
    return this.getElementDescriptor(element).propertiesByName[property];
};
'use strict';


function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function lower(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
}

function hasLowerCaseAlias(pkg) {
    return pkg.xml && pkg.xml.alias === 'lowerCase';
}


var aliasToName = function(alias, pkg) {
    if (hasLowerCaseAlias(pkg)) {
        return capitalize(alias);
    } else {
        return alias;
    }
};

var nameToAlias = function(name, pkg) {
    if (hasLowerCaseAlias(pkg)) {
        return lower(name);
    } else {
        return name;
    }
};

var DEFAULT_NS_MAP = {
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
};

//
//module.exports.DEFAULT_NS_MAP = {
//    'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
//};
'use strict';

//var sax = require('sax'),
//    _ = require('lodash');
//


//var common = require('./common'),
//    Types = require('moddle').types,
//    Stack = require('tiny-stack'),
//    parseNameNs = require('moddle').ns.parseName,
var parseNameNs = parseName;
var aliasToName = aliasToName;


function parseNodeAttributes(node) {
    var nodeAttrs = node.attributes;

    return _.reduce(nodeAttrs, function(result, v, k) {
        var name, ns;

        if (!v.local) {
            name = v.prefix;
        } else {
            ns = parseNameNs(v.name, v.prefix);
            name = ns.name;
        }

        result[name] = v.value;
        return result;
    }, {});
}

/**
 * Normalizes namespaces for a node given an optional default namespace and a
 * number of mappings from uris to default prefixes.
 *
 * @param  {XmlNode} node
 * @param  {Model} model the model containing all registered namespaces
 * @param  {Uri} defaultNsUri
 */
function normalizeNamespaces(node, model, defaultNsUri) {
    var uri, childUri, prefix;

    uri = node.uri || defaultNsUri;

    if (uri) {
        var pkg = model.getPackage(uri);

        if (pkg) {
            prefix = pkg.prefix;
        } else {
            prefix = node.prefix;
        }

        node.prefix = prefix;
        node.uri = uri;
    }

    _.forEach(node.attributes, function(attr) {
        normalizeNamespaces(attr, model, null);
    });
}

/**
 * A parse context.
 *
 * @class
 *
 * @param {ElementHandler} parseRoot the root handler for parsing a document
 */
function Context(parseRoot) {

    var elementsById = {};
    var references = [];

    var warnings = [];

    this.addReference = function(reference) {
        references.push(reference);
    };

    this.addElement = function(id, element) {

        if (!id || !element) {
            throw new Error('[xml-reader] id or ctx must not be null');
        }

        elementsById[id] = element;
    };

    this.addWarning = function (w) {
        warnings.push(w);
    };

    this.warnings = warnings;
    this.references = references;

    this.elementsById = elementsById;

    this.parseRoot = parseRoot;
}


function BaseHandler() {}

BaseHandler.prototype.handleEnd = function() {};
BaseHandler.prototype.handleText = function() {};
BaseHandler.prototype.handleNode = function() {};

function BodyHandler() {}

BodyHandler.prototype = new BaseHandler();

BodyHandler.prototype.handleText = function(text) {
    this.body = (this.body || '') + text;
};

function ReferenceHandler(property, context) {
    this.property = property;
    this.context = context;
}

ReferenceHandler.prototype = new BodyHandler();

ReferenceHandler.prototype.handleNode = function(node) {

    if (this.element) {
        throw new Error('expected no sub nodes');
    } else {
        this.element = this.createReference(node);
    }

    return this;
};

ReferenceHandler.prototype.handleEnd = function() {
    this.element.id = this.body;
};

ReferenceHandler.prototype.createReference = function() {
    return {
        property: this.property.ns.name,
        id: ''
    };
};

function ValueHandler(propertyDesc, element) {
    this.element = element;
    this.propertyDesc = propertyDesc;
}

ValueHandler.prototype = new BodyHandler();

ValueHandler.prototype.handleEnd = function() {

    var value = this.body,
        element = this.element,
        propertyDesc = this.propertyDesc;

    value = coerceType(propertyDesc.type, value);

    if (propertyDesc.isMany) {
        element.get(propertyDesc.name).push(value);
    } else {
        element.set(propertyDesc.name, value);
    }
};


function BaseElementHandler() {}

BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

BaseElementHandler.prototype.handleNode = function(node) {
    var parser = this;

    if (!this.element) {
        this.element = this.createElement(node);
        var id = this.element.id;

        if (id) {
            this.context.addElement(id, this.element);
        }
    } else {
        parser = this.handleChild(node);
    }

    return parser;
};

/**
 * @class XMLReader.ElementHandler
 *
 */
function ElementHandler(model, type, context) {
    this.model = model;
    this.type = model.getType(type);
    this.context = context;
}

ElementHandler.prototype = new BaseElementHandler();

ElementHandler.prototype.addReference = function(reference) {
    this.context.addReference(reference);
};

ElementHandler.prototype.handleEnd = function() {

    var value = this.body,
        element = this.element,
        descriptor = element.$descriptor,
        bodyProperty = descriptor.bodyProperty;

    if (bodyProperty && value !== undefined) {
        value = coerceType(bodyProperty.type, value);
        element.set(bodyProperty.name, value);
    }
};

/**
 * Create an instance of the model from the given node.
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.createElement = function(node) {
    var attributes = parseNodeAttributes(node),
        Type = this.type,
        descriptor = Type.$descriptor,
        context = this.context,
        instance = new Type({});

    _.forEach(attributes, function(value, name) {

        var prop = descriptor.propertiesByName[name];

        if (prop && prop.isReference) {
            context.addReference({
                element: instance,
                property: prop.ns.name,
                id: value
            });
        } else {
            if (prop) {
                value = coerceType(prop.type, value);
            }

            instance.set(name, value);
        }
    });

    return instance;
};

ElementHandler.prototype.getPropertyForElement = function(nameNs) {
    if (_.isString(nameNs)) {
        nameNs = parseNameNs(nameNs);
    }

    var type = this.type,
        model = this.model,
        descriptor = type.$descriptor;

    var propertyName = nameNs.name;

    var property = descriptor.propertiesByName[propertyName];

    // search for properties by name first
    if (property) {
        return property;
    }

    var pkg = model.getPackage(nameNs.prefix);

    if (pkg) {
        var typeName = nameNs.prefix + ':' + aliasToName(nameNs.localName, descriptor.$pkg),
            elementType = model.getType(typeName);

        // search for collection members later
        property = _.find(descriptor.properties, function(p) {
            return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
        });

        if (property) {
            return _.extend({}, property, { effectiveType: elementType.$descriptor.name });
        }
    } else {
        // parse unknown element (maybe extension)
        property = _.find(descriptor.properties, function(p) {
            return !p.isReference && !p.isAttribute && p.type === 'Element';
        });

        if (property) {
            return property;
        }
    }

    throw new Error('unrecognized element <' + nameNs.name + '>');
};

ElementHandler.prototype.toString = function() {
    return 'ElementDescriptor[' + this.type.$descriptor.name + ']';
};

ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
    return new ValueHandler(propertyDesc, element);
};

ElementHandler.prototype.referenceHandler = function(propertyDesc) {
    return new ReferenceHandler(propertyDesc, this.context);
};

ElementHandler.prototype.handler = function(type) {
    if (type === 'Element') {
        return new GenericElementHandler(this.model, type, this.context);
    } else {
        return new ElementHandler(this.model, type, this.context);
    }
};

/**
 * Handle the child element parsing
 *
 * @param  {Element} node the xml node
 */
ElementHandler.prototype.handleChild = function(node) {
    var nameNs = parseNameNs(node.local, node.prefix);

    var propertyDesc, type, element, childHandler;

    propertyDesc = this.getPropertyForElement(nameNs);
    element = this.element;

    type = propertyDesc.effectiveType || propertyDesc.type;

    if (isSimple(propertyDesc.type)) {
        return this.valueHandler(propertyDesc, element);
    }

    if (propertyDesc.isReference) {
        childHandler = this.referenceHandler(propertyDesc).handleNode(node);
    } else {
        childHandler = this.handler(type).handleNode(node);
    }

    var newElement = childHandler.element;

    // child handles may decide to skip elements
    // by not returning anything
    if (newElement !== undefined) {

        if (propertyDesc.isMany) {
            element.get(propertyDesc.name).push(newElement);
        } else {
            element.set(propertyDesc.name, newElement);
        }

        if (propertyDesc.isReference) {
            _.extend(newElement, {
                element: element
            });

            this.context.addReference(newElement);
        } else {
            // establish child -> parent relationship
            newElement.$parent = element;
        }
    }

    return childHandler;
};


function GenericElementHandler(model, type, context) {
    this.model = model;
    this.context = context;
}

GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

GenericElementHandler.prototype.createElement = function(node) {

    var name = node.name,
        prefix = node.prefix,
        uri = node.ns[prefix],
        attributes = node.attributes;

    return this.model.createAny(name, uri, attributes);
};

GenericElementHandler.prototype.handleChild = function(node) {

    var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
        element = this.element;

    var newElement = handler.element,
        children;

    if (newElement !== undefined) {
        children = element.$children = element.$children || [];
        children.push(newElement);

        // establish child -> parent relationship
        newElement.$parent = element;
    }

    return handler;
};

GenericElementHandler.prototype.handleText = function(text) {
    this.body = this.body || '' + text;
};

GenericElementHandler.prototype.handleEnd = function() {
    if (this.body) {
        this.element.$body = this.body;
    }
};

/**
 * A reader for a meta-model
 *
 * @class XMLReader
 *
 * @param {Model} model used to read xml files
 */
function XMLReader(model) {
    this.model = model;
}


XMLReader.prototype.fromXML = function(xml, rootHandler, done) {

    var context = new Context(rootHandler);

    var parser = sax.parser(true, { xmlns: true, trim: true });
        stackInstance =  stack();

    var model = this.model,
        self = this;

    rootHandler.context = context;

    // push root handler
    stackInstance.push(rootHandler);


    function resolveReferences() {

        var elementsById = context.elementsById;
        var references = context.references;

        var i, r;

        for (i = 0; !!(r = references[i]); i++) {
            var element = r.element;
            var reference = elementsById[r.id];
            var property = element.$descriptor.propertiesByName[r.property];

            if (!reference) {
                context.addWarning({
                    message: 'unresolved reference <' + r.id + '>',
                    element: r.element,
                    property: r.property,
                    value: r.id
                });
            }

            if (property.isMany) {
                var collection = element.get(property.name),
                    idx = collection.indexOf(r);

                if (!reference) {
                    // remove unresolvable reference
                    collection.splice(idx, 1);
                } else {
                    // update reference
                    collection[idx] = reference;
                }
            } else {
                element.set(property.name, reference);
            }
        }
    }

    function handleClose(tagName) {
        stackInstance.pop().handleEnd();
    }

    function handleOpen(node) {
        var handler = stackInstance.peek();

        normalizeNamespaces(node, model);

        try {
            stackInstance.push(handler.handleNode(node));
        } catch (e) {

            var line = this.line,
                column = this.column;

            throw new Error(
                'unparsable content <' + node.name + '> detected\n\t' +
                'line: ' + line + '\n\t' +
                'column: ' + column + '\n\t' +
                'nested error: ' + e.message);
        }
    }

    function handleText(text) {
        stackInstance.peek().handleText(text);
    }

    parser.onopentag = handleOpen;
    parser.oncdata = parser.ontext = handleText;
    parser.onclosetag = handleClose;
    parser.onend = resolveReferences;

    // deferred parse XML to make loading really ascnchronous
    // this ensures the execution environment (node or browser)
    // is kept responsive and that certain optimization strategies
    // can kick in
    _.defer(function() {
        var error;

        try {
            parser.write(xml).close();
        } catch (e) {
            error = e;
        }

        done(error, error ? undefined : rootHandler.element, context);
    });
};

XMLReader.prototype.handler = function(name) {
    return new ElementHandler(this.model, name);
};
'use strict';

//var _ = require('lodash');

//var Types = require('moddle').types,
//    common = require('./common'),
    var parseNameNs = parseName;
    var nameToAlias = nameToAlias;

var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';

var CDATA_ESCAPE = /[<>"&]+/;

var DEFAULT_NS_MAP = DEFAULT_NS_MAP;


function nsName(ns) {
    if (_.isString(ns)) {
        return ns;
    } else {
        return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
    }
}

function getElementNs(ns, descriptor) {
    if (descriptor.isGeneric) {
        return descriptor.name;
    } else {
        return _.extend({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
    }
}

function getPropertyNs(ns, descriptor) {
    return _.extend({ localName: descriptor.ns.localName }, ns);
}

function getSerializableProperties(element) {
    var descriptor = element.$descriptor;

    return _.filter(descriptor.properties, function(p) {
        var name = p.name;

        // do not serialize defaults
        if (!element.hasOwnProperty(name)) {
            return false;
        }

        var value = element[name];

        // do not serialize default equals
        if (value === p.default) {
            return false;
        }

        return p.isMany ? value.length : true;
    });
}

/**
 * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
 *
 * @param {String} str the string to escape
 * @return {String} the escaped string
 */
function escapeAttr(str) {
    var escapeMap = {
        '\n': '&#10;',
        '\n\r': '&#10;',
        '"': '&quot;'
    };

    // ensure we are handling strings here
    str = _.isString(str) ? str : '' + str;

    return str.replace(/(\n|\n\r|")/g, function(str) {
        return escapeMap[str];
    });
}

function filterAttributes(props) {
    return _.filter(props, function(p) { return p.isAttr; });
}

function filterContained(props) {
    return _.filter(props, function(p) { return !p.isAttr; });
}


function ReferenceSerializer(parent, ns) {
    this.ns = ns;
}

ReferenceSerializer.prototype.build = function(element) {
    this.element = element;
    return this;
};

ReferenceSerializer.prototype.serializeTo = function(writer) {
    writer
        .appendIndent()
        .append('<' + nsName(this.ns) + '>' + this.element.id + '</' + nsName(this.ns) + '>')
        .appendNewLine();
};

function BodySerializer() {}

BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {
    var value = this.value,
        escape = this.escape;

    if (escape) {
        writer.append('<![CDATA[');
    }

    writer.append(this.value);

    if (escape) {
        writer.append(']]>');
    }
};

BodySerializer.prototype.build = function(prop, value) {
    this.value = value;

    if (prop.type === 'String' && CDATA_ESCAPE.test(value)) {
        this.escape = true;
    }

    return this;
};

function ValueSerializer(ns) {
    this.ns = ns;
}

ValueSerializer.prototype = new BodySerializer();

ValueSerializer.prototype.serializeTo = function(writer) {

    writer
        .appendIndent()
        .append('<' + nsName(this.ns) + '>');

    this.serializeValue(writer);

    writer
        .append( '</' + nsName(this.ns) + '>')
        .appendNewLine();
};

function ElementSerializer(parent, ns) {
    this.body = [];
    this.attrs = [];

    this.parent = parent;
    this.ns = ns;
}

ElementSerializer.prototype.build = function(element) {
    this.element = element;

    var otherAttrs = this.parseNsAttributes(element);

    if (!this.ns) {
        this.ns = this.nsTagName(element.$descriptor);
    }

    if (element.$descriptor.isGeneric) {
        this.parseGeneric(element);
    } else {
        var properties = getSerializableProperties(element);

        this.parseAttributes(filterAttributes(properties));
        this.parseContainments(filterContained(properties));

        this.parseGenericAttributes(element, otherAttrs);
    }

    return this;
};

ElementSerializer.prototype.nsTagName = function(descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getElementNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getPropertyNs(effectiveNs, descriptor);
};

ElementSerializer.prototype.isLocalNs = function(ns) {
    return ns.uri === this.ns.uri;
};

ElementSerializer.prototype.nsAttributeName = function(element) {

    var ns;

    if (_.isString(element)) {
        ns = parseNameNs(element);
    } else
    if (element.ns) {
        ns = element.ns;
    }

    var effectiveNs = this.logNamespaceUsed(ns);

    // strip prefix if same namespace like parent
    if (this.isLocalNs(effectiveNs)) {
        return { localName: ns.localName };
    } else {
        return _.extend({ localName: ns.localName }, effectiveNs);
    }
};

ElementSerializer.prototype.parseGeneric = function(element) {

    var self = this,
        body = this.body,
        attrs = this.attrs;

    _.forEach(element, function(val, key) {

        if (key === '$body') {
            body.push(new BodySerializer().build({ type: 'String' }, val));
        } else
        if (key === '$children') {
            _.forEach(val, function(child) {
                body.push(new ElementSerializer(self).build(child));
            });
        } else
        if (key.indexOf('$') !== 0) {
            attrs.push({ name: key, value: escapeAttr(val) });
        }
    });
};

/**
 * Parse namespaces and return a list of left over generic attributes
 *
 * @param  {Object} element
 * @return {Array<Object>}
 */
ElementSerializer.prototype.parseNsAttributes = function(element) {
    var self = this;

    var genericAttrs = element.$attrs;

    var attributes = [];

    // parse namespace attributes first
    // and log them. push non namespace attributes to a list
    // and process them later
    _.forEach(genericAttrs, function(value, name) {
        var nameNs = parseNameNs(name);

        if (nameNs.prefix === 'xmlns') {
            self.logNamespace({ prefix: nameNs.localName, uri: value });
        } else
        if (!nameNs.prefix && nameNs.localName === 'xmlns') {
            self.logNamespace({ uri: value });
        } else {
            attributes.push({ name: name, value: value });
        }
    });

    return attributes;
};

ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {

    var self = this;

    _.forEach(attributes, function(attr) {
        try {
            self.addAttribute(self.nsAttributeName(attr.name), attr.value);
        } catch (e) {
            console.warn('[writer] missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);
        }
    });
};

ElementSerializer.prototype.parseContainments = function(properties) {

    var self = this,
        body = this.body,
        element = this.element,
        typeDesc = element.$descriptor;

    _.forEach(properties, function(p) {
        var value = element.get(p.name),
            isReference = p.isReference,
            isMany = p.isMany;

        var ns = self.nsPropertyTagName(p);

        if (!isMany) {
            value = [ value ];
        }

        if (p.isBody) {
            body.push(new BodySerializer().build(p, value[0]));
        } else
        //if (Types.isSimple(p.type)) {
        if (isSimple(p.type)) {
            _.forEach(value, function(v) {
                body.push(new ValueSerializer(ns).build(p, v));
            });
        } else
        if (isReference) {
            _.forEach(value, function(v) {
                body.push(new ReferenceSerializer(self, ns).build(v));
            });
        } else {
            // allow serialization via type
            // rather than element name
            var asType = p.serialize === 'xsi:type';

            _.forEach(value, function(v) {
                var serializer;

                if (asType) {
                    serializer = new TypeSerializer(self, ns);
                } else {
                    serializer = new ElementSerializer(self);
                }

                body.push(serializer.build(v));
            });
        }
    });
};

ElementSerializer.prototype.getNamespaces = function() {
    if (!this.parent) {
        if (!this.namespaces) {
            this.namespaces = {
                prefixMap: {},
                uriMap: {},
                used: {}
            };
        }
    } else {
        this.namespaces = this.parent.getNamespaces();
    }

    return this.namespaces;
};

ElementSerializer.prototype.logNamespace = function(ns) {
    var namespaces = this.getNamespaces();

    var existing = namespaces.uriMap[ns.uri];

    if (!existing) {
        namespaces.uriMap[ns.uri] = ns;
    }

    namespaces.prefixMap[ns.prefix] = ns.uri;

    return ns;
};

ElementSerializer.prototype.logNamespaceUsed = function(ns) {
    var element = this.element,
        model = element.$model,
        namespaces = this.getNamespaces();

    // ns may be
    //
    //   * prefix only
    //   * prefix:uri

    var prefix = ns.prefix;
    var uri = ns.uri || DEFAULT_NS_MAP[prefix] ||
        namespaces.prefixMap[prefix] || (model ? (model.getPackage(prefix) || {}).uri : null);

    if (!uri) {
        throw new Error('no namespace uri given for prefix <' + ns.prefix + '>');
    }

    ns = namespaces.uriMap[uri];

    if (!ns) {
        ns = this.logNamespace({ prefix: prefix, uri: uri });
    }

    if (!namespaces.used[ns.uri]) {
        namespaces.used[ns.uri] = ns;
    }

    return ns;
};

ElementSerializer.prototype.parseAttributes = function(properties) {
    var self = this,
        element = this.element;

    _.forEach(properties, function(p) {
        self.logNamespaceUsed(p.ns);

        var value = element.get(p.name);

        if (p.isReference) {
            value = value.id;
        }

        self.addAttribute(self.nsAttributeName(p), value);
    });
};

ElementSerializer.prototype.addAttribute = function(name, value) {
    var attrs = this.attrs;

    if (_.isString(value)) {
        value = escapeAttr(value);
    }

    attrs.push({ name: name, value: value });
};

ElementSerializer.prototype.serializeAttributes = function(writer) {
    var element = this.element,
        attrs = this.attrs,
        root = !this.parent,
        namespaces = this.namespaces;

    function collectNsAttrs() {
        return _.collect(namespaces.used, function(ns) {
            var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
            return { name: name, value: ns.uri };
        });
    }

    if (root) {
        attrs = collectNsAttrs().concat(attrs);
    }

    _.forEach(attrs, function(a) {
        writer
            .append(' ')
            .append(nsName(a.name)).append('="').append(a.value).append('"');
    });
};

ElementSerializer.prototype.serializeTo = function(writer) {
    var hasBody = this.body.length;

    writer
        .appendIndent()
        .append('<' + nsName(this.ns));

    this.serializeAttributes(writer);

    writer
        .append(hasBody ? '>' : ' />')
        .appendNewLine();

    writer.indent();

    _.forEach(this.body, function(b) {
        b.serializeTo(writer);
    });

    writer.unindent();

    if (hasBody) {
        writer
            .appendIndent()
            .append('</' + nsName(this.ns) + '>')
            .appendNewLine();
    }
};

/**
 * A serializer for types that handles serialization of data types
 */
function TypeSerializer(parent, ns) {
    ElementSerializer.call(this, parent, ns);
}

TypeSerializer.prototype = new ElementSerializer();

TypeSerializer.prototype.build = function(element) {
    this.element = element;
    this.typeNs = this.nsTagName(element.$descriptor);

    return ElementSerializer.prototype.build.call(this, element);
};

TypeSerializer.prototype.isLocalNs = function(ns) {
    return ns.uri === this.typeNs.uri;
};

function SavingWriter() {
    this.value = '';

    this.write = function(str) {
        this.value += str;
    };
}

function FormatingWriter(out, format) {

    var indent = [''];

    this.append = function(str) {
        out.write(str);

        return this;
    };

    this.appendNewLine = function() {
        if (format) {
            out.write('\n');
        }

        return this;
    };

    this.appendIndent = function() {
        if (format) {
            out.write(indent.join('  '));
        }

        return this;
    };

    this.indent = function() {
        indent.push('');
        return this;
    };

    this.unindent = function() {
        indent.pop();
        return this;
    };
}

/**
 * A writer for meta-model backed document trees
 *
 * @class XMLWriter
 */
function XMLWriter(options) {

    options = _.extend({ format: false, preamble: true }, options || {});

    function toXML(tree, writer) {
        var internalWriter = writer || new SavingWriter();
        var formatingWriter = new FormatingWriter(internalWriter, options.format);

        if (options.preamble) {
            formatingWriter.append(XML_PREAMBLE);
        }

        new ElementSerializer().build(tree).serializeTo(formatingWriter);

        if (!writer) {
            return internalWriter.value;
        }
    }

    return {
        toXML: toXML
    };
}

//module.exports = XMLWriter;
'use strict';
//
//var _ = require('lodash');
//
//var Moddle = require('bpmn-moddle');
    //ModdleXml = require('moddle-xml');
//

function createModel(packages) {
    return new Moddle(packages);
}

/**
 * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.
 *
 * @class BpmnModdle
 * @extends Moddle
 *
 * @param {Object|Array} packages to use for instantiating the model
 * @param {Object} [options] additional options to pass over
 */
function BpmnModdle(packages, options) {
    var packages = {
        bpmn: {
            "name": "BPMN20",
            "uri": "http://www.omg.org/spec/BPMN/20100524/MODEL",
            "associations": [],
            "types": [
                {
                    "name": "Interface",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operations",
                            "type": "Operation",
                            "association": "A_operations_interface",
                            "isMany": true
                        },
                        {
                            "name": "implementationRef",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Operation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "inMessageRef",
                            "type": "Message",
                            "association": "A_inMessageRef_operation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outMessageRef",
                            "type": "Message",
                            "association": "A_outMessageRef_operation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "errorRefs",
                            "type": "Error",
                            "association": "A_errorRefs_operation",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "implementationRef",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "EndPoint",
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "Auditing",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "GlobalTask",
                    "superClass": [
                        "CallableElement"
                    ],
                    "properties": [
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "association": "A_resources_globalTask",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Monitoring",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Performer",
                    "superClass": [
                        "ResourceRole"
                    ]
                },
                {
                    "name": "Process",
                    "superClass": [
                        "FlowElementsContainer",
                        "CallableElement"
                    ],
                    "properties": [
                        {
                            "name": "processType",
                            "type": "ProcessType",
                            "isAttr": true
                        },
                        {
                            "name": "isClosed",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "auditing",
                            "type": "Auditing",
                            "association": "A_auditing_process"
                        },
                        {
                            "name": "monitoring",
                            "type": "Monitoring",
                            "association": "A_monitoring_process"
                        },
                        {
                            "name": "properties",
                            "type": "Property",
                            "association": "A_properties_process",
                            "isMany": true
                        },
                        {
                            "name": "supports",
                            "type": "Process",
                            "association": "A_supports_process",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "definitionalCollaborationRef",
                            "type": "Collaboration",
                            "association": "A_definitionalCollaborationRef_process",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "isExecutable",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "association": "A_resources_process",
                            "isMany": true
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "association": "A_artifacts_process",
                            "isMany": true
                        },
                        {
                            "name": "correlationSubscriptions",
                            "type": "CorrelationSubscription",
                            "association": "A_correlationSubscriptions_process",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LaneSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "lanes",
                            "type": "Lane",
                            "association": "A_lanes_laneSet",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Lane",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "childLaneSet",
                            "type": "LaneSet",
                            "association": "A_childLaneSet_parentLane"
                        },
                        {
                            "name": "partitionElementRef",
                            "type": "BaseElement",
                            "association": "A_partitionElementRef_lane",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "flowNodeRef",
                            "type": "FlowNode",
                            "association": "A_flowNodeRefs_lanes",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "partitionElement",
                            "type": "BaseElement",
                            "association": "A_partitionElement_lane"
                        }
                    ]
                },
                {
                    "name": "GlobalManualTask",
                    "superClass": [
                        "GlobalTask"
                    ]
                },
                {
                    "name": "ManualTask",
                    "superClass": [
                        "Task"
                    ]
                },
                {
                    "name": "UserTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "renderings",
                            "type": "Rendering",
                            "association": "A_renderings_usertask",
                            "isMany": true
                        },
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Rendering",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "HumanPerformer",
                    "superClass": [
                        "Performer"
                    ]
                },
                {
                    "name": "PotentialOwner",
                    "superClass": [
                        "HumanPerformer"
                    ]
                },
                {
                    "name": "GlobalUserTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "renderings",
                            "type": "Rendering",
                            "association": "A_renderings_globalUserTask",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Gateway",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "gatewayDirection",
                            "type": "GatewayDirection",
                            "default": "Unspecified",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "EventBasedGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "instantiate",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "eventGatewayType",
                            "type": "EventBasedGatewayType",
                            "isAttr": true,
                            "default": "Exclusive"
                        }
                    ]
                },
                {
                    "name": "ComplexGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "activationCondition",
                            "type": "Expression",
                            "association": "A_activationCondition_complexGateway"
                        },
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "association": "A_default_complexGateway",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExclusiveGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "association": "A_default_exclusiveGateway",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InclusiveGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "association": "A_default_inclusiveGateway",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParallelGateway",
                    "superClass": [
                        "Gateway"
                    ]
                },
                {
                    "name": "RootElement",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Relationship",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "type",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "direction",
                            "type": "RelationshipDirection",
                            "isAttr": true
                        },
                        {
                            "name": "sources",
                            "association": "A_sources_relationship",
                            "isMany": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "targets",
                            "association": "A_targets_relationship",
                            "isMany": true,
                            "isReference": true,
                            "type": "Element"
                        }
                    ]
                },
                {
                    "name": "BaseElement",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "id",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "extensionDefinitions",
                            "type": "ExtensionDefinition",
                            "association": "A_extensionDefinitions_baseElement",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "extensionElements",
                            "type": "ExtensionElements",
                            "association": "A_extensionElements_baseElement"
                        },
                        {
                            "name": "documentation",
                            "type": "Documentation",
                            "association": "A_documentation_baseElement",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Extension",
                    "properties": [
                        {
                            "name": "mustUnderstand",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "definition",
                            "type": "ExtensionDefinition",
                            "association": "A_definition_extension"
                        }
                    ]
                },
                {
                    "name": "ExtensionDefinition",
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "extensionAttributeDefinitions",
                            "type": "ExtensionAttributeDefinition",
                            "association": "A_extensionAttributeDefinitions_extensionDefinition",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ExtensionAttributeDefinition",
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "type",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isReference",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "extensionDefinition",
                            "type": "ExtensionDefinition",
                            "association": "A_extensionAttributeDefinitions_extensionDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExtensionElements",
                    "properties": [
                        {
                            "name": "valueRef",
                            "association": "A_valueRef_extensionElements",
                            "isAttr": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "values",
                            "association": "A_value_extensionElements",
                            "type": "Element",
                            "isMany": true
                        },
                        {
                            "name": "extensionAttributeDefinition",
                            "type": "ExtensionAttributeDefinition",
                            "association": "A_extensionAttributeDefinition_extensionElements",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Documentation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "text",
                            "type": "String",
                            "isBody": true
                        },
                        {
                            "name": "textFormat",
                            "default": "text/plain",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Event",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode",
                        "InteractionNode"
                    ],
                    "properties": [
                        {
                            "name": "properties",
                            "type": "Property",
                            "association": "A_properties_event",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "IntermediateCatchEvent",
                    "superClass": [
                        "CatchEvent"
                    ]
                },
                {
                    "name": "IntermediateThrowEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "EndEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "StartEvent",
                    "superClass": [
                        "CatchEvent"
                    ],
                    "properties": [
                        {
                            "name": "isInterrupting",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "ThrowEvent",
                    "isAbstract": true,
                    "superClass": [
                        "Event"
                    ],
                    "properties": [
                        {
                            "name": "inputSet",
                            "type": "InputSet",
                            "association": "A_inputSet_throwEvent"
                        },
                        {
                            "name": "eventDefinitionRefs",
                            "type": "EventDefinition",
                            "association": "A_eventDefinitionRefs_throwEvent",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "dataInputAssociation",
                            "type": "DataInputAssociation",
                            "association": "A_dataInputAssociation_throwEvent",
                            "isMany": true
                        },
                        {
                            "name": "dataInputs",
                            "type": "DataInput",
                            "association": "A_dataInputs_throwEvent",
                            "isMany": true
                        },
                        {
                            "name": "eventDefinitions",
                            "type": "EventDefinition",
                            "association": "A_eventDefinitions_throwEvent",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "CatchEvent",
                    "isAbstract": true,
                    "superClass": [
                        "Event"
                    ],
                    "properties": [
                        {
                            "name": "parallelMultiple",
                            "isAttr": true,
                            "type": "Boolean",
                            "default": false
                        },
                        {
                            "name": "outputSet",
                            "type": "OutputSet",
                            "association": "A_outputSet_catchEvent"
                        },
                        {
                            "name": "eventDefinitionRefs",
                            "type": "EventDefinition",
                            "association": "A_eventDefinitionRefs_catchEvent",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "dataOutputAssociation",
                            "type": "DataOutputAssociation",
                            "association": "A_dataOutputAssociation_catchEvent",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputs",
                            "type": "DataOutput",
                            "association": "A_dataOutputs_catchEvent",
                            "isMany": true
                        },
                        {
                            "name": "eventDefinitions",
                            "type": "EventDefinition",
                            "association": "A_eventDefinitions_catchEvent",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "BoundaryEvent",
                    "superClass": [
                        "CatchEvent"
                    ],
                    "properties": [
                        {
                            "name": "cancelActivity",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "attachedToRef",
                            "type": "Activity",
                            "association": "A_boundaryEventRefs_attachedToRef",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "EventDefinition",
                    "isAbstract": true,
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "CancelEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ]
                },
                {
                    "name": "ErrorEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "errorRef",
                            "type": "Error",
                            "association": "A_errorRef_errorEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TerminateEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ]
                },
                {
                    "name": "EscalationEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "escalationRef",
                            "type": "Escalation",
                            "association": "A_escalationRef_escalationEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Escalation",
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "association": "A_structureRef_escalation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "escalationCode",
                            "isAttr": true,
                            "type": "String"
                        }
                    ],
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "CompensateEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "waitForCompletion",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "activityRef",
                            "type": "Activity",
                            "association": "A_activityRef_compensateEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TimerEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "timeDate",
                            "type": "Expression",
                            "association": "A_timeDate_timerEventDefinition"
                        },
                        {
                            "name": "timeCycle",
                            "type": "Expression",
                            "association": "A_timeCycle_timerEventDefinition"
                        },
                        {
                            "name": "timeDuration",
                            "type": "Expression",
                            "association": "A_timeDuration_timerEventDefinition"
                        }
                    ]
                },
                {
                    "name": "LinkEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "target",
                            "type": "LinkEventDefinition",
                            "association": "A_target_source",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "source",
                            "type": "LinkEventDefinition",
                            "association": "A_target_source",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "MessageEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "association": "A_messageRef_messageEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "association": "A_operationRef_messageEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ConditionalEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "condition",
                            "type": "Expression",
                            "association": "A_condition_conditionalEventDefinition",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "SignalEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "signalRef",
                            "type": "Signal",
                            "association": "A_signalRef_signalEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Signal",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "association": "A_structureRef_signal",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ImplicitThrowEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "DataState",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ItemAwareElement",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "itemSubjectRef",
                            "type": "ItemDefinition",
                            "association": "A_itemSubjectRef_itemAwareElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "dataState",
                            "type": "DataState",
                            "association": "A_dataState_itemAwareElement"
                        }
                    ]
                },
                {
                    "name": "DataAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "transformation",
                            "type": "FormalExpression",
                            "association": "A_transformation_dataAssociation"
                        },
                        {
                            "name": "assignment",
                            "type": "Assignment",
                            "association": "A_assignment_dataAssociation",
                            "isMany": true
                        },
                        {
                            "name": "sourceRef",
                            "type": "ItemAwareElement",
                            "association": "A_sourceRef_dataAssociation",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "ItemAwareElement",
                            "association": "A_targetRef_dataAssociation",
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataInput",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "inputSetRefs",
                            "type": "InputSet",
                            "association": "A_dataInputRefs_inputSetRefs",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "inputSetWithOptional",
                            "type": "InputSet",
                            "association": "A_optionalInputRefs_inputSetWithOptional",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "inputSetWithWhileExecuting",
                            "type": "InputSet",
                            "association": "A_whileExecutingInputRefs_inputSetWithWhileExecuting",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataOutput",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "outputSetRefs",
                            "type": "OutputSet",
                            "association": "A_dataOutputRefs_outputSetRefs",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetWithOptional",
                            "type": "OutputSet",
                            "association": "A_outputSetWithOptional_optionalOutputRefs",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetWithWhileExecuting",
                            "type": "OutputSet",
                            "association": "A_outputSetWithWhileExecuting_whileExecutingOutputRefs",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InputSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "dataInputRefs",
                            "type": "DataInput",
                            "association": "A_dataInputRefs_inputSetRefs",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "optionalInputRefs",
                            "type": "DataInput",
                            "association": "A_optionalInputRefs_inputSetWithOptional",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "whileExecutingInputRefs",
                            "type": "DataInput",
                            "association": "A_whileExecutingInputRefs_inputSetWithWhileExecuting",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetRefs",
                            "type": "OutputSet",
                            "association": "A_inputSetRefs_outputSetRefs",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "OutputSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataOutputRefs",
                            "type": "DataOutput",
                            "association": "A_dataOutputRefs_outputSetRefs",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "inputSetRefs",
                            "type": "InputSet",
                            "association": "A_inputSetRefs_outputSetRefs",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "optionalOutputRefs",
                            "type": "DataOutput",
                            "association": "A_outputSetWithOptional_optionalOutputRefs",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "whileExecutingOutputRefs",
                            "type": "DataOutput",
                            "association": "A_outputSetWithWhileExecuting_whileExecutingOutputRefs",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Property",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "DataInputAssociation",
                    "superClass": [
                        "DataAssociation"
                    ]
                },
                {
                    "name": "DataOutputAssociation",
                    "superClass": [
                        "DataAssociation"
                    ]
                },
                {
                    "name": "InputOutputSpecification",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "inputSets",
                            "type": "InputSet",
                            "association": "A_inputSets_inputOutputSpecification",
                            "isMany": true
                        },
                        {
                            "name": "outputSets",
                            "type": "OutputSet",
                            "association": "A_outputSets_inputOutputSpecification",
                            "isMany": true
                        },
                        {
                            "name": "dataInputs",
                            "type": "DataInput",
                            "association": "A_dataInputs_inputOutputSpecification",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputs",
                            "type": "DataOutput",
                            "association": "A_dataOutputs_inputOutputSpecification",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "DataObject",
                    "superClass": [
                        "FlowElement",
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "InputOutputBinding",
                    "properties": [
                        {
                            "name": "inputDataRef",
                            "type": "InputSet",
                            "association": "A_inputDataRef_inputOutputBinding",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outputDataRef",
                            "type": "OutputSet",
                            "association": "A_outputDataRef_inputOutputBinding",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "association": "A_operationRef_ioBinding",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Assignment",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "from",
                            "type": "Expression",
                            "association": "A_from_assignment"
                        },
                        {
                            "name": "to",
                            "type": "Expression",
                            "association": "A_to_assignment"
                        }
                    ]
                },
                {
                    "name": "DataStore",
                    "superClass": [
                        "RootElement",
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "capacity",
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "isUnlimited",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "DataStoreReference",
                    "superClass": [
                        "ItemAwareElement",
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "dataStoreRef",
                            "type": "DataStore",
                            "association": "A_dataStoreRef_dataStoreReference",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataObjectReference",
                    "superClass": [
                        "ItemAwareElement",
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "dataObjectRef",
                            "type": "DataObject",
                            "association": "A_dataObjectRef_dataObject",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ConversationLink",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "sourceRef",
                            "type": "InteractionNode",
                            "association": "A_sourceRef_outgoingConversationLinks",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "InteractionNode",
                            "association": "A_targetRef_incomingConversationLinks",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ConversationAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerConversationNodeRef",
                            "type": "ConversationNode",
                            "association": "A_innerConversationNodeRef_conversationAssociation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerConversationNodeRef",
                            "type": "ConversationNode",
                            "association": "A_outerConversationNodeRef_conversationAssociation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CallConversation",
                    "superClass": [
                        "ConversationNode"
                    ],
                    "properties": [
                        {
                            "name": "calledCollaborationRef",
                            "type": "Collaboration",
                            "association": "A_calledCollaborationRef_callConversation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "association": "A_participantAssociations_callConversation",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Conversation",
                    "superClass": [
                        "ConversationNode"
                    ]
                },
                {
                    "name": "SubConversation",
                    "superClass": [
                        "ConversationNode"
                    ],
                    "properties": [
                        {
                            "name": "conversationNodes",
                            "type": "ConversationNode",
                            "association": "A_conversationNodes_subConversation",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ConversationNode",
                    "isAbstract": true,
                    "superClass": [
                        "InteractionNode",
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRefs",
                            "type": "Participant",
                            "association": "A_participantRefs_conversationNode",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "messageFlowRefs",
                            "type": "MessageFlow",
                            "association": "A_messageFlowRefs_communication",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "association": "A_correlationKeys_conversationNode",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "GlobalConversation",
                    "superClass": [
                        "Collaboration"
                    ]
                },
                {
                    "name": "PartnerEntity",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRef",
                            "type": "Participant",
                            "association": "A_partnerEntityRef_participantRef",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "PartnerRole",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRef",
                            "type": "Participant",
                            "association": "A_partnerRoleRef_participantRef",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationProperty",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationPropertyRetrievalExpression",
                            "type": "CorrelationPropertyRetrievalExpression",
                            "association": "A_correlationPropertyRetrievalExpression_correlationproperty",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "type",
                            "type": "ItemDefinition",
                            "association": "A_type_correlationProperty",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Error",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "association": "A_structureRef_error",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "errorCode",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "CorrelationKey",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationPropertyRef",
                            "type": "CorrelationProperty",
                            "association": "A_correlationPropertyRef_correlationKey",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Expression",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "FormalExpression",
                    "superClass": [
                        "Expression"
                    ],
                    "properties": [
                        {
                            "name": "language",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "body",
                            "type": "Element"
                        },
                        {
                            "name": "evaluatesToTypeRef",
                            "type": "ItemDefinition",
                            "association": "A_evaluatesToTypeRef_formalExpression",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Message",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "itemRef",
                            "type": "ItemDefinition",
                            "association": "A_itemRef_message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ItemDefinition",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "itemKind",
                            "type": "ItemKind",
                            "isAttr": true
                        },
                        {
                            "name": "structureRef",
                            "type": "String",
                            "isAttr": true
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "import",
                            "type": "Import",
                            "association": "A_import_itemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "FlowElement",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "auditing",
                            "type": "Auditing",
                            "association": "A_auditing_flowElement"
                        },
                        {
                            "name": "monitoring",
                            "type": "Monitoring",
                            "association": "A_monitoring_flowElement"
                        },
                        {
                            "name": "categoryValueRef",
                            "type": "CategoryValue",
                            "association": "A_categorizedFlowElements_categoryValueRef",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "SequenceFlow",
                    "superClass": [
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "isImmediate",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "conditionExpression",
                            "type": "Expression",
                            "association": "A_conditionExpression_sequenceFlow"
                        },
                        {
                            "name": "sourceRef",
                            "type": "FlowNode",
                            "association": "A_sourceRef_outgoing_flow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "FlowNode",
                            "association": "A_targetRef_incoming_flow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "FlowElementsContainer",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "laneSets",
                            "type": "LaneSet",
                            "association": "A_laneSets_flowElementsContainer",
                            "isMany": true
                        },
                        {
                            "name": "flowElements",
                            "type": "FlowElement",
                            "association": "A_flowElements_container",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "CallableElement",
                    "isAbstract": true,
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "ioSpecification",
                            "type": "InputOutputSpecification",
                            "association": "A_ioSpecification_callableElement"
                        },
                        {
                            "name": "supportedInterfaceRefs",
                            "type": "Interface",
                            "association": "A_supportedInterfaceRefs_callableElements",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "ioBinding",
                            "type": "InputOutputBinding",
                            "association": "A_ioBinding_callableElement",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "FlowNode",
                    "isAbstract": true,
                    "superClass": [
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "incoming",
                            "type": "SequenceFlow",
                            "association": "A_targetRef_incoming_flow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outgoing",
                            "type": "SequenceFlow",
                            "association": "A_sourceRef_outgoing_flow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "lanes",
                            "type": "Lane",
                            "association": "A_flowNodeRefs_lanes",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationPropertyRetrievalExpression",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "messagePath",
                            "type": "FormalExpression",
                            "association": "A_messagePath_correlationset"
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "association": "A_messageRef_correlationPropertyRetrievalExpression",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationPropertyBinding",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataPath",
                            "type": "FormalExpression",
                            "association": "A_dataPath_correlationPropertyBinding"
                        },
                        {
                            "name": "correlationPropertyRef",
                            "type": "CorrelationProperty",
                            "association": "A_correlationPropertyRef_correlationPropertyBinding",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Resource",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "resourceParameters",
                            "type": "ResourceParameter",
                            "association": "A_resourceParameters_resource",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ResourceParameter",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isRequired",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "type",
                            "type": "ItemDefinition",
                            "association": "A_type_resourceParameter",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationSubscription",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationKeyRef",
                            "type": "CorrelationKey",
                            "association": "A_correlationKeyRef_correlationSubscription",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationPropertyBinding",
                            "type": "CorrelationPropertyBinding",
                            "association": "A_correlationPropertyBinding_correlationSubscription",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "MessageFlow",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "sourceRef",
                            "type": "InteractionNode",
                            "association": "A_sourceRef_messageFlow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "InteractionNode",
                            "association": "A_targetRef_messageFlow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "association": "A_messageRef_messageFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "MessageFlowAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerMessageFlowRef",
                            "type": "MessageFlow",
                            "association": "A_innerMessageFlowRef_messageFlowAssociation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerMessageFlowRef",
                            "type": "MessageFlow",
                            "association": "A_outerMessageFlowRef_messageFlowAssociation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InteractionNode",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "incomingConversationLinks",
                            "type": "ConversationLink",
                            "association": "A_targetRef_incomingConversationLinks",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outgoingConversationLinks",
                            "type": "ConversationLink",
                            "association": "A_sourceRef_outgoingConversationLinks",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Participant",
                    "superClass": [
                        "InteractionNode",
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "interfaceRefs",
                            "type": "Interface",
                            "association": "A_interfaceRefs_participant",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "participantMultiplicity",
                            "type": "ParticipantMultiplicity",
                            "association": "A_participantMultiplicity_participant"
                        },
                        {
                            "name": "endPointRefs",
                            "type": "EndPoint",
                            "association": "A_endPointRefs_participant",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "processRef",
                            "type": "Process",
                            "association": "A_processRef_participant",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParticipantAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerParticipantRef",
                            "type": "Participant",
                            "association": "A_innerParticipantRef_participantAssociation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerParticipantRef",
                            "type": "Participant",
                            "association": "A_outerParticipantRef_participantAssociation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParticipantMultiplicity",
                    "properties": [
                        {
                            "name": "minimum",
                            "default": 0,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "maximum",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        }
                    ]
                },
                {
                    "name": "Collaboration",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isClosed",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "choreographyRef",
                            "type": "Choreography",
                            "association": "A_choreographyRef_collaboration",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "association": "A_artifacts_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "association": "A_participantAssociations_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "messageFlowAssociations",
                            "type": "MessageFlowAssociation",
                            "association": "A_messageFlowAssociations_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "conversationAssociations",
                            "type": "ConversationAssociation",
                            "association": "A_conversationAssociations_converstaionAssociations"
                        },
                        {
                            "name": "participants",
                            "type": "Participant",
                            "association": "A_participants_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "messageFlows",
                            "type": "MessageFlow",
                            "association": "A_messageFlows_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "association": "A_correlationKeys_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "conversations",
                            "type": "ConversationNode",
                            "association": "A_conversations_collaboration",
                            "isMany": true
                        },
                        {
                            "name": "conversationLinks",
                            "type": "ConversationLink",
                            "association": "A_conversationLinks_collaboration",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ChoreographyActivity",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "participantRefs",
                            "type": "Participant",
                            "association": "A_participantRefs_choreographyActivity",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "initiatingParticipantRef",
                            "type": "Participant",
                            "association": "A_initiatingParticipantRef_choreographyActivity",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "association": "A_correlationKeys_choreographyActivity",
                            "isMany": true
                        },
                        {
                            "name": "loopType",
                            "type": "ChoreographyLoopType",
                            "default": "None",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "CallChoreography",
                    "superClass": [
                        "ChoreographyActivity"
                    ],
                    "properties": [
                        {
                            "name": "calledChoreographyRef",
                            "type": "Choreography",
                            "association": "A_calledChoreographyRef_callChoreographyActivity",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "association": "A_participantAssociations_callChoreographyActivity",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "SubChoreography",
                    "superClass": [
                        "ChoreographyActivity",
                        "FlowElementsContainer"
                    ],
                    "properties": [
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "association": "A_artifacts_subChoreography",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ChoreographyTask",
                    "superClass": [
                        "ChoreographyActivity"
                    ],
                    "properties": [
                        {
                            "name": "messageFlowRef",
                            "type": "MessageFlow",
                            "association": "A_messageFlowRef_choreographyTask",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Choreography",
                    "superClass": [
                        "FlowElementsContainer",
                        "Collaboration"
                    ]
                },
                {
                    "name": "GlobalChoreographyTask",
                    "superClass": [
                        "Choreography"
                    ],
                    "properties": [
                        {
                            "name": "initiatingParticipantRef",
                            "type": "Participant",
                            "association": "A_initiatingParticipantRef_globalChoreographyTask",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TextAnnotation",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "text",
                            "type": "String"
                        },
                        {
                            "name": "textFormat",
                            "default": "text/plain",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Group",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "categoryValueRef",
                            "type": "CategoryValue",
                            "association": "A_categoryValueRef_categoryValueRef",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Association",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "associationDirection",
                            "type": "AssociationDirection",
                            "isAttr": true
                        },
                        {
                            "name": "sourceRef",
                            "type": "BaseElement",
                            "association": "A_sourceRef_outgoing_association",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "BaseElement",
                            "association": "A_targetRef_incoming_association",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Category",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "categoryValue",
                            "type": "CategoryValue",
                            "association": "A_categoryValue_category",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Artifact",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "CategoryValue",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "categorizedFlowElements",
                            "type": "FlowElement",
                            "association": "A_categorizedFlowElements_categoryValueRef",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "value",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Activity",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "isForCompensation",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "loopCharacteristics",
                            "type": "LoopCharacteristics",
                            "association": "A_loopCharacteristics_activity"
                        },
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "association": "A_resources_activity",
                            "isMany": true
                        },
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "association": "A_default_activity",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "properties",
                            "type": "Property",
                            "association": "A_properties_activity",
                            "isMany": true
                        },
                        {
                            "name": "ioSpecification",
                            "type": "InputOutputSpecification",
                            "association": "A_ioSpecification_activity"
                        },
                        {
                            "name": "boundaryEventRefs",
                            "type": "BoundaryEvent",
                            "association": "A_boundaryEventRefs_attachedToRef",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "dataInputAssociations",
                            "type": "DataInputAssociation",
                            "association": "A_dataInputAssociations_activity",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputAssociations",
                            "type": "DataOutputAssociation",
                            "association": "A_dataOutputAssociations_activity",
                            "isMany": true
                        },
                        {
                            "name": "startQuantity",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "completionQuantity",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        }
                    ]
                },
                {
                    "name": "ServiceTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "association": "A_operationRef_serviceTask",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "SubProcess",
                    "superClass": [
                        "Activity",
                        "FlowElementsContainer"
                    ],
                    "properties": [
                        {
                            "name": "triggeredByEvent",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "association": "A_artifacts_subProcess",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LoopCharacteristics",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "MultiInstanceLoopCharacteristics",
                    "superClass": [
                        "LoopCharacteristics"
                    ],
                    "properties": [
                        {
                            "name": "isSequential",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "behavior",
                            "type": "MultiInstanceBehavior",
                            "default": "All",
                            "isAttr": true
                        },
                        {
                            "name": "loopCardinality",
                            "type": "Expression",
                            "association": "A_loopCardinality_multiInstanceLoopCharacteristics"
                        },
                        {
                            "name": "loopDataInputRef",
                            "type": "ItemAwareElement",
                            "association": "A_loopDataInputRef_multiInstanceLoopCharacteristics",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "loopDataOutputRef",
                            "type": "ItemAwareElement",
                            "association": "A_loopDataOutputRef_multiInstanceLoopCharacteristics",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "inputDataItem",
                            "type": "DataInput",
                            "association": "A_inputDataItem_multiInstanceLoopCharacteristics"
                        },
                        {
                            "name": "outputDataItem",
                            "type": "DataOutput",
                            "association": "A_outputDataItem_multiInstanceLoopCharacteristics"
                        },
                        {
                            "name": "completionCondition",
                            "type": "Expression",
                            "association": "A_completionCondition_multiInstanceLoopCharacteristics"
                        },
                        {
                            "name": "complexBehaviorDefinition",
                            "type": "ComplexBehaviorDefinition",
                            "association": "A_complexBehaviorDefinition_multiInstanceLoopCharacteristics",
                            "isMany": true
                        },
                        {
                            "name": "oneBehaviorEventRef",
                            "type": "EventDefinition",
                            "association": "A_oneBehaviorEventRef_multiInstanceLoopCharacteristics",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "noneBehaviorEventRef",
                            "type": "EventDefinition",
                            "association": "A_noneBehaviorEventRef_multiInstanceLoopCharacteristics",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "StandardLoopCharacteristics",
                    "superClass": [
                        "LoopCharacteristics"
                    ],
                    "properties": [
                        {
                            "name": "testBefore",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "loopCondition",
                            "type": "Expression",
                            "association": "A_loopCondition_standardLoopCharacteristics"
                        },
                        {
                            "name": "loopMaximum",
                            "type": "Expression",
                            "association": "A_loopMaximum_standardLoopCharacteristics"
                        }
                    ]
                },
                {
                    "name": "CallActivity",
                    "superClass": [
                        "Activity"
                    ],
                    "properties": [
                        {
                            "name": "calledElement",
                            "type": "String",
                            "association": "A_calledElementRef_callActivity",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Task",
                    "superClass": [
                        "Activity",
                        "InteractionNode"
                    ]
                },
                {
                    "name": "SendTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "association": "A_operationRef_sendTask",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "association": "A_messageRef_sendTask",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ReceiveTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "instantiate",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "association": "A_operationRef_receiveTask",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "association": "A_messageRef_receiveTask",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ScriptTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "scriptFormat",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "script",
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "BusinessRuleTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "AdHocSubProcess",
                    "superClass": [
                        "SubProcess"
                    ],
                    "properties": [
                        {
                            "name": "completionCondition",
                            "type": "Expression",
                            "association": "A_completionCondition_adHocSubProcess"
                        },
                        {
                            "name": "ordering",
                            "type": "AdHocOrdering",
                            "isAttr": true
                        },
                        {
                            "name": "cancelRemainingInstances",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "Transaction",
                    "superClass": [
                        "SubProcess"
                    ],
                    "properties": [
                        {
                            "name": "protocol",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "method",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "GlobalScriptTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "scriptLanguage",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "script",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "GlobalBusinessRuleTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ComplexBehaviorDefinition",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "condition",
                            "type": "FormalExpression",
                            "association": "A_condition_complexBehaviorDefinition"
                        },
                        {
                            "name": "event",
                            "type": "ImplicitThrowEvent",
                            "association": "A_event_complexBehaviorDefinition"
                        }
                    ]
                },
                {
                    "name": "ResourceRole",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "resourceRef",
                            "type": "Resource",
                            "association": "A_resourceRef_activityResource",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "resourceParameterBindings",
                            "type": "ResourceParameterBinding",
                            "association": "A_resourceParameterBindings_activityResource",
                            "isMany": true
                        },
                        {
                            "name": "resourceAssignmentExpression",
                            "type": "ResourceAssignmentExpression",
                            "association": "A_resourceAssignmentExpression_activityResource"
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ResourceParameterBinding",
                    "properties": [
                        {
                            "name": "expression",
                            "type": "Expression",
                            "association": "A_expression_resourceParameterBinding"
                        },
                        {
                            "name": "parameterRef",
                            "type": "ResourceParameter",
                            "association": "A_parameterRef_resourceParameterBinding",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ResourceAssignmentExpression",
                    "properties": [
                        {
                            "name": "expression",
                            "type": "Expression",
                            "association": "A_expression_resourceAssignmentExpression"
                        }
                    ]
                },
                {
                    "name": "Import",
                    "properties": [
                        {
                            "name": "importType",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "location",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "namespace",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Definitions",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "targetNamespace",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "expressionLanguage",
                            "default": "http://www.w3.org/1999/XPath",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "typeLanguage",
                            "default": "http://www.w3.org/2001/XMLSchema",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "imports",
                            "type": "Import",
                            "association": "A_imports_definition",
                            "isMany": true
                        },
                        {
                            "name": "extensions",
                            "type": "Extension",
                            "association": "A_extensions_definitions",
                            "isMany": true
                        },
                        {
                            "name": "relationships",
                            "type": "Relationship",
                            "association": "A_relationships_definition",
                            "isMany": true
                        },
                        {
                            "name": "rootElements",
                            "type": "RootElement",
                            "association": "A_rootElements_definition",
                            "isMany": true
                        },
                        {
                            "name": "diagrams",
                            "association": "A_diagrams_definitions",
                            "isMany": true,
                            "type": "bpmndi:BPMNDiagram"
                        },
                        {
                            "name": "exporter",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "exporterVersion",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                }
            ],
            "emumerations": [
                {
                    "name": "ProcessType",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Public"
                        },
                        {
                            "name": "Private"
                        }
                    ]
                },
                {
                    "name": "GatewayDirection",
                    "literalValues": [
                        {
                            "name": "Unspecified"
                        },
                        {
                            "name": "Converging"
                        },
                        {
                            "name": "Diverging"
                        },
                        {
                            "name": "Mixed"
                        }
                    ]
                },
                {
                    "name": "EventBasedGatewayType",
                    "literalValues": [
                        {
                            "name": "Parallel"
                        },
                        {
                            "name": "Exclusive"
                        }
                    ]
                },
                {
                    "name": "RelationshipDirection",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Forward"
                        },
                        {
                            "name": "Backward"
                        },
                        {
                            "name": "Both"
                        }
                    ]
                },
                {
                    "name": "ItemKind",
                    "literalValues": [
                        {
                            "name": "Physical"
                        },
                        {
                            "name": "Information"
                        }
                    ]
                },
                {
                    "name": "ChoreographyLoopType",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Standard"
                        },
                        {
                            "name": "MultiInstanceSequential"
                        },
                        {
                            "name": "MultiInstanceParallel"
                        }
                    ]
                },
                {
                    "name": "AssociationDirection",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "One"
                        },
                        {
                            "name": "Both"
                        }
                    ]
                },
                {
                    "name": "MultiInstanceBehavior",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "One"
                        },
                        {
                            "name": "All"
                        },
                        {
                            "name": "Complex"
                        }
                    ]
                },
                {
                    "name": "AdHocOrdering",
                    "literalValues": [
                        {
                            "name": "Parallel"
                        },
                        {
                            "name": "Sequential"
                        }
                    ]
                }
            ],
            "prefix": "bpmn",
            "xml": {
                "alias": "lowerCase"
            }
        },
        bpmndi: {
            "name": "BPMNDI",
            "uri": "http://www.omg.org/spec/BPMN/20100524/DI",
            "types": [
                {
                    "name": "BPMNDiagram",
                    "properties": [
                        {
                            "name": "plane",
                            "type": "BPMNPlane",
                            "association": "A_plane_diagram",
                            "redefines": "di:Diagram#rootElement"
                        },
                        {
                            "name": "labelStyle",
                            "type": "BPMNLabelStyle",
                            "association": "A_labelStyle_diagram",
                            "isMany": true
                        }
                    ],
                    "superClass": [
                        "di:Diagram"
                    ]
                },
                {
                    "name": "BPMNPlane",
                    "properties": [
                        {
                            "name": "bpmnElement",
                            "association": "A_bpmnElement_plane",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        }
                    ],
                    "superClass": [
                        "di:Plane"
                    ]
                },
                {
                    "name": "BPMNShape",
                    "properties": [
                        {
                            "name": "bpmnElement",
                            "association": "A_bpmnElement_shape",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        },
                        {
                            "name": "isHorizontal",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "isExpanded",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "isMarkerVisible",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "label",
                            "type": "BPMNLabel",
                            "association": "A_label_shape"
                        },
                        {
                            "name": "isMessageVisible",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "participantBandKind",
                            "type": "ParticipantBandKind",
                            "isAttr": true
                        },
                        {
                            "name": "choreographyActivityShape",
                            "type": "BPMNShape",
                            "association": "A_choreographyActivityShape_participantBandShape",
                            "isAttr": true,
                            "isReference": true
                        }
                    ],
                    "superClass": [
                        "di:LabeledShape"
                    ]
                },
                {
                    "name": "BPMNEdge",
                    "properties": [
                        {
                            "name": "label",
                            "type": "BPMNLabel",
                            "association": "A_label_edge"
                        },
                        {
                            "name": "bpmnElement",
                            "association": "A_bpmnElement_edge",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        },
                        {
                            "name": "sourceElement",
                            "association": "A_sourceElement_sourceEdge",
                            "isAttr": true,
                            "isReference": true,
                            "type": "di:DiagramElement",
                            "redefines": "di:Edge#source"
                        },
                        {
                            "name": "targetElement",
                            "association": "A_targetElement_targetEdge",
                            "isAttr": true,
                            "isReference": true,
                            "type": "di:DiagramElement",
                            "redefines": "di:Edge#target"
                        },
                        {
                            "name": "messageVisibleKind",
                            "type": "MessageVisibleKind",
                            "isAttr": true,
                            "default": "initiating"
                        }
                    ],
                    "superClass": [
                        "di:LabeledEdge"
                    ]
                },
                {
                    "name": "BPMNLabel",
                    "properties": [
                        {
                            "name": "labelStyle",
                            "type": "BPMNLabelStyle",
                            "association": "A_labelStyle_label",
                            "isAttr": true,
                            "isReference": true,
                            "redefines": "di:DiagramElement#style"
                        }
                    ],
                    "superClass": [
                        "di:Label"
                    ]
                },
                {
                    "name": "BPMNLabelStyle",
                    "properties": [
                        {
                            "name": "font",
                            "type": "dc:Font"
                        }
                    ],
                    "superClass": [
                        "di:Style"
                    ]
                }
            ],
            "emumerations": [
                {
                    "name": "ParticipantBandKind",
                    "literalValues": [
                        {
                            "name": "top_initiating"
                        },
                        {
                            "name": "middle_initiating"
                        },
                        {
                            "name": "bottom_initiating"
                        },
                        {
                            "name": "top_non_initiating"
                        },
                        {
                            "name": "middle_non_initiating"
                        },
                        {
                            "name": "bottom_non_initiating"
                        }
                    ]
                },
                {
                    "name": "MessageVisibleKind",
                    "literalValues": [
                        {
                            "name": "initiating"
                        },
                        {
                            "name": "non_initiating"
                        }
                    ]
                }
            ],
            "associations": [],
            "prefix": "bpmndi"
        },
        dc: {
            "name": "DC",
            "uri": "http://www.omg.org/spec/DD/20100524/DC",
            "types": [
                {
                    "name": "Boolean"
                },
                {
                    "name": "Integer"
                },
                {
                    "name": "Real"
                },
                {
                    "name": "String"
                },
                {
                    "name": "Font",
                    "properties": [
                        {
                            "name": "name",
                            "type": "String",
                            "isAttr": true
                        },
                        {
                            "name": "size",
                            "type": "Real",
                            "isAttr": true
                        },
                        {
                            "name": "isBold",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isItalic",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isUnderline",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isStrikeThrough",
                            "type": "Boolean",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Point",
                    "properties": [
                        {
                            "name": "x",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "y",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Bounds",
                    "properties": [
                        {
                            "name": "x",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "y",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "width",
                            "type": "Real",
                            "isAttr": true
                        },
                        {
                            "name": "height",
                            "type": "Real",
                            "isAttr": true
                        }
                    ]
                }
            ],
            "prefix": "dc",
            "associations": []
        },
        di: {
            "name": "DI",
            "uri": "http://www.omg.org/spec/DD/20100524/DI",
            "types": [
                {
                    "name": "DiagramElement",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "owningDiagram",
                            "type": "Diagram",
                            "isReadOnly": true,
                            "association": "A_rootElement_owningDiagram",
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "owningElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "association": "A_ownedElement_owningElement",
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "modelElement",
                            "isReadOnly": true,
                            "association": "A_modelElement_diagramElement",
                            "isVirtual": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "style",
                            "type": "Style",
                            "isReadOnly": true,
                            "association": "A_style_diagramElement",
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "ownedElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "association": "A_ownedElement_owningElement",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Node",
                    "isAbstract": true,
                    "superClass": [
                        "DiagramElement"
                    ]
                },
                {
                    "name": "Edge",
                    "isAbstract": true,
                    "superClass": [
                        "DiagramElement"
                    ],
                    "properties": [
                        {
                            "name": "source",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "association": "A_source_sourceEdge",
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "target",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "association": "A_target_targetEdge",
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "waypoint",
                            "isUnique": false,
                            "isMany": true,
                            "type": "dc:Point",
                            "serialize": "xsi:type"
                        }
                    ]
                },
                {
                    "name": "Diagram",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "rootElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "association": "A_rootElement_owningDiagram",
                            "isVirtual": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "documentation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "resolution",
                            "isAttr": true,
                            "type": "Real"
                        },
                        {
                            "name": "ownedStyle",
                            "type": "Style",
                            "isReadOnly": true,
                            "association": "A_ownedStyle_owningDiagram",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Shape",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "bounds",
                            "type": "dc:Bounds"
                        }
                    ]
                },
                {
                    "name": "Plane",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "planeElement",
                            "type": "DiagramElement",
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "association": "A_planeElement_plane",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LabeledEdge",
                    "isAbstract": true,
                    "superClass": [
                        "Edge"
                    ],
                    "properties": [
                        {
                            "name": "ownedLabel",
                            "type": "Label",
                            "isReadOnly": true,
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "association": "A_ownedLabel_owningEdge",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LabeledShape",
                    "isAbstract": true,
                    "superClass": [
                        "Shape"
                    ],
                    "properties": [
                        {
                            "name": "ownedLabel",
                            "type": "Label",
                            "isReadOnly": true,
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "association": "A_ownedLabel_owningShape",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Label",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "bounds",
                            "type": "dc:Bounds"
                        }
                    ]
                },
                {
                    "name": "Style",
                    "isAbstract": true
                }
            ],
            "associations": [],
            "prefix": "di"
        }
    };
    
    Moddle.call(this, packages, options);
}

BpmnModdle.prototype = Object.create(Moddle.prototype);

//module.exports = BpmnModdle;


/**
 * Instantiates a BPMN model tree from a given xml string.
 *
 * @param {String}   xmlStr
 * @param {String}   [typeName]   name of the root element, defaults to 'bpmn:Definitions'
 * @param {Object}   [options]    options to pass to the underlying reader
 * @param {Function} done         callback that is invoked with (err, result, parseContext) once the import completes
 */
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options, done) {

    if (!_.isString(typeName)) {
        done = options;
        options = typeName;
        typeName = 'bpmn:Definitions';
    }

    if (_.isFunction(options)) {
        done = options;
        options = {};
    }

    var reader = new XMLReader(this, options);
    var rootHandler = reader.handler(typeName);

    reader.fromXML(xmlStr, rootHandler, done);
};


/**
 * Serializes a BPMN 2.0 object tree to XML.
 *
 * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`
 * @param {Object}   [options]  to pass to the underlying writer
 * @param {Function} done       callback invoked with (err, xmlStr) once the import completes
 */
BpmnModdle.prototype.toXML = function(element, options, done) {

    if (_.isFunction(options)) {
        done = options;
        options = {};
    }

    var writer = new XMLWriter(options);
    try {
        var result = writer.toXML(element);
        done(null, result);
    } catch (e) {
        done(e);
    }
};
var PMCommandReconnect = function (rec, opt) {
    var CmdReconnect = function (receiver) {
        PMUI.command.CommandReconnect.call(this, receiver);
        CmdReconnect.prototype.init.call(this, receiver, opt);
    };

    CmdReconnect.prototype = new PMUI.command.CommandReconnect(rec);

    CmdReconnect.prototype.init = function (receiver, opt) {
        
        this.prefix = {
            "PMActivity": "act",
            "PMGateway": "gat"
        };
        
        this.srcShape = receiver.connection.getSrcPort().parent;
        if (this.receiver.connection.getFlowType) {
            this.before.type = this.receiver.connection.getFlowType();
        } else {
            this.before.type = 'connection';
        }
        if (this.receiver.connection.getFlowCondition) {
            this.before.condition = this.receiver.connection.getFlowCondition();
        } else {
            this.before.condition = 'flowCondition';
        }
        if (this.srcShape.type === 'PMGateway' || this.srcShape.type === 'PMActivity') {
            this.before.defaultFlow = this.srcShape[this.prefix[this.srcShape.type] + "_default_flow"];
        } else {
            this.before.defaultFlow = "";
        }

        this.after.type = null;
        this.condition = null;
        this.after.defaultFlow = "";
    };

    CmdReconnect.prototype.fireTrigger = function (undo) {
        var updatedElement = [], connection = this.receiver.connection, v, flowChanges, n;
        if (this.after.type === 'DEFAULT' || this.before.type === 'DEFAULT') {
            updatedElement.push({
                id: this.srcShape.getID(),
                relatedObject: this.srcShape,
                type: this.srcShape.type,
                fields: [{
                    field: "default_flow",
                    newVal: this.srcShape[this.prefix[this.srcShape.type] + "_default_flow"],
                    oldVal: undo ? this.after.defaultFlow : this.before.defaultFlow
                }]
            });
        }

        flowChanges = {
            id: connection.getID(),
            relatedObject: connection,
            type: connection.type,
            fields: []
        };

        v = undo ? this.after.type : this.before.type;
        n = connection.getFlowType();
        if (v !== n) {
            flowChanges.fields.push({
                field: "type",
                newVal: n,
                oldVal: v
            });
        }

        v = undo ? this.after.condition : this.before.condition;
        n = connection.getFlowCondition();
        if (v !== n) {
            flowChanges.fields.push({
                field: "condition",
                newVal: n,
                oldVal: v
            });
        }

        if (flowChanges.fields.length > 0) {
            updatedElement.push(flowChanges);
        }

        //this.receiver.getCanvas().triggerDefaultFlowChangeEvent(updatedElement);
    };

    CmdReconnect.prototype.execute = function () {
        var connection = this.receiver.connection;
        connection.setFlowType(this.after.type);

        PMUI.command.CommandReconnect.prototype.execute.call(this);

        if (connection.getSrcPort().getParent().type === 'PMGateway' || 
            (!connection.getFlowCondition() && this.srcShape.type !== "PMArtifact" 
                && connection.getDestPort().parent.type !== "PMArtifact")) {
            connection.setFlowType("SEQUENCE").changeFlowType('sequence');

        } else if ((connection.getSrcPort().getParent().type === 'PMActivity' && connection.getFlowCondition()) 
            && !(connection.getSrcPort().getParent().type === 'PMArtifact' 
                || connection.getDestPort().getParent().type === 'PMArtifact')) {
            connection.setFlowType("CONDITIONAL").changeFlowType('conditional');
            
        } else {
            connection.setFlowType("ASSOCIATION").setFlowCondition("").changeFlowType('association');
            if (this.srcShape.type === "PMActivity" || this.srcShape.type === "PMGateway") {
                this.srcShape[this.prefix[this.srcShape.type] + "_default_flow"] = "";
                this.after.defaultFlow = "";
            }
        }


        if (!this.after.type || !this.after.condition) {
            this.after.type = connection.getFlowType();
            this.after.condition = connection.getFlowCondition();
        }
        this.fireTrigger();
    };

    CmdReconnect.prototype.undo = function () {
        var connection = this.receiver.connection,
            prev = {
                type: connection.getFlowType(),
                condition: connection.getFlowCondition()
            };
        PMUI.command.CommandReconnect.prototype.undo.call(this);
        connection.setFlowCondition(this.before.condition)
            .setFlowType(this.before.type)
            .changeFlowType(this.before.type.toLowerCase());
        if (this.srcShape.updateDefaultFlow) {
            this.srcShape.updateDefaultFlow(this.before.defaultFlow);
        }
        this.fireTrigger(true);
    };
    return new CmdReconnect(rec);
};

var PMSegmentDragBehavior = function (options) {

};
PMSegmentDragBehavior.prototype = new PMUI.behavior.ConnectionDragBehavior();

/**
 * On drag handler, creates a connection segment from the shape to the current
 * mouse position
 * @param {PMUI.draw.CustomShape} customShape
 * @return {Function}
 */
PMSegmentDragBehavior.prototype.onDrag = function (customShape) {
    return function (e, ui) {
        var canvas = customShape.getCanvas(),
            endPoint = new PMUI.util.Point(),
            realPoint = canvas.relativePoint(e);
        if (canvas.connectionSegment) {
            //remove the connection segment in order to create another one
            $(canvas.connectionSegment.getHTML()).remove();
        }
        
        //Determine the point where the mouse currently is
        endPoint.x = realPoint.x*customShape.canvas.zoomFactor;
        endPoint.y = realPoint.y*customShape.canvas.zoomFactor;

        //creates a new segment from where the helper was created to the
        // currently mouse location

        canvas.connectionSegment = new PMUI.draw.Segment({
            startPoint: customShape.startConnectionPoint,
            endPoint: endPoint,
            parent: canvas,
            color: new PMUI.util.Color(92, 156, 204), 
            zOrder: PMUI.util.Style.MAX_ZINDEX * 2
        });

        //We make the connection segment point to helper in order to get
        // information when the drop occurs
        canvas.connectionSegment.pointsTo = customShape;
        //create HTML and paint
        //canvas.connectionSegment.createHTML();
        canvas.connectionSegment.paint();
    };

};
    var PMConnectHandler = function (options) {

        PMUI.draw.Handler.call(this, options);
        /**
         * Category of this resize handler
         * @type {"resizable"/"nonresizable"}
         */
        this.category = null;

        /**
         * Denotes whether the resize handle is visible or not.
         * @property boolean
         */
        this.visible = false;

        /**
         * JSON used to create an instance of the class Style used when the object is resizable.
         * @property {Object}
         */
        this.resizableStyle = null;

        /**
         * JSON used to create an instance of the class Style used when the object is not resizable.
         * @property {Object}
         */
        this.nonResizableStyle = null;
        
        this.relativeShape =  null;

        // set defaults
        PMConnectHandler.prototype.init.call(this, options);
    };

    PMConnectHandler.prototype = new PMUI.draw.Handler();
    //PMUI.inheritFrom('PMUI.draw.Handler', connectHandler);

    /**
     * The type of each instance of this class.
     * @property {String}
     */
    PMConnectHandler.prototype.type = "PMConnectHandler";

    /**
     * Instance initializer which uses options to extend the config options to initialize the instance
     * @param {Object} options The object that contains the config
     * @private
     */
    PMConnectHandler.prototype.init = function (options) {

        var defaults = {
            width: 10,
            height: 10,
            parent: null,
            orientation: null,
            representation: null,
            resizableStyle: {},
            nonResizableStyle: {},
            zOrder: 2
        };

        // extend recursively the defaultOptions with the given options
        $.extend(true, defaults, options);

        // add default zIndex to this handler
        if (defaults.resizableStyle.cssProperties) {
            defaults.resizableStyle.cssProperties.zIndex = defaults.zOrder;
        }
        if (defaults.nonResizableStyle.cssProperties) {
            defaults.nonResizableStyle.cssProperties.zIndex = defaults.zOrder;
        }

        // init
        this.setParent(defaults.parent)
            .setWidth(defaults.width)
            .setHeight(defaults.height)
            .setOrientation(defaults.orientation)
            .setRepresentation(defaults.representation)
            .setResizableStyle(defaults.resizableStyle)
            .setNonResizableStyle(defaults.nonResizableStyle);

        // create the id
        //this.id = defaults.orientation + defaults.parent.id + "connectHandler";
    };

    /**
     * Sets the parent of this handler
     * @param {PMUI.draw.Shape} newParent
     * @chainable
     */
    PMConnectHandler.prototype.setParent = function (newParent) {
        this.parent = newParent;
        return this;
    };

    /**
     * Gets the parent of this handler.
     * @return {PMUI.draw.Shape}
     */
    PMConnectHandler.prototype.getParent = function () {
        return this.parent;
    };

    /**
     * Paints this resize handler by calling it's parent's `paint` and setting
     * the visibility of this resize handler
     * @chainable
     */
    PMConnectHandler.prototype.paint = function () {
        if (!this.html) {
            throw new Error("paint():  This handler has no html");
        }

        // this line paints the representation (by default a rectangle)
        PMUI.draw.Handler.prototype.paint.call(this);
        
        this.setVisible(this.visible);
        return this;
    };

    /**
     * Sets the category of the resizeHandler (also adds the needed class to
     * make the element resizable)
     * @param newCategory
     * @chainable
     */
    PMConnectHandler.prototype.setCategory = function (newCategory) {
        if (typeof newCategory === "string") {
            this.category = newCategory;
        }
        //if (this.category === "resizable") {
        //    his.color = new PMUI.util.Color(255, 204, 0);
        //    this.style.addClasses([
        //        "ui-resizable-handle", "ui-resizable-" + this.orientation
        //    ]);
        //} else {
            this.style.addClasses([newCategory]);
            //this.color = new PMUI.util.Color(255, 204, 0);

            //this.style.removeClasses([
            //    "ui-resizable-handle", "ui-resizable-" + this.orientation
            //]);
        //}
        return this;
    };


    /**
     * Sets the resizable style of this shape by creating an instance of the class Style
     * @param {Object} style
     * @chainable
     */
    PMConnectHandler.prototype.setResizableStyle = function (style) {
        this.resizableStyle = new PMUI.util.Style({
            belongsTo: this,
            cssProperties: style.cssProperties,
            cssClasses: style.cssClasses
        });
        return this;
    };

    /**
     * Sets the non resizable style for this shape by creating an instance of the class Style
     * @param {Object} style
     * @chainable
     */
    PMConnectHandler.prototype.setNonResizableStyle = function (style) {
        this.nonResizableStyle = new PMUI.util.Style({
            belongsTo: this,
            cssProperties: style.cssProperties,
            cssClasses: style.cssClasses
        });
        return this;
    };

    PMConnectHandler.prototype.attachListeners = function () {


        var $handler = $('.dragConnectHandler');
        $handler.mousedown(this.onMouseDown(this));
        //if (this.attachEvents && !this.canvas.readOnly) {
            //$shape.on("mousedown", this.onMouseDown(this));
            //$shape.on("mouseup", this.onMouseUp(this));
            //$handler.on("click", this.onClick(this));
          //  this.updateBehaviors();    
        //}
        if (this.relativeShape) {
            //code
            dragOptions = {
                    revert: true,
                    helper: "clone",
                    cursorAt: false,
                    revertDuration: 0,
                    grid: [1, 1],
                    start: this.onDragStart(this.relativeShape),
                    drag: this.onDrag(this.relativeShape),
                    stop: this.onDragEnd(this.relativeShape),
                    //containment: "parent"
                    refreshPositions: true ,
                    cursor: "pointer"
                    //snap: '.dropConnectHandler',
                    //snapMode: 'inner',
                    //snapTolerance: 10,
        
                };
             $(this.html).draggable(dragOptions);

            
        }
        
        //$handler.droppable(dropOptions);
        return this;
    };
PMConnectHandler.prototype.attachDrop = function () {
    dropOptions = {
                    accept:  '.dragConnectHandler, .pmui-oval',
                    //activeClass: "ui-state-hover",
                    hoverClass: "ui-state-hover",
                    drop: this.onDrop(this.relativeShape, this),
                    over: this.onDropOver(this.relativeShape, this)
                    
                    //out: this.onDropOut(this.parent, this),
      //              greedy: true,
                    //live: true
                    
                };
            $('.dropConnectHandler').droppable(dropOptions);
}

PMConnectHandler.prototype.onMouseDown = function (customShape) {
    return function (e, ui) {
        e.preventDefault();
        e.stopPropagation();
    }
}
 PMConnectHandler.prototype.onDragStart = function (customShape) {
        return function (e, ui) {
            if (!customShape.canvas.currentConnection) {
                customShape.canvas.isDraggingConnectHandler = true;
                var canvas = customShape.canvas,
                    currentLabel = canvas.currentLabel,
                    realPoint = canvas.relativePoint(e),
                    startPortX = e.pageX - customShape.getAbsoluteX(),
                    startPortY = e.pageY - customShape.getAbsoluteY();
                
                customShape.startConnectionPoint.portX = startPortX;
                customShape.startConnectionPoint.portY= startPortY;
                // empty the current selection so that the segment created by the
                // helper is always on top
                customShape.canvas.emptyCurrentSelection();
                
                if (currentLabel) {
                    currentLabel.loseFocus();
                    $(currentLabel.textField).focusout();
                }
                if (customShape.family !== "CustomShape") {
                    return false;
                }
                customShape.setOldX(customShape.getX());
                customShape.setOldY(customShape.getY());
                
                //customShape.startConnectionPoint.x += customShape.getAbsoluteX();
                //customShape.startConnectionPoint.y += customShape.getAbsoluteY();
                customShape.startConnectionPoint.x = customShape.canvas.zoomFactor*realPoint.x;
                customShape.startConnectionPoint.y = customShape.canvas.zoomFactor*realPoint.y;
            } else {
                customShape.canvas.currentConnection.disconnect();
            }
            
            
    //        customShape.increaseParentZIndex(customShape.parent);
            return true;

        };
 };
 PMConnectHandler.prototype.onDragEnd = function (customShape) {
        return function (e, ui) {
            if (!customShape.canvas.currentConnection) {
                customShape.canvas.isDraggingConnectHandler = false;
                if (customShape.canvas.connectionSegment) {
                    //remove the connection segment left
                    $(customShape.canvas.connectionSegment.getHTML()).remove();
                }
                customShape.setPosition(customShape.getOldX(), customShape.getOldY());
                customShape.dragging = false;
                customShape.canvas.hideDragConnectHandlers();
                customShape.canvas.hideDropConnectHandlers();
            } else {
                if (customShape.canvas.connectionSegment) {
                    //remove the connection segment left
                    $(customShape.canvas.connectionSegment.getHTML()).remove();
                    customShape.canvas.currentConnection.connect();
                    customShape.canvas.currentConnection.setSegmentMoveHandlers();
                    customShape.canvas.currentConnection.showPortsAndHandlers();
                }
            }
            
        };
    };


PMConnectHandler.prototype.onDrag = function (customShape) {
    return function (e, ui) {
        if (customShape.canvas.currentConnection) {
            canvas = customShape.canvas;
            endPoint = new PMUI.util.Point();

            var startPoint;
            if (canvas.connectionSegment) {
                $(canvas.connectionSegment.getHTML()).remove();
            }
            
            endPoint.x = e.pageX - canvas.getX() + canvas.getLeftScroll() - canvas.getAbsoluteX();
            endPoint.y = e.pageY - canvas.getY() + canvas.getTopScroll() - canvas.getAbsoluteY();

            //make connection segment
            otherPort = customShape.connection.srcPort.getPoint(false)
                .equals(customShape.getPoint(false)) ? customShape.connection.destPort :
                        customShape.connection.srcPort;

            startPoint = otherPort.getPoint(false);
            startPoint.x = startPoint.x - canvas.getAbsoluteX();
            startPoint.y = startPoint.y - canvas.getAbsoluteY();

            canvas.connectionSegment = new PMUI.draw.Segment({
                startPoint: startPoint,
                endPoint: endPoint,
                parent: canvas
            });
            //canvas.connectionSegment.pointsTo = port;
            canvas.connectionSegment.createHTML();
            canvas.connectionSegment.paint();
        } else {
            customShape.canvas.isDraggingConnectHandler = true;
            var canvas = customShape.getCanvas(),
                endPoint = new PMUI.util.Point(),
                realPoint = canvas.relativePoint(e);
            if (canvas.connectionSegment) {
                //remove the connection segment in order to create another one
                $(canvas.connectionSegment.getHTML()).remove();
            }
            
            //Determine the point where the mouse currently is
            endPoint.x = realPoint.x*customShape.canvas.zoomFactor;
            endPoint.y = realPoint.y*customShape.canvas.zoomFactor;
            
            //creates a new segment from where the helper was created to the
            // currently mouse location
           
            canvas.connectionSegment = new PMUI.draw.Segment({
                startPoint: customShape.startConnectionPoint,
                endPoint: endPoint,
                parent: canvas,
                zOrder: PMUI.util.Style.MAX_ZINDEX * 2
            });
                
            //We make the connection segment point to helper in order to get
            // information when the drop occurs
            canvas.connectionSegment.pointsTo = customShape;
            //create HTML and paint
            //canvas.connectionSegment.createHTML();
            canvas.connectionSegment.paint();
        }
        
        
    };
};

PMConnectHandler.prototype.onClick = function (obj) {
    return function (e, ui) {
        alert('clicked');
    };
}

    /**
     * Drag enter hook for this drop behavior, marks that a shape is over a
     * droppable element
     * @param {PMUI.draw.Shape} shape
     * @return {Function}
     */
    PMConnectHandler.prototype.onDropOver = function (shape, handler) {
        return function (e, ui) {
            //shape.entered = true;
            //handler.style.remove
            //handler.style.addClasses(['pmConnnectHandler']);
        };
    };

    /**
     * Drag leave hook for this drop behavior, marks that a shape has left a
     * droppable element
     * @param {PMUI.draw.Shape} shape
     * @return {Function}
     */
    PMConnectHandler.prototype.onDropOut = function (shape, handler) {
        return function (e, ui) {
            shape.entered = false;
            handler.style.addClasses(['pmConnnectHandler']);
        };
    };
    /**
     * On drop handler for this drop behavior, creates a connection between the
     * droppable element and the dropped element, or move ports among those shapes
     * @param {PMUI.draw.Shape} shape
     * @return {Function}
     */
PMConnectHandler.prototype.onDrop = function (shape, handler) {
    var that = this;
    return function (e, ui) {
        if (!shape.canvas.currentConnection) {
            var canvas  = shape.getCanvas(),
                id = ui.draggable.attr('id'),
                x,
                y,
                currLeft,
                currTop,
                startPoint,
                sourceShape,
                sourcePort,
                endPort,
                endPortXCoord,
                endPortYCoord,
                connection,
                currentConnection = canvas.currentConnection,
                srcPort,
                dstPort,
                port,
                prop,
                success = false,
                command,
                aux,
                segmentMap;
            shape.entered = false;
            //if (!shape.drop.dropStartHook(shape, e, ui)) {
            //    return false;
            //}
            //if (shape.getConnectionType() === "none") {
            //    return true;
            //}
            //
            //if (currentConnection) {
            //    srcPort = currentConnection.srcPort;
            //    dstPort = currentConnection.destPort;
            //    if (srcPort.id === id) {
            //        port = srcPort;
            //    } else if (dstPort.id === id) {
            //        port = dstPort;
            //    } else {
            //        port = null;
            //    }
            //}
            //if (ui.helper && ui.helper.attr('id') === "drag-helper") {
    
                //if its the helper then we need to create two ports and draw a
                // connection
                //we get the points and the corresponding shapes involved
                startPoint = shape.canvas.connectionSegment.startPoint;
                sourceShape = shape.canvas.connectionSegment.pointsTo;
                //determine the points where the helper was created
                if (sourceShape.parent && sourceShape.parent.id === shape.id) {
                    return true;
                }
                if (!PMDesigner.connectValidator.isValid(sourceShape, shape).result) {
                    //show invalid message
                    PMDesigner.msgFlash(PMDesigner.connectValidator.isValid(sourceShape, shape).msg, document.body, 'info', 3000, 5);
                    return false;
                }
                if (((sourceShape.extendedType === 'START') || (sourceShape.extendedType === 'START' && (sourceShape.evn_marker === 'MESSAGE'|| sourceShape.evn_marker === 'TIMER'))) && !PMDesigner.connectValidator.oneToOneValidator(sourceShape).result) {
                    //show invalid message
                    PMDesigner.msgFlash(PMDesigner.connectValidator.oneToOneValidator(sourceShape, shape).msg, document.body, 'info', 3000, 5);
                    return false;
                }
                sourceShape.setPosition(sourceShape.oldX, sourceShape.oldY);
                startPoint.x -= sourceShape.absoluteX - shape.canvas.getAbsoluteX();
                startPoint.y -= sourceShape.absoluteY - shape.canvas.getAbsoluteY();
                //create the ports
                sourcePort = new PMUI.draw.Port({
                    width: 10,
                    height: 10
                });
                endPort = new PMUI.draw.Port({
                    width: 10,
                    height: 10
                });
    
                //determine the position where the helper was dropped
                endPortXCoord = ui.offset.left - shape.canvas.getX() -
                    shape.getAbsoluteX() + shape.canvas.getLeftScroll();
                endPortYCoord = ui.offset.top - shape.canvas.getY() -
                    shape.getAbsoluteY() + shape.canvas.getTopScroll();
                // add ports to the corresponding shapes
                // addPort() determines the position of the ports
                sourceShape.addPort(sourcePort, startPoint.x, startPoint.y);
                shape.addPort(endPort, endPortXCoord, endPortYCoord,
                    false, sourcePort);
    
                //add ports to the canvas array for regularShapes
                //shape.canvas.regularShapes.insert(sourcePort).insert(endPort);
                //create the connection
                connection = new PMFlow({
                    srcPort : sourcePort,
                    destPort: endPort,
                    segmentColor: new PMUI.util.Color(0, 0, 0),
                    name: "",
                    canvas : shape.canvas,
                    segmentStyle: shape.connectionType.segmentStyle,
                    flo_type: shape.connectionType.type
                });
    
                connection.setSrcDecorator(new PMUI.draw.ConnectionDecorator({
                    width: 11,
                    height: 11,
                    canvas: canvas,
                    decoratorPrefix: (typeof shape.connectionType.srcDecorator !== 'undefined'
                        && shape.connectionType.srcDecorator !== null) ?
                            shape.connectionType.srcDecorator : "mafe-decorator",
                    decoratorType: "source",
                    parent: connection
                }));
    
                connection.setDestDecorator(new PMUI.draw.ConnectionDecorator({
                    width: 11,
                    height: 11,
                    canvas: canvas,
                    decoratorPrefix: (typeof shape.connectionType.destDecorator !== 'undefined'
                        && shape.connectionType.destDecorator !== null) ?
                            shape.connectionType.destDecorator : "mafe-decorator",
                    decoratorType: "target",
                    parent: connection
                }));
    
                /*directionDec = connection.getDestPort().getDirection();
                if (directionDec) {
                    if (directionDec === 0 || directionDec === 2) {
                        //For TOP and BOTTOM
                        connection.destDecorator.setX(ui.offset.left);
                    } else if(directionDec === 1 || directionDec === 3){
                        //For RIGHT and LEFT
                        connection.destDecorator.setY(ui.offset.top);
                    }
                }*/
                connection.canvas.commandStack.add(new PMUI.command.CommandConnect(connection));
    
                //connect the two ports
                connection.connect();
                connection.setSegmentMoveHandlers();
    
                //add the connection to the canvas, that means insert its html to
                // the DOM and adding it to the connections array
                canvas.addConnection(connection);
    
                // Filling PMFlow fields
                connection.setTargetShape(endPort.parent);
                connection.setOriginShape(sourcePort.parent);
                connection.savePoints();
    
                // now that the connection was drawn try to create the intersections
                connection.checkAndCreateIntersectionsWithAll();
    
                //attaching port listeners
                sourcePort.attachListeners(sourcePort);
                endPort.attachListeners(endPort);
    
                // finally trigger createEvent
                canvas.triggerCreateEvent(connection, []);
        } else {
            var connection = shape.canvas.currentConnection,
                id = ui.draggable.attr('id'),
                canvas  = shape.getCanvas();
    
                if (shape.canvas.dragConnectHandlers.get(0).id === id) {
                    port = shape.canvas.dragConnectHandlers.get(0).relativeShape;
    
                } else if (shape.canvas.dragConnectHandlers.get(1).id === id) {
                    port = shape.canvas.dragConnectHandlers.get(1).relativeShape;
                } else {
                    port = null;
                }

                //if (connection.getSrcPort().parent.id === shape.id) {
                //    PMDesigner.msgFlash('Invalid connection'.translate(), document.body, 'info', 3000, 5);
                //    return true;
                //}

                //if (!PMDesigner.connectValidator.isValid(port.parent, shape).result) {
                //    //show invalid message
                //    PMDesigner.msgFlash(PMDesigner.connectValidator.isValid(port.parent, shape).msg, document.body, 'info', 3000, 5);
                //    return false;
                //}
                //if ((sourceShape.extendedType === 'START' && (sourceShape.evn_marker === 'MESSAGE'|| sourceShape.evn_marker === 'TIMER')) && !PMDesigner.connectValidator.oneToOneValidator(sourceShape).result) {
                //    //show invalid message
                //    PMDesigner.msgFlash(PMDesigner.connectValidator.oneToOneValidator(sourceShape, shape).msg, document.body, 'info', 3000, 5);
                //    return false;
                //}

                port.setOldParent(port.getParent());
                port.setOldX(port.getX());
                port.setOldY(port.getY());
                
                x = ui.position.left;
                y = ui.position.top;

                endPortXCoord = ui.offset.left - shape.canvas.getX() -
                    shape.getAbsoluteX() + shape.canvas.getLeftScroll();
                endPortYCoord = ui.offset.top - shape.canvas.getY() -
                    shape.getAbsoluteY() + shape.canvas.getTopScroll();
                port.setPosition(endPortXCoord, endPortYCoord);
                shape.dragging = false;
                if (shape.getID() !== port.parent.getID()) {
                    port.parent.removePort(port);
                    currLeft = ui.offset.left - canvas.getX() -
                        shape.absoluteX + shape.canvas.getLeftScroll();
                    currTop = ui.offset.top - canvas.getY() - shape.absoluteY +
                        shape.canvas.getTopScroll();
                    shape.addPort(port, currLeft, currTop, true);
                    canvas.regularShapes.insert(port);
                } else {
                    shape.definePortPosition(port, port.getPoint(true));
                }
                
                // LOGIC: when portChangeEvent is triggered it gathers the state
                // of the connection but since at this point there's only a segment
                // let's paint the connection, gather the state and then disconnect
                // it (the connection is later repainted on, I don't know how)
                
                aux = {
                    before: {
                        condition: connection.flo_condition,
                        type: connection.flo_type,
                        segmentStyle: connection.segmentStyle,
                        srcDecorator: connection.srcDecorator.getDecoratorPrefix(),
                        destDecorator: connection.destDecorator.getDecoratorPrefix()
                    },
                    after: {
                        //type : prop.type,
                        //segmentStyle: prop.connection,
                        //srcDecorator: prop.srcDecorator,
                        //destDecorator: prop.destDecorator
                        //condition: connection.flo_condition,
                        type: connection.flo_type,
                        segmentStyle: connection.segmentStyle,
                        srcDecorator: connection.srcDecorator.getDecoratorPrefix(),
                        destDecorator: connection.destDecorator.getDecoratorPrefix()
                    }
                };
                connection.connect();
                
                canvas.triggerPortChangeEvent(port);
                connection.disconnect();
                command = new PMCommandReconnect(port, aux);
                //command.execute();
                canvas.commandStack.add(command);
                canvas.hideDropConnectHandlers();
        }
        return false;
        };
    };

var PMShape = function (options) {
    PMUI.draw.CustomShape.call(this, options);
    this.extended = null;
    this.extendedType = null;
    this.relationship = null;

    this.midPointArray = [];
    this.htmlPorts = null;
    this.hasConnectHandlers = false;

    /**
     * Stores the label object used to show into the canvas
     * @type {Object}
     * @private
     */
    this.label = this.labels.get(0);
    /**
     * Array of markers added to this activity
     * @type {Array}
     */
    this.markersArray = new PMUI.util.ArrayList();

    this.businessObject = null;
    PMShape.prototype.init.call(this, options);
};

PMShape.prototype = new PMUI.draw.CustomShape();

PMShape.prototype.type = 'PMShape';
PMShape.prototype.pmConnectionDropBehavior = null;
PMShape.prototype.pmContainerDropBehavior = null;

PMShape.prototype.init = function (options) {
    var defaults = {
        extended: {},
        relationship: {}
    };
    jQuery.extend(true, defaults, options);
    this.setExtended(defaults.extended)
        .setExtendedType(defaults.extendedType)
        .setRelationship(defaults.relationship);
    if (defaults.markers) {
        this.addMarkers(defaults.markers, this);
    }
        //.createConnectHandlers('class','class');

};
/**
 * Sets the label element
 * @param {String} value
 * @return {*}
 */
PMShape.prototype.setName = function (value) {
    if (this.label) {
        this.label.setMessage(value);
    }
    return this;
};

/**
 * Returns the label text
 * @return {String}
 */
PMShape.prototype.getName = function () {
    var text = "";
    if (this.label) {
        text = this.label.getMessage();
    }
    return text;
};
PMShape.prototype.setExtendedType = function (type) {
    this.extendedType = type;
    return this;
};
PMShape.prototype.getDataObject = function() {
    return {
};
};
PMShape.prototype.setRelationship = function (relationship) {
    this.relationship = relationship;
    return this;
};
PMShape.prototype.addRelationship = function (object) {
    if (typeof object === "object") {
        jQuery.extend(true, this.relationship, object);
    }
    return this;
};
PMShape.prototype.setExtended = function (extended) {
    var ext;
    ext = (typeof extended === 'object')? extended : {};
    this.extended = ext;
    return this;
};
PMShape.prototype.getExtendedObject = function () {
    this.extended = {
        extendedType: this.extendedType
    };
    return this.extended;
};
PMShape.prototype.getMarkers = function () {
    return this.markersArray;
};
//PMShape.prototype.setDropBehavior = function (obj) {
//    var factory = new PMUI.behavior.BehaviorFactory({
//            products:{
//                "pmconnection": PMConnectionDropBehavior,
//                "connectioncontainer": PMUI.behavior.ConnectionContainerDropBehavior,
//                "connection": PMUI.behavior.ConnectionDropBehavior,
//                "container": PMUI.behavior.ContainerDropBehavior,
//                "nodrop": PMUI.behavior.NoDropBehavior
//            },
//            defaultProduct: "nodrop"
//        });
//    this.drop = factory.make(obj);
//    return this;
//};
PMShape.prototype.dropBehaviorFactory = function (type, selectors) {
      if (type === 'pmconnection') {
        if (!this.pmConnectionDropBehavior) {
            this.pmConnectionDropBehavior = new PMConnectionDropBehavior(selectors);
        }
        return this.pmConnectionDropBehavior;
    } else if (type === 'pmcontainer') {
        if (!this.pmContainerDropBehavior) {
            this.pmContainerDropBehavior = new PMContainerDropBehavior(selectors);
        }
        return this.pmContainerDropBehavior;
    } else {
        return PMUI.draw.CustomShape.prototype.dropBehaviorFactory.call(this, type, selectors);
    }
}

PMShape.prototype.setDragBehavior = function (obj) {
    var factory = new PMUI.behavior.BehaviorFactory({
        products: {
            "pmsegment": PMSegmentDragBehavior,
            "customshapedrag" : PMUI.behavior.CustomShapeDragBehavior,
            "regulardrag": PMUI.behavior.RegularDragBehavior,
            "connectiondrag": PMUI.behavior.ConnectionDragBehavior,
            "connection": PMUI.behavior.ConnectionDragBehavior,
            "nodrag": PMUI.behavior.NoDragBehavior
        },
        defaultProduct: "nodrag"
    });
    this.drag = factory.make(obj);
    if (this.html && this.drag) {
        this.drag.attachDragBehavior(this);
        
    }
    if (this.canvas) {
        this.canvas.hideDragConnectHandlers();
    }
    
    return this;
};
/**
 * This function will attach all the listeners corresponding to the CustomShape
 * @chainable
 */
PMShape.prototype.attachListeners = function () {
    var that = this;
    if (this.html === null) {
        return this;
    }
   
    //drag options for the added shapes
    if (!this.canvas.readOnly) {
        var $customShape = $(this.html).click(this.onClick(this));
        $customShape.on("mousedown", this.onMouseDown(this));
        //$customShape.mousemove(this.onMouseMove(this));
        $customShape.mouseup(this.onMouseUp(this));
        $customShape.mouseover(this.onMouseOver(this));
        $customShape.mouseout(this.onMouseOut(this));
        $customShape.on("contextmenu", function (e) {
            e.preventDefault();
        });
        this.updateBehaviors();
        //$customShape.droppable({
        //         accept:  '.dragConnectHandler, .pmui-port',
        //        
        //          drop: this.onDrop(this),
        //          over: this.onDropOver(this),
        //          //out: this.onDropOut(this),
        //          greedy: true,
        //          tolerance: 'intersect'
        //    })


    } else {
        if(this.canvas.hasClickEvent) {
            var $customShape = $(this.html).click(function(e){
                if(that.hasClick) {
                    that.hasClick(e);
                }
            });
            this.updateBehaviors(); 
        }
    }
    
    
    return this;

};

PMShape.prototype.showConnectDropHelper = function (i, customShape) {
    var connectHandler, x, y;
    connectHandler = customShape.canvas.dropConnectHandlers.get(i);
    connectHandler.setDimension(18*customShape.canvas.getZoomFactor(), 18*customShape.canvas.getZoomFactor());
    x = customShape.getAbsoluteX() - customShape.canvas.getAbsoluteX()+customShape.xMidPoints[i] - connectHandler.width/2 - 1;
    y = customShape.getAbsoluteY() - customShape.canvas.getAbsoluteY()+customShape.yMidPoints[i] - connectHandler.height/2 - 1;
    if (customShape.parent.type !== 'PMCanvas') {
        x += 3;
        y += 2;
    }
    connectHandler.setPosition(x, y);
    
    connectHandler.relativeShape = customShape;
    connectHandler.attachDrop();
    //connectHandler.paint();
    connectHandler.setVisible(true);
}

/**
 * Handler for the onmousedown event, changes the draggable properties
 * according to the drag behavior that is being applied
 * @param {PMUI.draw.CustomShape} CustomShape
 * @returns {Function}
 */
PMShape.prototype.onMouseDown = function (customShape) {
    return function (e, ui) {
        var canvas = customShape.canvas;
        if (e.which === 3) {
            $(canvas.html).trigger("rightclick", [e, customShape]);
        } else {
           canvas.hideDragConnectHandlers();
           canvas.hideDropConnectHandlers(); 
        //
            //if (customShape.dragType === customShape.DRAG) {
                customShape.setDragBehavior("customshapedrag");
            
        //
        //    } else if (customShape.dragType === customShape.CONNECT) {
                //customShape.setDragBehavior("pmsegment");
        //    } else {
        //        customShape.setDragBehavior("nodrag");
        }
            customShape.dragging = true;
        //
        e.stopPropagation();
        
    };
};

PMShape.prototype.showConnectDragHelpers = function (i, shape) {
    var y, x, connectHandler;
    connectHandler = shape.canvas.dragConnectHandlers.get(i);
    connectHandler.setDimension(15*shape.canvas.getZoomFactor(), 15*shape.canvas.getZoomFactor());
    //connectHandler.setPosition(shape.getZoomX()+shape.xMidPoints[i] - connectHandler.width/2 -1 , shape.getZoomY()+shape.yMidPoints[i]-connectHandler.height/2 -1);
    x = shape.getAbsoluteX() - shape.canvas.getAbsoluteX()+shape.xMidPoints[i] - connectHandler.width/2 -1;
    y = shape.getAbsoluteY()- shape.canvas.getAbsoluteY()+1+shape.yMidPoints[i]-connectHandler.height/2 -1;
    if (shape.parent.type !== 'PMCanvas') {
        x += 3;
        y += 2;
    }
    connectHandler.setPosition(x, y);

    //connectHandler.paint();
    
    connectHandler.setVisible(true);
    connectHandler.relativeShape = shape;
    connectHandler.attachListeners();
};

PMShape.prototype.onMouseOver = function (shape) {
    //var that = this;
    return function (e, ui) {
        
        if (shape.canvas.isDragging || shape.canvas.currentLabel ||shape.entered  || shape.canvas.isResizing || PMUI.isCtrl) {
                shape.canvas.hideDragConnectHandlers();
                return;
        }
        if (!shape.canvas.isDraggingConnectHandler && !shape.dragging &&
            !shape.canvas.currentSelection.find('id', shape.id) &&
            !shape.canvas.currentConnection &&
            !shape.canvas.isMouseDown) {
        
            if (shape.extendedType === "TEXT_ANNOTATION") {
                shape.canvas.hideDragConnectHandlers();
                shape.showConnectDragHelpers(3,shape);
                for (i = 0; i < shape.canvas.dragConnectHandlers.getSize(); i += 1) {
                //for (i = 0; i < 4; i += 1) {
                    connectHandler = shape.canvas.dragConnectHandlers.get(i);
                    connectHandler.relativeShape = shape;
                    connectHandler.attachListeners();
                }
            } else {
                if (shape.extendedType !== "H_LABEL" && shape.extendedType !== "V_LABEL"
                    && shape.extendedType !== "LANE" && shape.extendedType !== "POOL"
                    &&shape.extendedType !== "GROUP") {
                    //for (i = 0; i < shape.canvas.dragConnectHandlers.getSize(); i += 1) {
                    shape.canvas.hideDragConnectHandlers();
                    for (i = 0; i < 4; i += 1) {
                        shape.showConnectDragHelpers(i,shape);
                    }
                    shape.canvas.emptyCurrentSelection();
                }
                
            }

            
        }
        e.stopPropagation();
    };

    
};
PMShape.prototype.onMouseOut = function (customShape) {
    var that = this;
    return function (e, ui) {
        customShape.dragging = false;
        e.stopPropagation();
    };
};

/**
 * Overwrite the parent function to set the dimension
 * @param {Number} x
 * @param {Number} y
 * @return {*}
 */
PMShape.prototype.setDimension = function (x, y) {
    var factor;
    PMUI.draw.CustomShape.prototype.setDimension.call(this, x, y);
    //jCore.CustomShape.prototype.setDimension.call(this, x, y);
    //PMShape.CustomShape.prototype.setDimension.call(this, x, y);
    
    if (this.getType() === 'PMEvent' || this.getType() === 'PMGateway' || this.getType() === 'PMData') {
        factor = 3;
    } else {
        if (this.getType() === 'PMActivity') {
            factor = 1;
        } else {
            factor = 1;
        }
    }
    if (this.label) {
        this.label.setDimension((this.zoomWidth * 0.9 * factor) / this.canvas.zoomFactor,
            this.label.height);
        this.label.setLabelPosition(this.label.location, this.label.diffX, this.label.diffY);
    }
    if (this.getType() === 'PMPool') {
        this.paint();
    }

    return this;
};
/**
 * Creates a drag helper for drag and drop operations for the helper property
 * in jquery ui draggable
 * TODO Create a singleton object for this purpose
 * @returns {String} html
 */
PMShape.prototype.createDragHelper = function () {
    var html = document.createElement("div");

    // can't use class style here
    html.style.width = 8 + "px";
    html.style.height = 8 + "px";
    html.style.borderRadius = "5px";
    html.style.marginTop = "-5px";
    html.style.marginLeft = "-5px";
    html.style.backgroundColor = "rgb(92, 156, 204)";
    html.style.zIndex = 2 * PMUI.draw.Shape.prototype.MAX_ZINDEX;
    html.id = "drag-helper";
    html.className = "drag-helper";
    // html.style.display = "none";
    return html;
};
PMShape.prototype.getContextMenu = function () {
    return {};
};

PMShape.prototype.getHTMLPorts = function () {
    if (!this.htmlPorts) {
        //this.createHTMLPorts();
    }
    return this.htmlPorts;
};


PMShape.prototype.updatePropertiesHTMLPorts = function () {
    var items = jQuery(this.htmlPorts).children(), k,
    point =this.midPointArray;
    for (k = 0; k < items.length; k+=1) {
        items[k].style.left = point[k].x + "px";
        items[k].style.top = point[k].y + "px";
    }

    return this;
};

/**
 * Adds markers to the arrayMarker property
 * @param {Array} markers
 * @param {Object} parent
 * @return {*}
 */
PMShape.prototype.addMarkers = function (markers, parent) {
    var newMarker, i, factoryMarker;
    if (jQuery.isArray(markers)) {
        for (i = 0; i < markers.length; i += 1) {
            factoryMarker = markers[i];
            factoryMarker.parent = parent;
            factoryMarker.canvas = parent.canvas;
            newMarker = new PMMarker(factoryMarker);
            this.markersArray.insert(newMarker);
        }
    }
    return this;
};

/**
 * Paint the shape
 */
PMShape.prototype.paint = function () {
    var m, marker;
    PMUI.draw.CustomShape.prototype.paint.call(this);
    for (m = 0; m < this.markersArray.getSize(); m += 1) {
        marker = this.markersArray.get(m);
        marker.paint();
    }

};

/**
 *  Extend applyZoom of CustomShape for apply Zoom into Markers
 *  @return {*}
 */
PMShape.prototype.applyZoom = function () {
    var i, marker;
    PMUI.draw.CustomShape.prototype.applyZoom.call(this);
    for (i = 0; i < this.markersArray.getSize(); i += 1) {
        marker = this.markersArray.get(i);
        marker.applyZoom();
    }
    return this;
};
/**
 * Set flow as a default and update the other flows
 * @param {String} destID
 * @returns {AdamShape}
 */
PMShape.prototype.setDefaultFlow = function (floID) {
    var i,
        port,
        connection;
    for (i = 0; i < this.getPorts().getSize(); i += 1) {
        port = this.getPorts().get(i);
        connection = port.connection;
        this.updateDefaultFlow(0);
        if (connection.srcPort.parent.getID() === this.getID()) {
            if (connection.getID() === floID) {
                this.updateDefaultFlow(floID);
                connection.setFlowCondition("");
                connection.changeFlowType('default');
                connection.setFlowType("DEFAULT");
            } else if (connection.getFlowType() === 'DEFAULT') {
                connection.changeFlowType('sequence');
                connection.setFlowType("SEQUENCE");
            }
        }

    }
    return this;
};

PMShape.prototype.hideAllChilds = function() {
    var i,
        child,
        j,
        flow,
        arrayFlow= {};
    for (i = 0; i < this.getChildren().getSize(); i += 1) {
        child = this.getChildren().get(i);
        child.hideElement();
    }
    this.canvas.hideFlowRecursively(this);
};

PMShape.prototype.showAllChilds = function() {
    var i,child;
    for (i = 0; i < this.getChildren().getSize(); i += 1) {
        child = this.getChildren().get(i);
        child.showElement();
    }
};

PMShape.prototype.hideElement = function() {
    this.html.style.visibility = 'hidden';
    return this;
};

PMShape.prototype.showElement = function() {
    this.html.style.visibility = 'visible';
    return this;
};

PMShape.prototype.getBpmnElementType = function () {
    var map = {
        'TASK' : 'bpmn:Task',
        'START' : 'bpmn:StartEvent',
        'END' : 'bpmn:EndEvent',
        'EXCLUSIVE' : 'bpmn:ExclusiveGateway',
        'INCLUSIVE' : 'bpmn:InclusiveGateway',
        'PARALLEL' : 'bpmn:ParallelGateway',
        'COMPLEX' : 'bpmn:ComplexGateway',
        'EVENTBASED' : 'bpmn:EventBasedGateway',
        'SUB_PROCESS' : 'bpmn:SubProcess',
        'INTERMEDIATE': 'bpmn:IntermediateCatchEvent',
        'TEXT_ANNOTATION': 'bpmn:TextAnnotation',
        'GROUP': 'bpmn:Group',
        'PARTICIPANT':  'bpmn:Participant',
        'POOL':  'bpmn:Participant',
        'LANE':  'bpmn:Lane',
        'DATASTORE': 'bpmn:DataStore'
    };
    if (this.evn_type === 'INTERMEDIATE' && this.evn_behavior  === 'THROW') {
        return 'bpmn:IntermediateThrowEvent';
    } else {
        return map[this.extendedType];
    }

};

PMShape.prototype.createWithBpmn = function(bpmnElementType, name) {
    var businessObject = PMDesigner.bpmnFactory.create(bpmnElementType, {id: 'el_' + this.id, name: this.getName()});
    if (!businessObject.di) {
        if (this.type === 'PMParticipant' || this.type === 'PMPool' || this.type === 'PMLane') {
            businessObject.di = PMDesigner.bpmnFactory.createDiShape(businessObject, {}, {
                id: 'di_' + businessObject.id,
                isHorizontal: true
            });
        } else {
            businessObject.di = PMDesigner.bpmnFactory.createDiShape(businessObject, {}, {
                id: 'di_' + businessObject.id
            });
        }
    }
    this[name] = businessObject;
    //this.businessObject = businessObject;
};


PMShape.prototype.updateShapeParent = function(businessObject, parentBusinessObject) {
    var parentDi = parentBusinessObject && parentBusinessObject.di;
    if (parentBusinessObject.$type === 'bpmn:Lane' ) {

        this.parent.updateLaneSetParent(businessObject, parentBusinessObject);
        parentBusinessObject = this.parent.parent.businessObject;
        var parentDi = parentBusinessObject && parentBusinessObject.di;
    }
    this.updateSemanticParent(businessObject, parentBusinessObject);
    this.updateDiParent(businessObject.di, parentDi);

};


PMShape.prototype.updateSemanticParent = function(businessObject, newParent) {

    if (businessObject.$parent === newParent) {
        return;
    }

    var children;

    if (businessObject.$parent) {
        // remove from old parent
        children = businessObject.$parent.get('flowElements');
        CollectionRemove(children, businessObject);
    }

    if (!newParent) {
        businessObject.$parent = null;
    } else {
        // add to new parent
        children = newParent.get('flowElements');
        children.push(businessObject);
        businessObject.$parent = newParent;

    }
};

PMShape.prototype.updateDiParent = function(di, parentDi) {

    if (parentDi && !parentDi.$instanceOf('bpmndi:BPMNPlane')) {
        parentDi = parentDi.$parent;
    }

    if (di.$parent === parentDi) {
        return;
    }

    var planeElements = (parentDi || di.$parent).get('planeElement');

    if (parentDi) {
        planeElements.push(di);
        di.$parent = parentDi;
    } else {
        CollectionRemove(planeElements, di);
        di.$parent = null;
    }
};

PMShape.prototype.updateBounds = function(di) {
   var bounds = this.type === 'label' ? this._getLabel(di).bounds : di.bounds;
   var x = this.getX(), y = this.getY(),
    parent = this.parent;
    while (parent) {
        x = parent.getX() + x;
        y = parent.getY() + y;
        parent = parent.parent;
    }

    _.extend(bounds, {
        x: x,
        y: y,
        width: this.width,
        height: this.height
    });

};

PMShape.prototype._getLabel = function(di) {
    if (!di.label) {
        di.label = PMDesigner.bpmnFactory.createDiLabel();
    }

    return di.label;
};


PMShape.prototype.createBpmn = function(type) {
        if(!this.businessObject && !(this instanceof PMUI.draw.MultipleSelectionContainer)){
            this.createWithBpmn(type, 'businessObject');
        }
        this.updateBounds(this.businessObject.di);
        if (this.parent.businessObject){

            this.updateShapeParent(this.businessObject, this.parent.businessObject);
        } else {
            //Here create busines object to new process
            this.parent.createBusinesObject();
            this.updateShapeParent(this.businessObject, this.parent.businessObject);
        }

        //PMDesigner.moddle.toXML(PMDesigner.businessObject, function (err, xmlStrUpdated) {
        //    //
        //});

};
//remove bpmn section
PMShape.prototype.removeBpmn = function() {
    var parentShape = this.parent;
    var businessObject = this.businessObject,
        parentBusinessObject = parentShape && parentShape.businessObject,
        parentDi = parentBusinessObject && parentBusinessObject.di;

    if (this.parent.businessObject.$type === 'bpmn:Lane' ) {

        this.parent.updateLaneSetParent(businessObject);
        //parentBusinessObject = this.parent.parent.businessObject;
        //var parentDi = parentBusinessObject && parentBusinessObject.di;
    }

    this.updateSemanticParent(businessObject);
    this.updateDiParent(businessObject.di);



};

PMShape.prototype.updateBpmn = function() {
    this.updateBounds(this.businessObject.di);

    if (!this.parent.businessObject){
        //Here create busines object to new process
        this.parent.createBusinesObject();
    }
    this.updateShapeParent(this.businessObject, this.parent.businessObject);

};

PMShape.prototype.setBPPMName = function (name) {
    if (this.businessObject || this.participantObject ) {
        this.businessObject.name = name;
    }
};
/**
 * @class PMFlow
 * Handle the designer flows
 *
 * @constructor
 * Create a new flow object
 * @param {Object} options
 */
 var PMFlow = function (options) {
    PMUI.draw.Connection.call(this, options);
    /**
     * Unique Idenfier
     * @type {String}
     */
     this.flo_uid = null;
    /**
     * Defines the connecion/flow type
     * @type {String}
     */
     this.flo_type = null;
    /**
     * Defines the connection/flow name
     * @type {String}
     */
     this.flo_name = null;
    /**
     * Unique Identifier of the source shape
     * @type {String}
     */
     this.flo_element_origin = null;
    /**
     * Defines the type of shape for the source
     * @type {String}
     */
     this.flo_element_origin_type = null;
    /**
     * Unique Identifier of the target shape
     * @type {String}
     */
     this.flo_element_dest = null;
    /**
     * Defines the type of shape for the target
     * @type {String}
     */
     this.flo_element_dest_type = null;
    /**
     * Defines if the flow was followed inmediately
     * @type {Boolean}
     */
     this.flo_is_inmediate = null;
    /**
     * Defines the condition to follow the flow
     * @type {String}
     */
     this.flo_condition = null;
    /**
     * X1 Coordinate
     * @type {Number}
     */
     this.flo_x1 = null;
    /**
     * Y1 Coordinate
     * @type {Number}
     */
     this.flo_y1 = null;
    /**
     * X2 Coordinate
     * @type {Number}
     */
     this.flo_x2 = null;
    /**
     * Y2 Coordinate
     * @type {Number}
     */
     this.flo_y2 = null;
    /**
     * Array of segments that conform the connection
     * @type {Array}
     */
     this.flo_state = null;

     this.label = null;

     PMFlow.prototype.init.call(this, options);
 };
 PMFlow.prototype = new PMUI.draw.Connection();
/**
* Defines the object type
* @type {String}
*/
PMFlow.prototype.type = "Connection";  //TODO Replace this type by PMFlow when jCore will be updated

/**
 * Initialize the object with default values
 * @param {Object} options
 */
 PMFlow.prototype.init = function (options) {
    var  defaults = {
        flo_type: 'SEQUENCE',
        flo_is_inmediate: true,
        flo_x1: 0,
        flo_y1: 0,
        flo_x2: 0,
        flo_y2: 0,
        name: ''
    };
    jQuery.extend(true, defaults, options);
    this.setFlowType(defaults.flo_type)
    .setFlowUid(defaults.flo_uid)
    .setIsInmediate(defaults.flo_is_inmediate)
    .setOriginPoint(defaults.flo_x1, defaults.flo_y1)
    .setTargetPoint(defaults.flo_x2, defaults.flo_y2);

    this.setFlowName(defaults.name || null);
    this.setFlowOrigin(defaults.flo_element_origin || null, defaults.flo_element_origin_type || null);
    this.setFlowTarget(defaults.flo_element_dest || null, defaults.flo_element_dest_type || null);
    this.setFlowCondition(defaults.flo_condition || null);
    this.setFlowState(defaults.flo_state || null);
};

/**
 * Returns the flow's name
 * @return {String}
 */
 PMFlow.prototype.getName = function () {
    return this.flo_name;
};
/**
 * Sets the label element
 * @param {String} value
 * @return {*}
 */
PMFlow.prototype.setName = function (name) {
    if (typeof name !== 'undefined') {
        this.flo_name = name;
        if (this.label) {
            this.label.setMessage(name);
        }
    }
    return this;
};
/**
 * Returns the flow conditions
 * @return {String}
 */
 PMFlow.prototype.getFlowCondition = function () {
    return this.flo_condition;
};

/**
 * Defines the unique identiier property
 * @param {String} value
 * @return {*}
 */
 PMFlow.prototype.setFlowUid = function (value) {
    this.flo_uid = value;
    return this;
};

/**
 * Defines the connection type
 * @param {String} type
 * @return {*}
 */
 PMFlow.prototype.setFlowType = function (type) {
    this.flo_type = type;
    return this;
};

/** Return Flow Type
 *
 * @returns {String}
 */
 PMFlow.prototype.getFlowType = function () {
    return this.flo_type;
};

/**
 * Sets the inmediately behavior of the connection
 * @param {Boolean} value
 * @return {*}
 */
 PMFlow.prototype.setIsInmediate = function (value) {
    this.flo_is_inmediate = value;
    return this;
};

/**
 * Sets the origin point
 * @param {Number} x
 * @param {Number} y
 * @return {*}
 */
 PMFlow.prototype.setOriginPoint = function (x, y) {
    this.flo_x1 = x;
    this.flo_y1 = y;
    return this;
};

/**
 * Sets the target point
 * @param {Number} x
 * @param {Number} y
 * @return {*}
 */
 PMFlow.prototype.setTargetPoint = function (x, y) {
    this.flo_x2 = x;
    this.flo_y2 = y;
    return this;
};

/**
 * Sets the connection label
 * @param {String} name
 * @return {*}
 */
 PMFlow.prototype.setFlowName = function (name) {
    this.flo_name = name;
    return this;
};

/**
 * Set the shape origin using input data
 * @param {String} code
 * @param {String} type
 * @return {*}
 */
 PMFlow.prototype.setFlowOrigin = function (code, type) {
    this.flo_element_origin = code;
    this.flo_element_origin_type = type;
    return this;
};

/**
 * Set the shape target using input data
 * @param {String} code
 * @param {String} type
 * @return {*}
 */
 PMFlow.prototype.setFlowTarget = function (code, type) {
    this.flo_element_dest = code;
    this.flo_element_dest_type = type;
    return this;
};

/**
 * Sets the flow conditions
 * @param value
 * @return {*}
 */
 PMFlow.prototype.setFlowCondition = function (value) {
    this.flo_condition = value;
    return this;
};

/**
 * Sets the array of segments that conform the connection
 * @param {Array} state
 * @return {*}
 */
 PMFlow.prototype.setFlowState = function (state) {
    this.flo_state = state;
    return this;
};

/**
 * Sets the origin data from a Shape
 * @param {PMShape} shape
 * @return {*}
 */
 PMFlow.prototype.setOriginShape = function (shape) {
    var data;
    if (shape instanceof PMShape) {
        data = this.getNativeType(shape);
        this.flo_element_origin = data.code;
        this.flo_element_origin_type = data.type;
    }
    return this;
};

/**
 * Sets the target data from a Shape
 * @param {PMShape} shape
 * @return {*}
 */
 PMFlow.prototype.setTargetShape = function (shape) {
    var data;
    if (shape instanceof PMShape) {
        data = this.getNativeType(shape);
        this.flo_element_dest = data.code;
        this.flo_element_dest_type = data.type;
    }
    return this;
};

/**
 * Returns the clean object to be sent to the backend
 * @return {Object}
 */
 PMFlow.prototype.getDataObject = function () {
    var typeMap = {
        regular: 'SEQUENCE',
        segmented: 'MESSAGE',
        dotted: 'ASSOCIATION'
    },
    flo_x1 = 0,
    flo_y1 = 0,
    flo_x2 = 0,
    flo_y2 = 0,
    state = this.getPoints(),
    flowElementOrigin,
    flowElementDest,
    portsOrigin,
    portOrigin,
    portsDest,
    portDest,
    k, j,
    bpmnMap = {
        'PMActivity': 'bpmnActivity',
        'PMEvent': 'bpmnEvent',
        'PMGateway': 'bpmnGateway',
        'PMArtifact': 'bpmnArtifact',
        'PMData': 'bpmnData',
        'PMParticipant': 'bpmnParticipant'
    };

    //For get initial port and end port
    
    flowElementOrigin = this.canvas.items.find("id",this.getSrcPort().parent.id);
    if(!flowElementOrigin) {
        throw new Error("Element not found!");
    }
    flowElementDest = this.canvas.items.find("id", this.getDestPort().parent.id);
    if(!flowElementDest) {
        throw new Error("Element not found!");
    }
    //Updating the positions, getting the last ports
    portsOrigin = flowElementOrigin.relatedObject.getPorts().asArray();
    for (k=0 ;k<portsOrigin.length; k+=1) {
        if(portsOrigin[k].connection) {
            if (portsOrigin[k].connection.flo_uid === this.flo_uid) {
                portOrigin = portsOrigin[k];
            }
        }
    }
    if (!portOrigin) {
        portOrigin = {absoluteX:this.flo_x1, absoluteY:this.flo_y1};
    }
    //this.setOriginPoint(portOrigin.absoluteX, portOrigin.absoluteY);
    

    portsDest = flowElementDest.relatedObject.getPorts().asArray();
    for (j=0 ;j<portsDest.length; j+=1) {
        if(portsDest[j].connection) {
            if (portsDest[j].connection.flo_uid === this.flo_uid) {
                portDest = portsDest[j];
            }
        }
    }
    if (!portDest) {
        portDest = {absoluteX:this.flo_x2, absoluteY:this.flo_y2};
    }
    //this.setTargetPoint(portDest.absoluteX, portDest.absoluteY);
    //
    //flo_x1 = this.flo_x1;
    //flo_y1 = this.flo_y1;
    //flo_x2 = this.flo_x2;
    //flo_y2 = this.flo_y2;
    
    
   flo_x1 = this.points[0]['x'] / this.canvas.getZoomFactor();
   flo_y1 = this.points[0]['y'] / this.canvas.getZoomFactor();
   flo_x2 = this.points[this.points.length - 1]['x'] / this.canvas.getZoomFactor();
   flo_y2 = this.points[this.points.length - 1]['y'] / this.canvas.getZoomFactor();
   return {
        flo_uid : this.flo_uid,
        //flo_type : typeMap[this.segmentStyle.toLowerCase()],
        flo_type: this.flo_type,
        flo_name : this.flo_name,
        flo_element_origin : flowElementOrigin.id,
        //flo_element_origin_type : this.flo_element_origin_type,
        flo_element_origin_type : bpmnMap[flowElementOrigin.type],
        flo_element_dest : flowElementDest.id,
        //flo_element_dest_type : this.flo_element_dest_type,
        flo_element_dest_type : bpmnMap[flowElementDest.type] ,
        flo_is_inmediate : this.flo_is_inmediate,
        flo_condition : this.flo_condition,
        flo_state : state,
        flo_x1 : flo_x1,
        flo_y1 : flo_y1,
        flo_x2 : flo_x2,
        flo_y2 : flo_y2
    };
};

/**
 * Converts the type to be sent to backend
 * @param {PMShape} shape
 * @return {Object}
 */
 PMFlow.prototype.getNativeType = function (shape) {
    var type,
        code;
    switch (shape.getType()) {
    case 'PMActivity':
        type = "bpmnActivity";
        code = shape.act_uid;
        break;
    case 'PMGateway':
        type = "bpmnGateway";
        code = shape.gat_uid;
        break;
    case 'PMEvent':
        type = 'bpmnEvent';
        code = shape.evn_uid;
        break;
    case 'PMArtifact':
        type = "bpmnArtifact";
        code = shape.art_uid;
        break;
   case 'PMData':
        type = "bpmnData";
        code = shape.dat_uid;
        break;
   case 'PMParticipant':
        type = "bpmnParticipant";
        code = shape.dat_uid;
        break;
    }
    return {
        "type" : type,
        "code" : code
    };
};

PMFlow.prototype.showMoveHandlers = function () {
    PMUI.draw.Connection.prototype.showMoveHandlers.call(this);
    this.canvas.updatedElement = [{
        relatedObject: this
    }];
    $(this.html).trigger('selectelement');

    return this;
};

/**
 * Get Segment Width
 * @returns {Number}
 */
 PMFlow.prototype.getSegmentHeight = function (index) {
    return Math.abs(this.lineSegments.get(index).endPoint.y
        - this.lineSegments.get(index).startPoint.y);
};
/**
 * Get Segment Width
 * @returns {Number}
 */
 PMFlow.prototype.getSegmentWidth = function (index) {
    return Math.abs(this.lineSegments.get(index).endPoint.x
        - this.lineSegments.get(index).startPoint.x);
};
/**
 * Get Label Coordinates
 * @returns {Point}
 */

 PMFlow.prototype.getLabelCoordinates = function () {
    var  x, y, index = 0, diffX, diffY, i, max;
    max = (this.getSegmentWidth(0) > this.getSegmentHeight(0)) ?
    this.getSegmentWidth(0) : this.getSegmentHeight(0);

    for (i = 1; i < this.lineSegments.getSize(); i += 1) {
        diffX = this.getSegmentWidth(i);
        diffY = this.getSegmentHeight(i);
        if (diffX > max + 1) {
            max = diffX;
            index = i;
        } else if (diffY > max + 1) {
            max = diffY;
            index = i;
        }
    }
    diffX = (this.lineSegments.get(index).endPoint.x
        - this.lineSegments.get(index).startPoint.x) / 2;
    diffY = (this.lineSegments.get(index).endPoint.y
        - this.lineSegments.get(index).startPoint.y) / 2;
    x = this.lineSegments.get(index).startPoint.x + diffX;
    y = this.lineSegments.get(index).startPoint.y + diffY;

    return new PMUI.util.Point(x, y);
};

/**
 * Connects two PM Figures
 * @returns {Connection}
 */
 PMFlow.prototype.connect = function (options) {
    var labelPoint;
    PMUI.draw.Connection.prototype.connect.call(this, options);
    labelPoint = this.getLabelCoordinates();

    this.label = new PMUI.draw.Label({
        message: this.getName(),
        canvas: this.canvas,
        parent: this,
        position: {
            location: "center",
            diffX: labelPoint.getX() / this.canvas.zoomFactor,
            diffY: labelPoint.getY() / this.canvas.zoomFactor

        }
    });
    this.html.appendChild(this.label.getHTML());


    this.label.attachListeners();
    this.label.setDimension(100,"auto");
    this.label.setLabelPosition(this.label.location, this.label.diffX, this.label.diffY);  
    return this;
};

PMFlow.prototype.changeFlowType = function (type) { 
    var segmentStyle, destDecorator,
    typeMap = {
        'default': {
            srcPrefix: 'mafe-default',
            destPrefix: 'mafe-sequence'
        },
        'conditional': {
            srcPrefix: 'mafe-decorator_conditional',
            destPrefix: 'mafe-decorator_default'
        },
        'sequence': {
            srcPrefix: 'mafe-sequence',
            destPrefix: 'mafe-sequence'
        }
    }, srcDecorator;

    if (type === 'association') {
        segmentStyle = "dotted";
        destDecorator = "con-none";
    } else {
        segmentStyle = "regular";
    }
    this.setSegmentStyle(segmentStyle);
    this.originalSegmentStyle = segmentStyle;

    if (type === 'association') {
        if (srcDecorator &&  this.srcDecorator) {
            this.srcDecorator
            .setDecoratorPrefix(srcDecorator);
        } else {
            this.srcDecorator
            .setDecoratorPrefix("mafe-decorator");

        }
        this.srcDecorator.paint();
    } else {
        this.srcDecorator.setDecoratorPrefix(typeMap[type].srcPrefix)
        .setDecoratorType("source")
        .paint();

        this.destDecorator.setDecoratorPrefix(typeMap[type].destPrefix)
        .setDecoratorType("target")
        .paint();
        this.disconnect()
        .connect()
        .setSegmentMoveHandlers()
        .checkAndCreateIntersectionsWithAll();
        return this;
    }


    if (destDecorator && this.srcDecorator) {
        this.destDecorator
        .setDecoratorPrefix(destDecorator);
    } else {
        this.destDecorator
        .setDecoratorPrefix("mafe-decorator");
    }
    this.srcDecorator.paint();
    this.disconnect();
    this.connect();
    return this;
};

PMFlow.prototype.saveAndDestroy = function () {
    var otherConnection,sizeIntersection,bar;
    sizeIntersection=this.intersectionWith.getSize();
    PMUI.draw.Connection.prototype.saveAndDestroy.call(this);
    bar = this.intersectionWith.asArray().slice();
    bar.reverse();
    for (i = 0; i < sizeIntersection; i += 1) {
        otherConnection = bar[i];
        otherConnection
                        .setSegmentColor(otherConnection.originalSegmentColor, false)
                        .setSegmentStyle(otherConnection.originalSegmentStyle, false)
                        .disconnect()
                        .connect();
        otherConnection.setSegmentMoveHandlers();
        otherConnection.checkAndCreateIntersectionsWithAll();
        this.canvas.triggerCreateEvent(otherConnection, []);
    }
    if (this.getFlowType() === 'DEFAULT') {
        this.getSrcPort().getParent().updateDefaultFlow("");
    }    

};


PMFlow.prototype.showPortsAndHandlers = function () {
    //this.showPorts();
    this.showMoveHandlers();
    this.showPorts();
    return this;
};

PMFlow.prototype.showPorts = function () {
    var connectHandler, connectHandler2;
    this.canvas.hideDragConnectHandlers();
    connectHandler = this.canvas.dragConnectHandlers.get(0);
    connectHandler.setDimension(15*this.canvas.getZoomFactor(), 15*this.canvas.getZoomFactor());
    connectHandler.setPosition(this.srcPort.parent.getAbsoluteX()- this.canvas.getAbsoluteX() + this.srcPort.getZoomX(), this.srcPort.parent.getAbsoluteY()- this.canvas.getAbsoluteY() +this.srcPort.getZoomY());
    connectHandler.setVisible(true);
    connectHandler.relativeShape = this.srcPort;
    connectHandler.attachListeners();


    connectHandler2 = this.canvas.dragConnectHandlers.get(1);
    connectHandler2.setDimension(15*this.canvas.getZoomFactor(), 15*this.canvas.getZoomFactor());
    connectHandler2.setPosition(this.destPort.parent.getAbsoluteX()- this.canvas.getAbsoluteX() + this.destPort.getZoomX(), this.destPort.parent.getAbsoluteY()- this.canvas.getAbsoluteY() +this.destPort.getZoomY());
    connectHandler2.setVisible(true);
    connectHandler2.relativeShape = this.destPort;
    connectHandler2.attachListeners();

    return this;
};

PMFlow.prototype.hidePortsAndHandlers = function () {
    //this.hidePorts();
    this.hideMoveHandlers();
    this.canvas.hideDragConnectHandlers();
    return this
};


PMFlow.prototype.getBpmnElementType = function () {
    var map = {
        'SEQUENCE': 'bpmn:SequenceFlow',
        'ASSOCIATION': 'bpmn:Association',
        'MESSAGE': 'bpmn:MessageFlow'
    }
    var type = map[this.flo_type] || 'bpmn:SequenceFlow';
    if (this.flo_type === 'DATAASSOCIATION' ) {
        if (this.flo_element_origin_type === 'bpmnData') {
            type = 'bpmn:DataInputAssociation';
        } else {
            type = 'bpmn:DataOutputAssociation';
        }
    }
    return type;
};


PMFlow.prototype.createWithBpmn = function(bpmnElementType) {
    var businessObject = PMDesigner.bpmnFactory.create(bpmnElementType, {id: 'flo_' + this.id, name: this.getName() ? this.getName(): ""});
    businessObject.di = PMDesigner.bpmnFactory.createDiEdge(businessObject, [], {
        id: businessObject.id + '_di'
    });
    this.businessObject = businessObject;
    //console.log(this);
};

PMFlow.prototype.updateConnectionWaypoints = function() {
    this.businessObject.di.set('waypoint', PMDesigner.bpmnFactory.createDiWaypoints(this.waypoints));
};


PMFlow.prototype.updateConnection = function(newSource, newTarget) {

    var businessObject = this.businessObject,
        children;

    if (this.flo_type === 'DATAASSOCIATION') {
        if (this.flo_element_origin_type === 'bpmnData') {

            children = newTarget.get('dataInputAssociations');
            CollectionRemove(children, businessObject);
            businessObject.sourceRef = [];
            newTarget.get('dataInputAssociations').push(businessObject);

            businessObject.sourceRef.push(newSource);
        } else {
            children = newSource.get('dataOutputAssociations');
            CollectionRemove(children, businessObject);
            businessObject.targetRef = [];
            newSource.get('dataOutputAssociations').push(businessObject);
            businessObject.targetRef = newTarget;
        }


    }  else {
        var inverseSet = businessObject.$instanceOf('bpmn:SequenceFlow');
        if (businessObject.sourceRef !== newSource) {
            if (inverseSet) {
                CollectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);

                if (newSource) {
                    newSource.get('outgoing').push(businessObject);
                }
            }

            businessObject.sourceRef = newSource;
        }
        if (businessObject.targetRef !== newTarget) {
            if (inverseSet) {
                CollectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);

                if (newTarget) {
                    newTarget.get('incoming').push(businessObject);
                }
            }

            businessObject.targetRef = newTarget;
        }

    }

    businessObject.di.set('waypoint', PMDesigner.bpmnFactory.createDiWaypoints(this.points));
};

PMFlow.prototype.updateShapeParent = function() {
    var parentShape = this.srcPort.parent.parent;
    var businessObject = this.businessObject,
        parentBusinessObject = parentShape && parentShape.businessObject,
        parentDi = parentBusinessObject && parentBusinessObject.di;

    if (this.flo_type === 'MESSAGE') {
        if (this.srcPort.parent.businessObject
            && this.destPort.parent.businessObject
            && this.srcPort.parent.businessObject.$parent.id !== this.destPort.parent.businessObject.$parent.id) {

            //console.log ('between pools');
            parentBusinessObject = _.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"});
        } else {
            if (this.srcPort.parent.type === 'PMParticipant') {
                parentBusinessObject = this.srcPort.parent && this.srcPort.parent.participantObject.$parent;
            } else if (this.srcPort.parent ){
                parentBusinessObject = this.destPort.parent && this.destPort.parent.participantObject.$parent;
            }

        }
    }
    this.updateSemanticParent(businessObject, parentBusinessObject);

    this.updateDiParent(businessObject.di, parentDi);
};


PMFlow.prototype.updateSemanticParent = function(businessObject, newParent) {

    if (businessObject.$parent === newParent) {
        return;
    }

    var children;
    if (this.flo_type !== 'DATAASSOCIATION') {

        if (this.flo_type === 'MESSAGE') {
            //HERE MESSAGE FLOW SET TO COLLABORATIONS
            if (businessObject.$parent) {
                // remove from old parent
                children = businessObject.$parent.get('messageFlows');
                CollectionRemove(children, businessObject);
            }

            if (!newParent) {
                businessObject.$parent = null;
            } else {
                children = newParent.get('messageFlows');
                children.push(businessObject);
                businessObject.$parent = newParent;
            }

        } else {
            if (businessObject.$parent) {
                // remove from old parent
                children = businessObject.$parent.get('flowElements');
                CollectionRemove(children, businessObject);
            }

            if (!newParent) {
                businessObject.$parent = null;
            } else {
                // add to new parent
                if (newParent.$type === 'bpmn:Lane') {
                    children = newParent.$parent.$parent.get('flowElements');
                } else {
                    children = newParent.get('flowElements');
                }
                children.push(businessObject);
                businessObject.$parent = newParent;
            }
        }


    }


};

PMFlow.prototype.updateDiParent = function(di, parentDi) {

    if (parentDi && !parentDi.$instanceOf('bpmndi:BPMNPlane')) {
        parentDi = parentDi.$parent;
    }

    if (di.$parent === parentDi) {
        return;
    }

    var planeElements = (parentDi || di.$parent).get('planeElement');

    if (parentDi) {
        planeElements.push(di);
        di.$parent = parentDi;
    } else {
        CollectionRemove(planeElements, di);
        di.$parent = null;
    }
};


PMFlow.prototype.createBpmn = function(bpmnElementType) {
    var newSource, newTarget;
    this.createWithBpmn(bpmnElementType);
    this.updateShapeParent();

    newSource = this.srcPort.parent && this.srcPort.parent.businessObject;
    newTarget = this.destPort.parent && this.destPort.parent.businessObject;
    if (this.srcPort.parent.type == 'PMParticipant') {
        newSource = this.srcPort.parent && this.srcPort.parent.participantObject;
    }
    if (this.destPort.parent.type == 'PMParticipant') {
        newTarget = this.destPort.parent && this.destPort.parent.participantObject;
    }
    this.updateConnection(newSource, newTarget);
    //PMDesigner.moddle.toXML(PMDesigner.businessObject, function(err, xmlStrUpdated) {
    //    console.log(xmlStrUpdated  );
        // xmlStrUpdated contains new id and the added process

    //});
};
PMFlow.prototype.removeBpmn = function() {
var parentShape,
    businessObject,
    newSource,
    newTarget,
    children,
    parentBusinessObject,
    parentDi;
    businessObject = this.businessObject;

    this.updateSemanticParent(businessObject);
    this.updateDiParent(businessObject.di);

    if (this.flo_type !== 'DATAASSOCIATION') {
        parentShape = this.parent;
        parentBusinessObject = parentShape && parentShape.businessObject;
        parentDi = parentBusinessObject && parentBusinessObject.di;

        CollectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);
        CollectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);

    } else {

        newSource = this.srcPort.parent && this.srcPort.parent.businessObject,
        newTarget = this.destPort.parent && this.destPort.parent.businessObject;

        if (this.flo_element_origin_type === 'bpmnData') {
            children = newTarget.get('dataInputAssociations');
            CollectionRemove(children, businessObject);

        } else {
            children = newSource.get('dataOutputAssociations');
            CollectionRemove(children, businessObject);

        }
    }

};

PMFlow.prototype.updateBpmn = function() {
    var newSource = this.srcPort.parent && this.srcPort.parent.businessObject,
        newTarget = this.destPort.parent && this.destPort.parent.businessObject;
    this.updateConnection(newSource, newTarget);
};

PMFlow.prototype.setBPPMName = function (name) {
    if (this.businessObject || this.participantObject ) {
        this.businessObject.name = name;
    }
};
/**
* @class PMConnectionDropBehavior
* Extends the functionality to handle creation of connections
*
* @constructor
* Creates a new instance of the object
*/
var PMConnectionDropBehavior = function (selectors) {
    PMUI.behavior.ConnectionDropBehavior.call(this, selectors);
};
PMConnectionDropBehavior.prototype = new PMUI.behavior.ConnectionDropBehavior();
/**
* Defines the object type
* @type {String}
*/
PMConnectionDropBehavior.prototype.type = "PMConnectionDropBehavior";

/**
 * Defines a Map of the basic Rules
 * @type {Object}
 */
PMConnectionDropBehavior.prototype.basicRules = {
    PMEvent : {
        PMEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMActivity : {
            connection : 'regular',
            type: 'SEQUENCE'
        }
    },
    PMActivity: {
        PMActivity : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMArtifact : {
            connection : 'dotted',
            destDecorator: 'con_none',
            type: 'ASSOCIATION'
        },
        PMIntermediateEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMEndEvent: {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMGateway : {
            connection : 'regular',
            type: 'SEQUENCE'
        }
    },
    PMStartEvent : {
        PMActivity : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMIntermediateEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMGateway : {
            connection : 'regular',
            type: 'SEQUENCE'
        }
    },
    PMIntermediateEvent : {
        PMActivity : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMIntermediateEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMEndEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMGateway : {
            connection : 'regular',
            type: 'SEQUENCE'
        }
    },
    PMBoundaryEvent : {
        PMActivity : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMIntermediateEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMEndEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMGateway : {
            connection : 'regular',
            type: 'SEQUENCE'
        }
    },
    PMGateway : {
        PMActivity : {
            connection : 'regular',
            type: 'SEQUENCE'
        },
        PMIntermediateEvent : {
            connection : 'regular',
            type: 'SEQUENCE'
        }
    },
    PMArtifact: {
        PMActivity: {
            connection : 'dotted',
            destDecorator: 'con_none',
            type: 'ASSOCIATION'
        }
    }
};

/**
 * Defines a Map of the init Rules
 * @type {Object}
 */

PMConnectionDropBehavior.prototype.initRules = {
    PMCanvas: {
        PMCanvas: {
            name: 'PMCanvas to PMCanvas',
            rules: PMConnectionDropBehavior.prototype.basicRules
        }
    },
    PMActivity: {
        PMCanvas: {
            name: 'PMActivity to PMCanvas',
            rules: PMConnectionDropBehavior.prototype.basicRules
        }
    }
};

/**
 * Handle the hook functionality when a drop start
 *  @param shape
 */
PMConnectionDropBehavior.prototype.dropStartHook = function (shape, e, ui) {
    shape.srcDecorator = null;
    shape.destDecorator = null;
    var draggableId = ui.draggable.attr("id"),
        source  = shape.canvas.customShapes.find('id', draggableId),
        prop;
    if (source) {
        prop = this.validate(source, shape);
        if (prop) {
            shape.setConnectionType({
                type: prop.type,
                segmentStyle: prop.connection,
                srcDecorator: prop.srcDecorator,
                destDecorator: prop.destDecorator
            });

        } else {
            // verif if port is changed
            if (typeof source !== 'undefined') {
                if (!(ui.helper && ui.helper.attr('id') === "drag-helper")) {
                    return false;
                }
                //showMessage('Invalid Connection');
                shape.setConnectionType('none');
            }
        }
    }

    return true;
};

/**
 * Connection validations method
 * return an object if is valid otherwise return false
 * @param {Connection} source
 * @param {Connection} target
 */
PMConnectionDropBehavior.prototype.validate = function (source, target) {
    var sType,
        tType,
        rules,
        initRules,
        initRulesName,
        BPMNAuxMap = {
            PMEvent : {
                'START' : 'PMStartEvent',
                'END': 'PMEndEvent',
                'INTERMEDIATE': 'PMIntermediateEvent',
                'BOUNDARY': 'PMBoundaryEvent'
            },
            bpmnArtifact : {
                'TEXTANNOTATION': 'bpmnAnnotation'
            }
        };

    if (source && target) {
        if (source.getID() === target.getID()) {
            return false;
        }

        if (this.initRules[source.getParent().getType()]
                && this.initRules[source.getParent().getType()][target.getParent().getType()]) {


            initRules = this.initRules[source.getParent().getType()][target.getParent().getType()].rules;
            initRulesName = this.initRules[source.getParent().getType()][target.getParent().getType()].name;
            // get the types
            sType = source.getType();
            tType = target.getType();
            //Custimize all PM events
            if (sType === 'PMEvent') {
                if (BPMNAuxMap[sType] && BPMNAuxMap[sType][source.getEventType()]) {
                    sType = BPMNAuxMap[sType][source.getEventType()];
                }
            }
            if (tType === 'PMEvent') {
                if (BPMNAuxMap[tType] && BPMNAuxMap[tType][target.getEventType()]) {
                    tType = BPMNAuxMap[tType][target.getEventType()];
                }
            }

            if (initRules[sType] && initRules[sType][tType]) {
                rules = initRules[sType][tType];
            } else {
                rules = false;
            }
            if (initRules) {
                switch (initRulesName) {
                case 'bpmnPool to bpmnPool':
                    if (source.getParent().getID() !== target.getParent().getID()) {
                        rules = false;
                    }
                    break;
                case 'bpmnLane to bpmnLane':
                    if (source.getFirstPool(source.parent).getID()
                            !== target.getFirstPool(target.parent).getID()) {
                        if (this.extraRules[sType]
                                && this.extraRules[sType][tType]) {
                            rules = this.extraRules[sType][tType];
                        } else {
                            rules = false;
                        }
                    }
                    break;
                case 'bpmnActivity to bpmnLane':
                    if (this.basicRules[sType]
                            && this.basicRules[sType][tType]) {
                        rules = this.basicRules[sType][tType];
                    } else {
                        rules = false;
                    }
                    break;
                default:
                    break;
                }
            } else {
                rules = false;
            }

        } else {
            // get the types
            sType = source.getType();
            tType = target.getType();
            //
            if (sType === 'PMEvent') {
                if (BPMNAuxMap[sType] && BPMNAuxMap[sType][source.getEventType()]) {
                    sType = BPMNAuxMap[sType][source.getEventType()];
                }
            }
            if (tType === 'PMEvent') {
                if (BPMNAuxMap[tType] && BPMNAuxMap[tType][target.getEventType()]) {
                    tType = BPMNAuxMap[tType][target.getEventType()];
                }
            }
            if (this.advancedRules[sType] && this.advancedRules[sType][tType]) {
                rules = this.advancedRules[sType][tType];
            } else {
                rules = false;
            }
        }
        return rules;
    }
};
PMConnectionDropBehavior.prototype.onDragEnter = function (customShape) {
    return function (e, ui) {
        var shapeRelative, i;
        if (customShape.extendedType !== "PARTICIPANT") {
            if (ui.helper && ui.helper.hasClass("dragConnectHandler")) {
                if (customShape.extendedType !== "TEXT_ANNOTATION") {
                shapeRelative = customShape.canvas.dragConnectHandlers.get(0).relativeShape;
                    if (shapeRelative.id !== customShape.id) {
                        //for (i = 0; i < customShape.canvas.dropConnectHandlers.getSize(); i += 1) {
                        for (i = 0; i < 4; i += 1) {
                            customShape.showConnectDropHelper(i, customShape);
                        }
                    }
                } else {
                    if (customShape.extendedType !== "H_LABEL" && customShape.extendedType !== "V_LABEL") {
                        shapeRelative = customShape.canvas.dragConnectHandlers.get(3).relativeShape;
                        if (shapeRelative.id !== customShape.id) {
                            customShape.canvas.hideDropConnectHandlers();
                            customShape.showConnectDropHelper(3, customShape);
                        }
                    }
                }
            }
        } else {
            shapeRelative = customShape.canvas.dragConnectHandlers.get(0).relativeShape;
                if (shapeRelative.id !== customShape.id) {
                    if (ui.helper && ui.helper.hasClass("dragConnectHandler")) {
                    //for (i = 0; i < customShape.canvas.dropConnectHandlers.getSize(); i += 1) {
                        for (i = 0; i < 10; i += 1) {
                           //shape.showConnectDragHelpers(i,shape);
                           connectHandler = customShape.canvas.dropConnectHandlers.get(i);
                           connectHandler.setDimension(18*customShape.canvas.getZoomFactor(),18*customShape.canvas.getZoomFactor());
                           //connectHandler.setPosition(customShape.getZoomX()+customShape.xMidPoints[i] - connectHandler.width/2 - 1, customShape.getZoomY()+customShape.yMidPoints[i] - connectHandler.height/2 - 1);
                            connectHandler.setPosition(customShape.getZoomX()+ i*customShape.getZoomWidth()/10 , customShape.getZoomY()-connectHandler.height/2 -1);
                           connectHandler.relativeShape = customShape;
                           connectHandler.attachDrop();
                           //connectHandler.paint();
                           connectHandler.setVisible(true);
                       }
                       
                         for (i = 0; i < 10; i += 1) {
                           //shape.showConnectDragHelpers(i,shape);
                           connectHandler = customShape.canvas.dropConnectHandlers.get(i+10);
                           connectHandler.setDimension(18*customShape.canvas.getZoomFactor(),18*customShape.canvas.getZoomFactor());
                           //connectHandler.setPosition(customShape.getZoomX()+customShape.xMidPoints[i] - connectHandler.width/2 - 1, customShape.getZoomY()+customShape.yMidPoints[i] - connectHandler.height/2 - 1);
                           connectHandler.setPosition(customShape.getZoomX()+ i*customShape.getZoomWidth()/10 , customShape.getZoomY()+ customShape.getZoomHeight()-connectHandler.height/2 -1);
                           connectHandler.relativeShape = customShape;
                           connectHandler.attachDrop();
                           //connectHandler.paint();
                           connectHandler.setVisible(true);
                       }
                    }
                }
        }
    }
};
/**
* Handle the functionality when a shape is dropped
* @param shape
*/
PMConnectionDropBehavior.prototype.onDrop = function (shape) {
    var that = this;
    return function (e, ui) {
        return false;
        var canvas  = shape.getCanvas(),
            id = ui.draggable.attr('id'),
            x,
            y,
            currLeft,
            currTop,
            startPoint,
            sourceShape,
            sourcePort,
            endPort,
            endPortXCoord,
            endPortYCoord,
            connection,
            currentConnection = canvas.currentConnection,
            srcPort,
            dstPort,
            port,
            prop,
            success = false,
            command,
            aux,
            segmentMap;
        shape.entered = false;
        if (!shape.drop.dropStartHook(shape, e, ui)) {
            return false;
        }
        if (shape.getConnectionType() === "none") {
            return true;
        }

        if (currentConnection) {
            srcPort = currentConnection.srcPort;
            dstPort = currentConnection.destPort;
            if (srcPort.id === id) {
                port = srcPort;
            } else if (dstPort.id === id) {
                port = dstPort;
            } else {
                port = null;
            }
        }
        if (ui.helper && ui.helper.attr('id') === "drag-helper") {

            //if its the helper then we need to create two ports and draw a
            // connection
            //we get the points and the corresponding shapes involved
            startPoint = shape.canvas.connectionSegment.startPoint;
            sourceShape = shape.canvas.connectionSegment.pointsTo;
            //determine the points where the helper was created
            if (sourceShape.parent && sourceShape.parent.id === shape.id) {
                return true;
            }
            sourceShape.setPosition(sourceShape.oldX, sourceShape.oldY);

            //startPoint.x -= sourceShape.absoluteX;
            //startPoint.y -= sourceShape.absoluteY;
            startPoint.x = startPoint.portX;
            startPoint.y = startPoint.portY;
            //create the ports
            sourcePort = new PMUI.draw.Port({
                width: 10,
                height: 10
            });
            endPort = new PMUI.draw.Port({
                width: 10,
                height: 10
            });

            //determine the position where the helper was dropped
            endPortXCoord = ui.offset.left - shape.canvas.getX() -
                shape.getAbsoluteX() + shape.canvas.getLeftScroll();
            endPortYCoord = ui.offset.top - shape.canvas.getY() -
                shape.getAbsoluteY() + shape.canvas.getTopScroll();
            // add ports to the corresponding shapes
            // addPort() determines the position of the ports
            sourceShape.addPort(sourcePort, startPoint.x, startPoint.y);
            shape.addPort(endPort, endPortXCoord, endPortYCoord,
                false, sourcePort);

            //add ports to the canvas array for regularShapes
            //shape.canvas.regularShapes.insert(sourcePort).insert(endPort);
            //create the connection
            connection = new PMFlow({
                srcPort : sourcePort,
                destPort: endPort,
                segmentColor: new PMUI.util.Color(0, 0, 0),
                name: "",
                canvas : shape.canvas,
                segmentStyle: shape.connectionType.segmentStyle,
                flo_type: shape.connectionType.type
            });

            connection.setSrcDecorator(new PMUI.draw.ConnectionDecorator({
                width: 1,
                height: 1,
                canvas: canvas,
                decoratorPrefix: (typeof shape.connectionType.srcDecorator !== 'undefined'
                    && shape.connectionType.srcDecorator !== null) ?
                        shape.connectionType.srcDecorator : "mafe-decorator",
                decoratorType: "source",
                parent: connection
            }));

            connection.setDestDecorator(new PMUI.draw.ConnectionDecorator({
                width: 1,
                height: 1,
                canvas: canvas,
                decoratorPrefix: (typeof shape.connectionType.destDecorator !== 'undefined'
                    && shape.connectionType.destDecorator !== null) ?
                        shape.connectionType.destDecorator : "mafe-decorator",
                decoratorType: "target",
                        style : {
                            cssClasses : [
                                "mafe-connection-decoration-target"
                            ]
                        },
                parent: connection
            }));

            /*directionDec = connection.getDestPort().getDirection();
            if (directionDec) {
                if (directionDec === 0 || directionDec === 2) {
                    //For TOP and BOTTOM
                    connection.destDecorator.setX(ui.offset.left);
                } else if(directionDec === 1 || directionDec === 3){
                    //For RIGHT and LEFT
                    connection.destDecorator.setY(ui.offset.top);
                }
            }*/
            connection.canvas.commandStack.add(new PMUI.command.CommandConnect(connection));

            //connect the two ports
            connection.connect();
            connection.setSegmentMoveHandlers();

            //add the connection to the canvas, that means insert its html to
            // the DOM and adding it to the connections array
            canvas.addConnection(connection);

            // Filling PMFlow fields
            connection.setTargetShape(endPort.parent);
            connection.setOriginShape(sourcePort.parent);
            connection.savePoints();

            // now that the connection was drawn try to create the intersections
            connection.checkAndCreateIntersectionsWithAll();

            //attaching port listeners
            sourcePort.attachListeners(sourcePort);
            endPort.attachListeners(endPort);

            // finally trigger createEvent
            canvas.triggerCreateEvent(connection, []);
        } else if (port) {
            connection = port.getConnection();
            if (connection.srcPort.getID() === port.getID()) {
                prop = PMConnectionDropBehavior.prototype.validate(
                    shape,
                    connection.destPort.getParent()
                );
            } else {
                prop = PMConnectionDropBehavior.prototype.validate(
                    connection.srcPort.getParent(),
                    shape
                );
            }
            
            if (prop) {
                port.setOldParent(port.getParent());
                port.setOldX(port.getX());
                port.setOldY(port.getY());

                x = ui.position.left;
                y = ui.position.top;
                port.setPosition(x, y);
                shape.dragging = false;
                if (shape.getID() !== port.parent.getID()) {
                    port.parent.removePort(port);
                    currLeft = ui.offset.left - canvas.getX() -
                        shape.absoluteX + shape.canvas.getLeftScroll();
                    currTop = ui.offset.top - canvas.getY() - shape.absoluteY +
                        shape.canvas.getTopScroll();
                    shape.addPort(port, currLeft, currTop, true);
                    canvas.regularShapes.insert(port);
                } else {
                    shape.definePortPosition(port, port.getPoint(true));
                }

                // LOGIC: when portChangeEvent is triggered it gathers the state
                // of the connection but since at this point there's only a segment
                // let's paint the connection, gather the state and then disconnect
                // it (the connection is later repainted on, I don't know how)

                aux = {
                    before: {
                        condition: connection.flo_condition,
                        type: connection.flo_type,
                        segmentStyle: connection.segmentStyle,
                        srcDecorator: connection.srcDecorator.getDecoratorPrefix(),
                        destDecorator: connection.destDecorator.getDecoratorPrefix()
                    },
                    after: {
                        type : prop.type,
                        segmentStyle: prop.connection,
                        srcDecorator: prop.srcDecorator,
                        destDecorator: prop.destDecorator
                    }
                };
                connection.connect();
                canvas.triggerPortChangeEvent(port);
                command = new PMCommandReconnect(port, aux);
                //command.execute();
                canvas.commandStack.add(command);
                canvas.hideDropConnectHandlers();

            } else {
                return false;
            }
        }
        return false;
    };
};
var ToolbarPanel = function (options) {
	this.tooltip = null;
    ToolbarPanel.prototype.init.call(this, options);
};

ToolbarPanel.prototype = new PMUI.core.Panel();
ToolbarPanel.prototype.type = "ToolbarPanel";

ToolbarPanel.prototype.init = function (options) {
    var defaults = {
        buttons: [],
        tooltip: "",
        width: "96%"
    };
    jQuery.extend(true, defaults, options);
    PMUI.core.Panel.call(this, defaults);
    this.buttons = [];
    this.setTooltip(defaults.tooltip);
    this.setButtons(defaults.buttons);
};
ToolbarPanel.prototype.setTooltip = function (message) {
    if (typeof message === "string") {
        this.tooltip = message;
    }

    return this;
};

ToolbarPanel.prototype.setButtons = function (buttons) {
    var that = this; 
    jQuery.each(buttons, function(index, button){
        that.buttons.push(button);
    });
    return this;
};
ToolbarPanel.prototype.createHTMLButton = function (button) {
    var i,
        li = PMUI.createHTMLElement('li'),
        a = PMUI.createHTMLElement('a');

    li.id = button.selector;
    li.className = "mafe-toolbarpanel-btn";
    a.title = "";
    a.style.cursor = "move";
    jQuery(a).tooltip({ content: button.tooltip,
                        tooltipClass: "mafe-action-tooltip",
                        position: {
                            my: "left top", at: "left bottom", collision: "flipfit"
                        }
                     });

    for (i = 0; i < button.className.length; i+=1) {
        jQuery(a).addClass(button.className[i]);
    }
    
    li.appendChild(a);
    return li;
};

ToolbarPanel.prototype.createHTML = function () {
	var that = this, ul;
    PMUI.core.Panel.prototype.setElementTag.call(this, "ul");
    PMUI.core.Panel.prototype.createHTML.call(this);
    this.html.style.overflow = "visible";
	jQuery.each(this.buttons, function(i, button){
		var html = that.createHTMLButton(button);
        that.html.appendChild(html);
		button.html = html;
	});

	return this.html;
};

ToolbarPanel.prototype.activate = function () {
    var that = this;
    jQuery.each(this.buttons, function(i, b) {

        jQuery(b.html).draggable({ 
            opacity: 0.7, 
            helper: "clone", 
            cursor: "hand"
        });
    });
    return this;
};
ToolbarPanel.prototype.getSelectors = function () {
    var selectors = [], that = this;
    jQuery.each(this.buttons, function(i, button){
        selectors.push ('#' + button.selector);
    });
    return selectors;
};


var PMProject;
PMProject = function(options) {
    this.diagrams = new PMUI.util.ArrayList();
    this.keys = null;
    this.waitingResponse = false;
    this.identifiers = {};

    this.dirtyElements = [
        {
            laneset: {},
            lanes: {},
            activities: {},
            events:{},
            gateways:{},
            flows:{},
            artifacts: {},
            lines: {},
            data: {},
            participants: {}
        },
        {
            laneset: {},
            lanes: {},
            activities: {},
            events:{},
            gateways:{},
            flows:{},
            artifacts: {},
            lines: {},
            data: {},
            participants: {}
        }
    ];
    PMProject.prototype.init.call(this, options);

};

PMProject.prototype.init = function (options) {
    var defaults = {
        projectId: "",
        projectName: "",
        description: "",
        remoteProxy: null,
        localProxy: null,
        keys: {
            access_token: null,
            expires_in: null,
            token_type: null,
            scope: null,
            refresh_token: null,
            client_id: null,
            client_secret: null
        },
        listeners: {
            create : function(){},
            remove : function(){},
            update : function(){},
            success: function(){},
            failure: function(){}
        }
    };
    jQuery.extend(true, defaults, options);

    this.setKeysClient(defaults.keys)
        .setID(defaults.id)
        .setTokens(defaults.keys)
        .setListeners(defaults.listeners);
    this.remoteProxy = new PMUI.proxy.RestProxy();
};

PMProject.prototype.setID = function (id) {
    this.id = id;
    return this;
};

PMProject.prototype.setProjectId = function (id) {
    if (typeof id === "string") {
        this.projectId = id;
    }
    return this;
};

PMProject.prototype.setProjectName = function (name) {
    if (typeof name === "string") {
        this.projectName = name;
        //jQuery(".navBar div").text(name);
        jQuery(".navBar div").remove();
        if ( $( ".navBar h2" ).length > 0) {
            $( ".navBar h2" ).text(name);
        } else {
            jQuery(".navBar").append( "<h2>"+ name +"</h2>" );
        }

    }
    return this;
};

PMProject.prototype.setDescription = function (description) {
    this.description = description;
    return this;
};

PMProject.prototype.setKeysClient = function (keys) {
    if (typeof keys === "object") {
        this.keys = keys;
    }
    return this;
};

PMProject.prototype.setListeners = function (listeners) {
    if (typeof listeners === "object") {
        this.listeners = listeners;
    }
    return this;
};

PMProject.prototype.getKeysClient = function () {
    //var token = Base64.decode(this.keys);
    var keys = this.keys;
    return {
        access_token: keys.access_token,
        expires_in: keys.expires_in,
        token_type: keys.token_type,
        scope: keys.scope,
        refresh_token: keys.refresh_token,
        client_id: keys.client_id,
        client_secret: keys.client_secret
    };
};
PMProject.prototype.buildCanvas = function (selectors, options) {
    var canvas = new PMCanvas({
        id: PMUI.generateUniqueId(),
        project: PMDesigner.project,
        absoluteX: jQuery("#div-layout-canvas").offset().left,
        absoluteY: jQuery("#div-layout-canvas").offset().top,
        //left: jQuery("#div-layout-canvas").offset().left,
        //top: jQuery("#div-layout-canvas").offset().top,
        //left:jQuery("#pm_designer").offset().left,
        //top:jQuery("#pm_designer").offset().top,
        width: 4000,
        height: 4000,
        style: {
            cssProperties: {
                overflow: "hidden"
            }
        },
        drop: {
            type: 'container',
            selectors: selectors
        },
        //container: "regularcontainer",
        container: "pmcanvas",
        //readOnly:  true,
        readOnly: prj_readonly === 'true' ? true : false,
        hasClickEvent : true,
        copyAndPasteReferences: {
            PMEvent: PMEvent,
            PMGateway: PMGateway,
            PMActivity: PMActivity,
            PMArtifact: PMArtifact,
            PMFlow: PMFlow
        }
    });
    // diagram = canvas
    jQuery("#div-layout-canvas").append(canvas.getHTML());

    canvas.setShapeFactory(PMDesigner.shapeFactory);
    canvas.attachListeners();
    canvas.createConnectHandlers('','');
    var menuCanvas = PMDesigner.getMenuFactory("CANVAS");
    canvas.setContextMenu(menuCanvas);

    PMDesigner.canvasList.addOption(
        {
            label: options.name,
            value: canvas.getID()
        });


    this.diagrams.insert(canvas);
    return canvas;
};

PMProject.prototype.getKeysClient = function () {
    //var token = Base64.decode(this.keys);
    var keys = this.keys;
    return {
        access_token: keys.access_token,
        expires_in: keys.expires_in,
        token_type: keys.token_type,
        scope: keys.scope,
        refresh_token: keys.refresh_token,
        client_id: keys.client_id,
        client_secret: keys.client_secret
    };
};

PMProject.prototype.load = function () {
    var keys = this.getKeysClient(),
        that = this;
    this.remoteProxy.setDataType("json");
    this.remoteProxy.setAuthorizationType('oauth2',keys);

    this.remoteProxy.get({
        url: that.remoteProxy.url,
        authorizationOAuth: true,
        success: function (xhr, response) {
            that.dirty = false;
            that.loadProject(response);
        },
        failure: function (xhr, response) {
            that.listeners.failure(that, xhr, response);
        }
    });

    return this;
};

PMProject.prototype.loadProject = function (project) {
    var that = this,
        i,
        j,
        moddle,
        imported = false,     // imported flag
        sidebarCanvas = [];
       if (project) {
        this.loadingProcess = true;
        this.setProjectId(project.prj_uid);
        this.setProjectName(project.prj_name);
        this.setDescription(project.prj_description);
           //var xml2;



        if (imported) {
            // import ----------------------------
            //jQuery.get('/resources/miwg-test-suite/A.1.0.bpmn', function(data) {
            //jQuery.get('/resources/miwg-test-suite/A.2.0.bpmn', function(data) {
            //jQuery.get('/resources/miwg-test-suite/C.2.0.bpmn', function(data) {
            //
            //    moddle.fromXML(data, function(err, definitions) {
            //        PMDesigner.businessObject = definitions;
            //        var imp = new importBpmnDiagram(definitions);
            //        PMUI.getActiveCanvas().buildingDiagram = false;
            //        //console.log('import');
            //        //console.log(definitions);
            //
            //        //moddle.toXML(definitions, function(err, xmlStrUpdated) {
            //        //    xml2 = xmlStrUpdated;
            //        //    // xmlStrUpdated contains new id and the added process
            //        //});
            //    });
            //});
            //---------------------------------------------------
        } else {
            for (i = 0; i < project.diagrams.length; i += 1) {
                diagram = project.diagrams[i];
                for (j = 0; j < PMDesigner.sidebar.length; j += 1) {
                    sidebarCanvas = sidebarCanvas.concat(PMDesigner.sidebar[j].getSelectors());
                    jQuery(".bpmn_shapes").append(PMDesigner.sidebar[j].getHTML());
                }
                sidebarCanvas.splice(15, 1);  //to remove lane selector
                // sidebarCanvas = sidebarCanvas + ',.mafe-event-start';
                sidebarCanvas = sidebarCanvas.concat('.mafe-event-start');
                sidebarCanvas = sidebarCanvas.concat('.pmui-pmactivity');
                sidebarCanvas = sidebarCanvas.concat('.mafe-event-end');


                var canvas =  PMDesigner.project.buildCanvas(sidebarCanvas, {name: 'Main'});
                PMUI.setActiveCanvas(canvas);
                jQuery("#p-center-layout").scroll(canvas.onScroll(canvas, jQuery("#p-center-layout")));


                var xmlStr =
                    '<?xml version="1.0" encoding="UTF-8"?>' +
                    '<bpmn2:definitions xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" id="empty-definitions" targetNamespace="http://bpmn.io/schema/bpmn">' +
                    '</bpmn2:definitions>';

                PMDesigner.moddle.fromXML(xmlStr, function(err, definitions) {
                    PMDesigner.businessObject = definitions;
                    var bpmnProcess =  PMDesigner.moddle.create('bpmn:Process', { id:  'pmui-' + PMUI.generateUniqueId() });
                    PMDesigner.businessObject.get('rootElements').push(bpmnProcess);
                    //console.log(PMDesigner.businessObject);

                    PMDesigner.mainProcess = bpmnProcess;
                    //PMDesigner.moddle.toXML(PMDesigner.businessObject, function(err, xmlStrUpdated) {
                    //    // xmlStrUpdated contains new id and the added project
                    //    //console.log(xmlStrUpdated);
                    //});
                    //diagram = project.diagrams[i];
                    canvas.buildDiagram(diagram);
                    //console.log(diagram);
                });

                this.loadingProcess = false;
                this.loaded = true;

            }
        }

    }

    this.setDirty(false);
};

PMProject.prototype.importDiagram = function(data) {
    //jQuery.get('/resources/miwg-test-suite/C.2.0.bpmn', function(data) {

    PMDesigner.moddle.fromXML(data, function(err, definitions) {
            PMDesigner.businessObject = definitions;
            var imp = new importBpmnDiagram(definitions);
            PMUI.getActiveCanvas().buildingDiagram = false;
            //console.log('import');
            //console.log(definitions);

            //moddle.toXML(definitions, function(err, xmlStrUpdated) {
            //    xml2 = xmlStrUpdated;
            //    // xmlStrUpdated contains new id and the added process
            //});
        });
    //});
}

/**
 * Represents a flag if the project was saved or not
 */
PMProject.prototype.isDirty = function () {
    return this.dirty;
};
PMProject.prototype.save = function (options) {
    var keys = this.getKeysClient(),
        that = this;
    if (this.isDirty()) {
        this.remoteProxy.setDataType("json");
        this.remoteProxy.setAuthorizationType('oauth2',keys);

        this.remoteProxy.update({
            url: that.remoteProxy.url,
            authorizationOAuth: true,
            data: that.getDirtyObject(),
            success: function (xhr, response) {
                that.listeners.success(that, xhr, response);
            },
            failure: function (xhr, response) {
                that.listeners.failure(that, xhr, response);
            }
        });
    }
    return this;
};
PMProject.prototype.getDirtyObject = function () {
    var that = this, diaArray = [], shape, i, diagram;

    for (i = 0; i < this.diagrams.getSize(); i += 1) {
        diagram = this.diagrams.get(i);
        shape =this.getDataObject(diagram);
        diaArray.push({
            dia_uid: that.diagramId || PMUI.generateUniqueId(),
            pro_uid: that.id,
            laneset: shape.laneset,
            lanes: shape.lanes,
            activities: shape.activities,
            events: shape.events,
            gateways: shape.gateways,
            flows: shape.flows,
            artifacts: shape.artifacts,
            data: shape.data,
            participants: shape.participants
        });
    }

    return {
        prj_uid: that.id,
        prj_name: that.projectName,
        prj_description: that.description,
        diagrams: diaArray
    };
};

PMProject.prototype.getDataObject = function (canvas) {
    var object, i, elements, shapes;
    //elements = this.canvas.items.asArray();
    elements = canvas.items.asArray();

    shapes = {
        activities: [],
        gateways: [],
        events: [],
        flows: [],
        artifacts: [],
        laneset: [],
        lanes: [],
        data: [],
        participants: [],
        pools: []
    };
    //if (this.canvas.items.getSize() > 0) {
    if (canvas.items.getSize() > 0) {
        for (i = 0; i < elements.length; i+=1) {
            if (typeof elements[i].relatedObject.getDataObject === "undefined"){
                object = elements[i].relatedObject;
            } else {
                object = elements[i].relatedObject.getDataObject();
            }
            switch(elements[i].type) {
                case "PMActivity":
                    shapes.activities.push(object);
                    break;
                case "PMGateway":
                    shapes.gateways.push(object);
                    break;
                case "PMEvent":
                    shapes.events.push(object);
                    break;
                case "PMFlow":
                case "Connection":
                    shapes.flows.push(object);
                    break;
                case "PMArtifact":
                    shapes.artifacts.push(object);
                    break;
                case "PMData":
                    shapes.data.push(object);
                    break;
                case "PMParticipant":
                    shapes.participants.push(object);
                    break;
                case "PMPool":
                    shapes.laneset.push(object);
                    break;
                case "PMLane":
                    shapes.lanes.push(object);
                    break;
            }
        }
    }
    return shapes;
};
PMProject.prototype.setDirty = function (dirty) {
    if (typeof dirty === "boolean") {
        this.dirty = dirty;
    }
    return this;
};

PMProject.prototype.addElement = function (element) {
    var object,
        pk_name,
        list,
        i,
        pasteElement,
        elementUndo,
        sh,
        contDivergent = 0,
        contConvergent = 0;


    if (element.relatedElements.length > 0) {
        // for (i = 0; i < element.relatedElements.length; i += 1) {
        for (i = element.relatedElements.length -1; i >= 0; i -= 1) {
            pasteElement = element.relatedElements[i];
            list = this.getUpdateList(pasteElement.type);
            if (list === undefined) {
                return;
            }

            list[pasteElement.id] = object;
            elementUndo = {
                id: pasteElement.id,
                relatedElements: [],
                relatedObject: pasteElement,
                type: pasteElement.type || pasteElement.extendedType
            };
            //this.canvas.items.insert(elementUndo);
            PMUI.getActiveCanvas().items.insert(elementUndo);
            if (!(pasteElement instanceof PMUI.draw.MultipleSelectionContainer)
                && !(pasteElement instanceof PMLine)
                && !(pasteElement instanceof PMLabel)) {
                pasteElement.createBpmn(pasteElement.getBpmnElementType());
            }

            //object = pasteElement.getDataObject();
        }
    } else {
        switch(element.type) {
            case "Connection":
                pk_name = this.formatProperty(element.type, 'uid');
                list = this.getUpdateList(element.type);
                element.relatedObject[pk_name] = element.id;

                if (typeof element.relatedObject.getDataObject === "undefined"){
                    object = element.relatedObject;
                } else {
                    //object = element.relatedObject.getDataObject();
                }
                list[element.id] = object;

                break;
            default:
                pk_name = this.formatProperty(element.type, 'uid');
                list = this.getUpdateList(element.type);
                element.relatedObject[pk_name] = element.id;
                //object = element.relatedObject.getDataObject();
                list[element.id] = object;
                break;
        }
        //this.canvas.items.insert(element);
        PMUI.getActiveCanvas().items.insert(element);

        var shape = element.relatedObject;
        if (!(shape instanceof PMUI.draw.MultipleSelectionContainer)
            && !(shape instanceof PMLine)
            && !(shape instanceof PMLabel)) {
            shape.createBpmn(shape.getBpmnElementType());
        }
    }
    this.dirty = true;

    //Call to Create callBack
    this.listeners.create(this, element);

};


PMProject.prototype.updateElement = function (updateElement) {
    var element,
        i,
        shape,
        object,
        list,
        item;
    for (i = 0; i < updateElement.length; i += 1) {
        element = updateElement[i];
        shape = element.relatedObject;

        object = this.formatObject(element);
        list = this.getUpdateList(element.type);

        if (list[element.id]) {
            jQuery.extend(true, list[element.id], object);
            if (element.type === 'Connection') {
                list[element.id].flo_state = object.flo_state;
                item = PMUI.getActiveCanvas().items.find("id",element.id);
                item.relatedObject.flo_state = object.flo_state;
            }
        } else {
            list[element.id] = object;
        }
        if (shape) {
            if(shape instanceof PMUI.draw.Port) {
                shape.connection.updateBpmn();
            } else {
                if (!(shape instanceof PMUI.draw.MultipleSelectionContainer)
                    && !(shape instanceof PMLine)
                    && !(shape instanceof PMLabel)) {
                    shape.updateBpmn();
                    //if (element.atachedDiagram) {
                    //    console.log('update diagram');
                    //    //this.removeAttachedDiagram(element);
                    //}
                }

            }
        }

    }
    this.dirty = true;

    //Call to Update callBack
    this.listeners.update(this, updateElement);
};



PMProject.prototype.removeElement = function (updateElement) {
    var object,
        dirtyEmptyCounter,
        element,
        i,
        pk_name,
        list,
        emptyObject = {},
        currentItem;

    for (i = 0; i < updateElement.length; i += 1) {
        element = updateElement[i];
        //Removig from canvas.item
        currentItem = PMUI.getActiveCanvas().items.find("id", updateElement[i].id);
        PMUI.getActiveCanvas().items.remove(currentItem);

        list = this.getUpdateList(element.type);
        if (list) {
            pk_name = this.formatProperty(element.type, 'uid');
            if (list[element.id]) {
                delete list[element.id];
            } else {
                pk_name = this.formatProperty(element.type, 'uid');
                object = {};
                object[pk_name] = element.id;
                list[element.id] = object;
            }
        }
        // to remove BpmnModdle in de exported xml
        if (!(element instanceof PMUI.draw.MultipleSelectionContainer)
            && !(element instanceof PMLine)
            && !(element instanceof PMLabel)) {
            element.removeBpmn();
            if (element.atachedDiagram) {
                //console.log('remove diagram');
                this.removeAttachedDiagram(element);
            }
        }


    }

    if (!this.isWaitingResponse()) {
        dirtyEmptyCounter = true;
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].activities === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].gateways === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].events === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].artifacts === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].flows === emptyObject);
        //dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].data === emptyObject);
        if (dirtyEmptyCounter) {
            this.dirty = false;
        }
    }
    this.dirty = true;
    //Call to Remove callBack
    this.listeners.remove(this, updateElement);
};

PMProject.prototype.formatProperty = function (type, property) {
    var prefixes = {
            "PMActivity" : "act",
            "PMGateway" : "gat",
            "PMEvent" : "evn",
            "PMArtifact" : "art",
            "PMData" : "dat",
            "PMParticipant" : "par",
            "PMPool" : "swl",
            "PMLane" : "lan"
        },
        map = {
            // map for shapes
            x: "bou_x",
            y: "bou_y",
            width: "bou_width",
            height: "bou_height"
        },
        out;

    if (type === "PMFlow" || type === 'Connection') {
        out = "flo_" + property;
    } else if (map[property]) {
        out = map[property];
    } else {
        out = prefixes[type] + '_' + property;
    }
    return out;
};
PMProject.prototype.getUpdateList = function (type) {
    var listName = {
            "PMActivity" : "activities",
            "PMGateway" : "gateways",
            "PMEvent" : "events",
            "PMFlow" : "flows",
            "PMArtifact" : "artifacts",
            "PMLabel" : "artifacts",
            "Connection" : "flows",
            "PMData": "data",
            "PMParticipant": "participants",
            "PMPool": "laneset",
            "PMLane": "lanes"
        },
        dirtyArray;
    dirtyArray = (this.isWaitingResponse()) ? 1 : 0;
    return this.dirtyElements[dirtyArray][listName[type]];
};

/**
 * Represents if the proxy is waiting any response from the server
 */
PMProject.prototype.isWaitingResponse = function () {
    return this.waitingResponse;
};

PMProject.prototype.updateIdentifiers = function (response) {
    var i, shape, that = this, connection, shapeCanvas;
    if (typeof response === "object") {
        for (i = 0; i < response.length; i+=1) {
            shape = PMUI.getActiveCanvas().items.find("id", response[i].old_uid);
            shapeCanvas = PMUI.getActiveCanvas().children.find("id", response[i].old_uid);
            connection = PMUI.getActiveCanvas().connections.find("flo_uid", response[i].old_uid);
            this.identifiers[response[i].old_uid] = response[i].new_uid;
            if (shape) {
                shape.id = response[i].new_uid;
                shape.relatedObject.id = response[i].new_uid;
                switch(shape.type) {
                    case "Connection":
                        shape.relatedObject.flo_uid = response[i].new_uid;
                        break;
                    case "PMActivity":
                        shape.relatedObject.act_uid = response[i].new_uid;
                        break;
                    case "PMEvent":
                        shape.relatedObject.evn_uid = response[i].new_uid;
                        break;
                    case "PMGateway":
                        shape.relatedObject.gat_uid = response[i].new_uid;
                        break;
                    case "PMArtifact":
                        shape.relatedObject.art_uid = response[i].new_uid;
                        break;
                    case "PMData":
                        shape.relatedObject.dat_uid = response[i].new_uid;
                        break;
                    case "PMParticipant":
                        shape.relatedObject.par_uid = response[i].new_uid;
                        break;
                    case "PMPool":
                        shape.relatedObject.lns_uid = response[i].new_uid;
                        shape.relatedObject.participantObject.id = 'el_' + response[i].new_uid;
                        break;
                    case "PMLane":
                        shape.relatedObject.lan_uid = response[i].new_uid;
                        break;
                }
            }
            if (shapeCanvas) {
                shapeCanvas.id = response[i].new_uid;
            }
            if (connection) {
                connection.flo_uid = response[i].new_uid;
                connection.id = response[i].new_uid;
            }
        }
    }
};

PMProject.prototype.formatObject = function (element) {
    var i,
        field,
        formattedElement = {},
        property;
    formattedElement[this.formatProperty(element.type, 'uid')] = element.id;

    if (element.adam) {
        for (i = 0; i < element.fields.length;  i += 1) {
            field = element.fields[i];
            formattedElement[field.field] = field.newVal;
        }
    } else if (element.fields){
        for (i = 0; i < element.fields.length;  i += 1) {
            field = element.fields[i];
            property = this.formatProperty(element.type, field.field);
            if (property === "element_uid") {
                field.newVal = field.newVal.id;
            }
            formattedElement[property] = field.newVal;
        }
    }

    return formattedElement;
};

PMProject.prototype.subProcessDiagram = function (element) {
    var sidebarCanvas = [], opt= {name : element.act_name}, s, newCanvas, di;
    PMUI.getActiveCanvas().getHTML().style.display = 'none';
    //console.log(element);
    if (!element.atachedDiagram) {
        for(s = 0; s < PMDesigner.sidebar.length; s += 1) {
            sidebarCanvas = sidebarCanvas.concat(PMDesigner.sidebar[s].getSelectors());
            jQuery(".bpmn_shapes").append(PMDesigner.sidebar[s].getHTML());
        }

        sidebarCanvas.splice(13, 3);  //to remove lane selector
        sidebarCanvas = sidebarCanvas.concat('.mafe-event-start');
        sidebarCanvas = sidebarCanvas.concat('.pmui-pmactivity');
        sidebarCanvas = sidebarCanvas.concat('.mafe-event-end');


        newCanvas = this.buildCanvas(sidebarCanvas, opt);
        PMUI.setActiveCanvas(newCanvas);
        jQuery("#p-center-layout").scroll(newCanvas.onScroll(newCanvas, jQuery("#p-center-layout")));
        newCanvas.getHTML().style.display = 'inline';
        element.atachedDiagram = newCanvas;
        PMDesigner.canvasList.setValue(newCanvas.getID());

        //change business object
        di = newCanvas.createBPMNDiagram();
        newCanvas.businessObject = element.businessObject;
        di.bpmnElement = element.businessObject; //update reference
        newCanvas.businessObject.di = di;


    } else {
        newCanvas = element.atachedDiagram;
        PMUI.setActiveCanvas(newCanvas);
        newCanvas.getHTML().style.display = 'inline';
        PMDesigner.canvasList.setValue(newCanvas.getID());
    }

};

PMProject.prototype.removeAttachedDiagram = function (element) {
    var canvas = element.atachedDiagram;
    this.diagrams.remove(canvas);
    if (canvas.html !== undefined) {
        jQuery(canvas.html).remove();
        canvas.html = null;
    }
    element.atachedDiagram = null;

    PMDesigner.canvasList.removeOption(canvas.getID());

};
PMProject.prototype.setTokens = function (response) {
    this.tokens = response;
    return this;
};

/**
 *
 *
 */
var PMProcess = function (options) {
    /**
     * @property {Object}
     * Object to stores the functionalities from {@link PMUI.proxy.RestProxy RestProxy}
     * @private
     */
    this.remoteProxy = null;
    /**
     * @property {Object}
     * Object to stores the functionalities from any local Proxy
     * @private
     */
    this.localProxy = null;
    /**
     *
     * @private
     */
    this.tokens = null;
    /**
     *
     * @private
     */
    this.keys = null;
    /**
     * @property {String}
     * Represents the process identifier
     */
    this.id = null;
    /* Defines the identifier of the diagram
     * @type {String}
     */
    this.diagramId = null;
    /**
     * Represents the diagram name
     * @type {String}
     */
    this.diagramName = null;
    /**
     * Stores if the project has elements without save
     * @type {Boolean}
     */
    this.dirty = false;
    /**
     * Property related to project name
     * @type {String}
     */
    this.name = null;
    /**
     * Stores id the  project is waiting for a response
     * @type {Boolean}
     */
    this.waitingResponse = false;
    /**
     * Stores the interval of time for auto save feature
     * @type {Number}
     */
    this.saveInterval = 20000;
    /**
     * Stores the current canvas
     * @type {Object}
     */
    this.canvas = null;
    /**
     * Represents an object joint related to elements inside of canvas
     * @tyle {Object}
     */
    this.projectId = null;
    /**
     * Represents the project name
     * @type {String}
     */
    this.projectName = null;

    this.loadingProcess = false;
    this.dirtyElements = [
        {
            laneset: {},
            lanes: {},
            activities: {},
            events:{},
            gateways:{},
            flows:{},
            artifacts: {},
            lines: {},
            data: {},
            participants: {}
        },
        {   
            laneset: {},
            lanes: {},
            activities: {},
            events:{},
            gateways:{},
            flows:{},
            artifacts: {},
            lines: {},
            data: {},
            participants: {}
        }
    ];
    /**
     * Grid that contains the current selected element's properties
     * @type {Object} This object is a used from the jquery propi plugin
     */
    this.propertiesGrid = null;

    this.identifiers ={};
    this.listeners = {
        create : function(){},
        remove : function(){},
        update : function(){},
        success : function(){},
        failure : function(){}
    };
    

    PMProcess.prototype.init.call(this, options);
};
/**
 * Defines the object type
 * @type {String}
 */
PMProcess.prototype.type = 'PMProcess';
/**
 * Defines the object family
 * @type {String}
 */
PMProcess.prototype.family = 'PMProcess';

PMProcess.prototype.init = function (options) {
    var defaults = {
        diagramId: "",
        diagramName: "",
        projectId: "",
        projectName: "",
        description: "",
        canvas: null,
        remoteProxy: null,
        localProxy: null,
        keys: {
            access_token: null,
            expires_in: null,
            token_type: null,
            scope: null,
            refresh_token: null,
            client_id: null,
            client_secret: null
        },
        listeners: {
            create : function(){},
            remove : function(){},
            update : function(){},
            success: function(){},
            failure: function(){}
        }
    };
    jQuery.extend(true, defaults, options);
    this.setId(defaults.id)
        .setName(defaults.name)
        .setDiagramId(defaults.diagramId)
        .setDiagramName(defaults.diagramName)
        .setProjectId(defaults.projectId)
        .setProjectName(defaults.projectName)
        .setDescription(defaults.description)
        .setCanvas(defaults.canvas)
        .setRemoteProxy(defaults.remoteProxy)
        .setLocalProxy(defaults.localProxy)
        .setKeysClient(defaults.keys)
        .setTokens(defaults.keys)
        .setListeners(defaults.listeners);


    this.remoteProxy = new PMUI.proxy.RestProxy();
};
/**
 * Sets the identifier for the process
 * @param {String} id
 */
PMProcess.prototype.setId = function (id) {
    this.id = id;
    return this;
};
/**
 * Sets the diagram identifier from the project
 * @param {String} id [description]
 */
PMProcess.prototype.setDiagramId = function (id) {
    if (typeof id === "string") {
        this.diagramId = id;
    }
    return this;
};
/**
 * [setDiagramName description]
 * @param {[type]} name [description]
 */
PMProcess.prototype.setDiagramName = function (name) {
    if (typeof name === "string") {
        this.diagramName = name;
    }
    return this;
};
/**
 * [setProjectId description]
 * @param {[type]} id [description]
 */
PMProcess.prototype.setProjectId = function (id) {
    if (typeof id === "string") {
        this.projectId = id;
    }
    return this;
};
/**
 * [setProjectName description]
 * @param {[type]} name [description]
 */
PMProcess.prototype.setProjectName = function (name) {
    if (typeof name === "string") {
        this.projectName = name;
        //jQuery(".navBar div").text(name);
        jQuery(".navBar div").remove();
        if ( $( ".navBar h2" ).length > 0) {
                $( ".navBar h2" ).text(name);
        } else {
            jQuery(".navBar").append( "<h2>"+name+"</h2>" );
        }
        
    }
    return this;
};
/**
 * Sets the project name
 * @param {String} value
 */
PMProcess.prototype.setName = function (name) {
    var titleProject;
    this.name = name;
    titleProject = jQuery(".mafe-designer-title-name");
    jQuery(titleProject).html = name;
    return this;
};
/**
 * Sets the project description
 * @param  {String} description [description]
 */
PMProcess.prototype.setDescription = function (description) {
    this.description = description;
    return this;
};
PMProcess.prototype.setDirty = function (dirty) {
    if (typeof dirty === "boolean") {
        this.dirty = dirty;
    }
    return this;
};
/**
 * Sets the time interval used to save automatically
 * @param {Number} interval Expressed in miliseconds
 * @return {*}
 */
PMProcess.prototype.setSaveInterval = function (interval) {
    this.saveInterval = interval;
    return this;
};
/**
 *
 * @param {Object} canvas
 */
PMProcess.prototype.setCanvas = function (canvas) {
    this.canvas = canvas;
    return this;
};
/**
 *
 *
 */
PMProcess.prototype.setKeysClient = function (keys) {
    if (typeof keys === "object") {
        this.keys = keys;
    }
    return this;
};
PMProcess.prototype.setListeners = function (listeners) {
    if (typeof listeners === "object") {
        this.listeners = listeners;
    }
    return this;
};
PMProcess.prototype.getKeysClient = function () {
    //var token = Base64.decode(this.keys);
    var keys = this.keys;
    return {
        access_token: keys.access_token,
        expires_in: keys.expires_in,
        token_type: keys.token_type,
        scope: keys.scope,
        refresh_token: keys.refresh_token,
        client_id: keys.client_id,
        client_secret: keys.client_secret
    };
};
/**
 *
 * @param {Object} proxy
 */
PMProcess.prototype.setRemoteProxy = function (proxy) {
    this.remoteProxy = proxy;
    return this;
};
/**
 *
 * @param {Object} proxy
 */
PMProcess.prototype.setLocalProxy = function (proxy) {
    this.localProxy = proxy;
    return this; 
};
/**
 * Represents a flag if the project was saved or not
 */
PMProcess.prototype.isDirty = function () {
    return this.dirty;
};
/**
 * Represents if the proxy is waiting any response from the server
 */
PMProcess.prototype.isWaitingResponse = function () {
    return this.waitingResponse;
};
/**
 *
 *
 */
PMProcess.prototype.setWaitingResponse = function (value) {
    this.waitingResponse = value;
    return this;
};
/**
 *
 *
 */
PMProcess.prototype.formatProperty = function (type, property) {
    var prefixes = {
            "PMActivity" : "act",
            "PMGateway" : "gat",
            "PMEvent" : "evn",
            "PMArtifact" : "art",
            "PMData" : "dat",
            "PMParticipant" : "par",
            "PMPool" : "swl",
            "PMLane" : "lan"
        },
        map = {
            // map for shapes
            x: "bou_x",
            y: "bou_y",
            width: "bou_width",
            height: "bou_height"
        },
        out;

    if (type === "PMFlow" || type === 'Connection') {
        out = "flo_" + property;
    } else if (map[property]) {
        out = map[property];
    } else {
        out = prefixes[type] + '_' + property;
    }
    return out;
};
/**
 *
 *
 */
PMProcess.prototype.getUpdateList = function (type) {
    var listName = {
            "PMActivity" : "activities",
            "PMGateway" : "gateways",
            "PMEvent" : "events",
            "PMFlow" : "flows",
            "PMArtifact" : "artifacts",
            "PMLabel" : "artifacts",
            "Connection" : "flows",
            "PMData": "data",
            "PMParticipant": "participants",
            "PMPool": "laneset",
            "PMLane": "lanes"
        },
        dirtyArray;
    dirtyArray = (this.isWaitingResponse()) ? 1 : 0;
    return this.dirtyElements[dirtyArray][listName[type]];
};
/**
 *
 *
 */
PMProcess.prototype.objectToArray = function (object) {
    var newArray = [];
    jQuery.each(object, function(index, val) {
        newArray.push(val);
    });
    return newArray;
};
PMProcess.prototype.getDataObject = function () {
    var object, i, elements, shapes;
    elements = this.canvas.items.asArray();

    shapes = {
        activities: [],
        gateways: [],
        events: [],
        flows: [],
        artifacts: [],
        laneset: [],
        lanes: [],
        data: [],
        participants: [],
        pools: []
    };
    if (this.canvas.items.getSize() > 0) {
        for (i = 0; i < elements.length; i+=1) {
            if (typeof elements[i].relatedObject.getDataObject === "undefined"){
                object = elements[i].relatedObject;
            } else {
                object = elements[i].relatedObject.getDataObject();
            }
            switch(elements[i].type) {
                case "PMActivity":
                    shapes.activities.push(object);
                    break;
                case "PMGateway":
                    shapes.gateways.push(object);
                    break;
                case "PMEvent":
                    shapes.events.push(object);
                    break;
                case "PMFlow":
                case "Connection":
                    shapes.flows.push(object);
                    break;
                case "PMArtifact":
                    shapes.artifacts.push(object);
                    break;
                case "PMData":
                    shapes.data.push(object);
                    break;
                case "PMParticipant":
                    shapes.participants.push(object);
                    break;
                case "PMPool":
                    shapes.laneset.push(object);
                    break;
                case "PMLane":
                    shapes.lanes.push(object);
                    break;
            }
        }
    }
    return shapes;
};
/**
 *
 *
 */
PMProcess.prototype.getDirtyObject = function () {
    var that = this,
        shape =this.getDataObject();
    return {
        prj_uid: that.id,
        prj_name: that.projectName,
        prj_description: that.description,
        diagrams: [
            {
                dia_uid: that.diagramId || PMUI.generateUniqueId(),
                pro_uid: that.id,
                laneset: shape.laneset,
                lanes: shape.lanes,
                activities: shape.activities,
                events: shape.events,
                gateways: shape.gateways,
                flows: shape.flows,
                artifacts: shape.artifacts,
                data: shape.data,
                participants: shape.participants
            }
        ]
    };
};
/**
 *
 *
 */
PMProcess.prototype.load = function () {
    var keys = this.getKeysClient(),
    that = this;
    this.remoteProxy.setDataType("json");
    this.remoteProxy.setAuthorizationType('oauth2',keys);

    this.remoteProxy.get({
        url: that.remoteProxy.url,
        authorizationOAuth: true,
        success: function (xhr, response) {
            that.dirty = false;
            that.loadProject(response);
        },
        failure: function (xhr, response) {
            that.listeners.failure(that, xhr, response);
        }
    });

    return this;
};

/**
 *
 *
 */
PMProcess.prototype.loadProject = function (project) {
    var that = this, 
        i,
        shapes,
        result,
        activities,
        gateways,
        events,
        artifacts,
        connections,
        approved,
        diagram,
        laneset;

    if (typeof project !== 'object') {
         project = JSON.parse(project);
    }
    if (project) {
        this.loadingProcess = true;
        this.setProjectId(project.prj_uid);
        this.setProjectName(project.prj_name);
        this.setDescription(project.prj_description);
        diagram = project.diagrams[0];
        this.setDiagramId(diagram.dia_uid);
        this.setDiagramName(diagram.dia_name);

        jQuery.each(diagram.laneset, function(index, val) {
            laneset = diagram.laneset[index];
            if (that.propertiesReview("laneset", laneset)) {
                that.loadShape('POOL', laneset);
            }
        });

        jQuery.each(diagram.activities, function(index, val) {
            activities = diagram.activities[index];
            if (that.propertiesReview("activities", activities)) {
                that.loadShape(activities.act_type, activities);
            }
        });
        jQuery.each(diagram.events, function(index, val) {
            events = diagram.events[index];
            if (that.propertiesReview("events", events)) {
                that.loadShape(events.evn_type, events);
            }
        });
        jQuery.each(diagram.gateways, function(index, val) {
            gateways = diagram.gateways[index];
            if (that.propertiesReview("gateways", gateways)) {
                that.loadShape(gateways.gat_type, gateways);
            }
        });
        jQuery.each(diagram.artifacts, function(index, val) {
            artifacts = diagram.artifacts[index];
            if (that.propertiesReview("artifacts", artifacts)) {
                that.loadShape(artifacts.art_type, artifacts);
            }
        });
        jQuery.each(diagram.data, function(index, val) {
            data = diagram.data[index];
            if (that.propertiesReview("data", data)) {
                that.loadShape(data.dat_type, data);
            }
        });
        jQuery.each(diagram.participants, function(index, val) {
            participants = diagram.participants[index];
            if (that.propertiesReview("participants", participants)) {
                that.loadShape('PARTICIPANT', participants);
            }
        });
        jQuery.each(diagram.flows, function(index, val) {
            connections = diagram.flows[index];
            if (that.propertiesReview("flows", connections)) {
                that.loadFlow(connections);
            }
        });
     
        
        this.loadingProcess = false;
        this.loaded = true;
    } else {
        this.loaded = false;
    }
    this.setDirty(false);
    return this;
};
/**
 * Loads the AdamShape into the diagram
 * @param {Object} shape
 * @param {String} type
 */
PMProcess.prototype.loadShape = function (type, shape) {
    var customShape,
        command,
        transformShape;

    transformShape = this.setShapeValues(type, shape);
    customShape = this.canvas.shapeFactory(type, transformShape);

    if (customShape) {
        //customShape.extendedType = type;
        this.canvas.addElement(customShape, parseInt(shape.bou_x, 10), parseInt(shape.bou_y, 10), true);
        //customShape.attachListeners();    //Important! was detected double call to the events recorded
        this.canvas.updatedElement = customShape;

        command = new PMUI.command.CommandCreate(customShape);
        //this.canvas.commandStack.add(command);
        command.execute();

    }
};
/**
 * Loads the connection into the diagram
 * @param {Object} conn
 */
PMProcess.prototype.loadFlow = function (conn) {
    var sourceObj,
        targetObj,
        startPoint,
        endPoint,
        sourcePort,
        targetPort,
        connection,
        positionX,
        positionY,
        segmentMap = {
            'SEQUENCE' : 'regular',
            'MESSAGE' : 'segmented',
            'DATAASSOCIATION' : 'dotted',
            'ASSOCIATION' : 'dotted',
            'DEFAULT' : 'regular',
            'CONDITIONAL' : 'regular'
        },
        srcDecorator = {
            'SEQUENCE' : 'mafe-decorator',
            'MESSAGE' : 'mafe-message',
            'DATAASSOCIATION' : 'mafe-association',
            'ASSOCIATION' : 'mafe-decorator',
            'DEFAULT' : 'mafe-default',
            'CONDITIONAL' : 'mafe-decorator_conditional'
        },
        destDecorator = {
            //'SEQUENCE' : 'mafe-decorator',
            'SEQUENCE' : 'mafe-sequence',
            'MESSAGE' : 'mafe-message',
            'DATAASSOCIATION' : 'mafe-association',
            'ASSOCIATION' : 'mafe-decorator_association',
            'DEFAULT' : 'mafe-sequence',
            'CONDITIONAL' : 'mafe-sequence'
        },
        positionSourceX,
        positionSourceY,
        positionTargetX,
        positionTargetY;

    sourceObj = this.getElementByUid(conn.flo_element_origin);
    targetObj = this.getElementByUid(conn.flo_element_dest);

    if (typeof sourceObj === "object" && typeof targetObj === "object") {
        startPoint = new PMUI.util.Point(conn.flo_x1, conn.flo_y1);
        endPoint = new PMUI.util.Point(conn.flo_x2, conn.flo_y2);

        sourcePort = new PMUI.draw.Port({
            width: 10,
            height: 10
        });

        targetPort = new PMUI.draw.Port({
            width: 10,
            height: 10
        });

        positionSourceX = startPoint.x - sourceObj.absoluteX + this.canvas.absoluteX;
        positionSourceY = startPoint.y - sourceObj.absoluteY + this.canvas.absoluteY;

        positionTargetX = endPoint.x - targetObj.absoluteX + this.canvas.absoluteX;
        positionTargetY = endPoint.y - targetObj.absoluteY + this.canvas.absoluteY;

        sourceObj.addPort(sourcePort, positionSourceX, positionSourceY);
        targetObj.addPort(targetPort, positionTargetX, positionTargetY, false, sourcePort);

        connection = new PMFlow({
            id : conn.flo_uid,
            srcPort : sourcePort,
            destPort : targetPort,
            canvas : this.canvas,
            segmentStyle : segmentMap[conn.flo_type],
            segmentColor: new PMUI.util.Color(0, 0, 0),
            flo_type : conn.flo_type,
            name : conn.flo_name,
            flo_condition : conn.flo_condition,
            flo_state : conn.flo_state
        });

        connection.setSrcDecorator(new PMUI.draw.ConnectionDecorator({
            decoratorPrefix : srcDecorator[conn.flo_type],
            decoratorType : "source",
            style : {
                cssClasses: []
            },
            width : 11,
            height : 11,
            canvas : this.canvas,
            parent : connection
        }));

        connection.setDestDecorator(new PMUI.draw.ConnectionDecorator({
            decoratorPrefix : destDecorator[conn.flo_type],
            decoratorType : "target",
            style : {
                cssClasses : []
            },
            width : 11,
            height : 11,
            canvas : this.canvas,
            parent : connection
        }));

        //connection.connect();

        
        connection.setSegmentMoveHandlers();

        //add the connection to the canvas, that means insert its html to
        // the DOM and adding it to the connections array
        this.canvas.addConnection(connection);

        // Filling mafeFlow fields
        connection.setTargetShape(targetPort.parent);
        connection.setOriginShape(sourcePort.parent);
        connection.savePoints();

        // now that the connection was drawn try to create the intersections
        connection.checkAndCreateIntersectionsWithAll();

        //attaching port listeners
        sourcePort.attachListeners(sourcePort);
        targetPort.attachListeners(targetPort);

        this.canvas.triggerCreateEvent(connection, []);
    } else {
        throw new Error ("No elements found to connect.".translate());
    }
    

};
/**
 * Returns the shape into the diagram
 * @param {String} uid
 * @return {Object|undefined}
 */

PMProcess.prototype.getElementByUid = function (uid) {
    var element;

    element = this.canvas.items.find('id', uid);
    if (!element) {
        element = this.canvas.getCustomShapes().find('id', uid);
    }
    return element.relatedObject;
};
/**
 *
 *
 */
PMProcess.prototype.addElement = function (element) {
    var object,
        pk_name,
        list,
        i,
        pasteElement,
        elementUndo,
        sh,
        contDivergent = 0,
        contConvergent = 0;

    
    if (element.relatedElements.length > 0) {
       // for (i = 0; i < element.relatedElements.length; i += 1) {
        for (i = element.relatedElements.length -1; i >= 0; i -= 1) {
            pasteElement = element.relatedElements[i];
            list = this.getUpdateList(pasteElement.type);
            if (list === undefined) {
                return;
            }

            list[pasteElement.id] = object;
            elementUndo = {
                id: pasteElement.id,
                relatedElements: [],
                relatedObject: pasteElement,
                type: pasteElement.type || pasteElement.extendedType
            };
            this.canvas.items.insert(elementUndo);
            if (!(pasteElement instanceof PMUI.draw.MultipleSelectionContainer)
                && !(pasteElement instanceof PMLine)
                && !(pasteElement instanceof PMLabel)) {
                pasteElement.createBpmn(pasteElement.getBpmnElementType());
            }

            //object = pasteElement.getDataObject();
        }
    } else {
        switch(element.type) {
            case "Connection":
                pk_name = this.formatProperty(element.type, 'uid');
                list = this.getUpdateList(element.type);
                element.relatedObject[pk_name] = element.id;
                
                if (typeof element.relatedObject.getDataObject === "undefined"){
                    object = element.relatedObject;
                } else {
                    //object = element.relatedObject.getDataObject();
                }
                list[element.id] = object;                
                
                break;
            default:
                pk_name = this.formatProperty(element.type, 'uid');
                list = this.getUpdateList(element.type);
                element.relatedObject[pk_name] = element.id;
                //object = element.relatedObject.getDataObject();
                list[element.id] = object;
                break;
        }
        this.canvas.items.insert(element);

        var shape = element.relatedObject;
        if (!(shape instanceof PMUI.draw.MultipleSelectionContainer)
            && !(shape instanceof PMLine)
            && !(shape instanceof PMLabel)) {
            shape.createBpmn(shape.getBpmnElementType());
        }
    }
    //this.dirty = true;
    
    //Call to Create callBack
    this.listeners.create(this, element);
    
};
/**
 *
 *
 */
PMProcess.prototype.updateElement = function (updateElement) {
    var element,
        i,
        shape,
        object,
        list,
        item;
    for (i = 0; i < updateElement.length; i += 1) {
        element = updateElement[i];
        shape = element.relatedObject;

        object = this.formatObject(element);
        list = this.getUpdateList(element.type);
        
        if (list[element.id]) {
            jQuery.extend(true, list[element.id], object);
            if (element.type === 'Connection') {
                list[element.id].flo_state = object.flo_state;
                item = this.canvas.items.find("id",element.id);
                item.relatedObject.flo_state = object.flo_state;
            }
        } else {
            list[element.id] = object;
        }
        if (shape) {
            if(shape instanceof PMUI.draw.Port) {
                shape.connection.updateBpmn();
            } else {
                if (!(shape instanceof PMUI.draw.MultipleSelectionContainer)
                    && !(shape instanceof PMLine)
                    && !(shape instanceof PMLabel)) {
                    shape.updateBpmn();
                }

            }
        }

    }
    this.dirty = true;



    //Call to Update callBack
    this.listeners.update(this, updateElement);
};
/**
 *
 *
 */
PMProcess.prototype.removeElement = function (updateElement) {
    var object,
        dirtyEmptyCounter,
        element,
        i,
        pk_name,
        list,
        emptyObject = {},
        currentItem;

    for (i = 0; i < updateElement.length; i += 1) {
        element = updateElement[i];
        //Removig from canvas.item
        currentItem = this.canvas.items.find("id", updateElement[i].id);
        this.canvas.items.remove(currentItem);

        list = this.getUpdateList(element.type);
        if (list) {
            pk_name = this.formatProperty(element.type, 'uid');
            if (list[element.id]) {
                delete list[element.id];
            } else {
                pk_name = this.formatProperty(element.type, 'uid');
                object = {};
                object[pk_name] = element.id;
                list[element.id] = object;
            }
        }
        // to remove BpmnModdle in de exported xml
        if (!(element instanceof PMUI.draw.MultipleSelectionContainer)
            && !(element instanceof PMLine)
            && !(element instanceof PMLabel)) {
            element.removeBpmn();
        }


    }
    
    if (!this.isWaitingResponse()) {
        dirtyEmptyCounter = true;
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].activities === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].gateways === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].events === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].artifacts === emptyObject);
        dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].flows === emptyObject);
        //dirtyEmptyCounter = dirtyEmptyCounter && (this.dirtyElements[0].data === emptyObject);
        if (dirtyEmptyCounter) {
            this.dirty = false;
        }
    }
    this.dirty = true;
    //Call to Remove callBack
    this.listeners.remove(this, updateElement);
};
/**
 * Gets the changed fields from an object
 * @param {Object} element
 * @return {Object}
 */
PMProcess.prototype.formatObject = function (element) {
    var i,
        field,
        formattedElement = {},
        property;
    formattedElement[this.formatProperty(element.type, 'uid')] = element.id;

    if (element.adam) {
        for (i = 0; i < element.fields.length;  i += 1) {
            field = element.fields[i];
            formattedElement[field.field] = field.newVal;
        }
    } else if (element.fields){
        for (i = 0; i < element.fields.length;  i += 1) {
            field = element.fields[i];
            property = this.formatProperty(element.type, field.field);
            if (property === "element_uid") {
                field.newVal = field.newVal.id;
            }
            formattedElement[property] = field.newVal;
        }
    }

    return formattedElement;
};
PMProcess.prototype.setRefreshToken = function () {
    var keys = this.getKeysClient(),
    that = this;
    this.remoteProxy.setDataType("json");
    this.remoteProxy.setAuthorizationType('basic',{client:keys.client_id, secret:keys.client_secret});
    
    this.remoteProxy.post({
        url: that.remoteProxy.url,
        data: {
            grant_type: "refresh_token",
            refresh_token: keys.refresh_token
        },
        success: function (xhr, response) {
            that.setKeysClient(response);
            that.setTokens(response);
            that.remoteProxy.setAuthorizationType('oauth2',that.tokens);
        },
        failure: function (xhr, response) {
            throw new Error("There are problems getting tokens from the server...".translate());
        }
    });

};

PMProcess.prototype.setTokens = function (response) {
    this.tokens = response;
    return this;
};
/**
 *
 *
 */ 
PMProcess.prototype.getTokens = function (type) {
    var token;
    if (typeof type === "string") {
        token = this.tokens[type];
    } else if (type === undefined) {
        token = this.tokens;
    }
    return token;
};
/**
 *
 *
 */
PMProcess.prototype.save = function (options) {
    var keys = this.getKeysClient(),
    that = this;
    if (this.isDirty()) {
        this.remoteProxy.setDataType("json");
        this.remoteProxy.setAuthorizationType('oauth2',keys);
        
        this.remoteProxy.update({
            url: that.remoteProxy.url,
            authorizationOAuth: true,
            data: that.getDirtyObject(),
            success: function (xhr, response) {
                that.listeners.success(that, xhr, response);
            },
            failure: function (xhr, response) {
                that.listeners.failure(that, xhr, response);
            }
        });
    }
    return this;
};
PMProcess.prototype.updateIdentifiers = function (response) {
    var i, shape, that = this, connection, shapeCanvas;
    if (typeof response === "object") {
        for (i = 0; i < response.length; i+=1) {
            shape = that.canvas.items.find("id", response[i].old_uid);
            shapeCanvas = that.canvas.children.find("id", response[i].old_uid);
            connection = that.canvas.connections.find("flo_uid", response[i].old_uid);
            this.identifiers[response[i].old_uid] = response[i].new_uid;
            if (shape) {
                shape.id = response[i].new_uid;
                shape.relatedObject.id = response[i].new_uid;
                switch(shape.type) {
                    case "Connection":
                        shape.relatedObject.flo_uid = response[i].new_uid;
                        break;
                    case "PMActivity":
                        shape.relatedObject.act_uid = response[i].new_uid;
                        break;
                    case "PMEvent":
                        shape.relatedObject.evn_uid = response[i].new_uid;
                        break;
                    case "PMGateway":
                        shape.relatedObject.gat_uid = response[i].new_uid;
                        break;
                    case "PMArtifact":
                        shape.relatedObject.art_uid = response[i].new_uid;
                        break;
                    case "PMData":
                        shape.relatedObject.dat_uid = response[i].new_uid;
                        break;
                    case "PMParticipant":
                        shape.relatedObject.par_uid = response[i].new_uid;
                        break;
                    case "PMPool":
                        shape.relatedObject.lns_uid = response[i].new_uid;
                        shape.relatedObject.participantObject.id = 'el_' + response[i].new_uid;
                        break;
                    case "PMLane":
                        shape.relatedObject.lan_uid = response[i].new_uid;
                        break;
                }
            }
            if (shapeCanvas) {
                shapeCanvas.id = response[i].new_uid;
            }
            if (connection) {
                connection.flo_uid = response[i].new_uid;
                connection.id = response[i].new_uid;
            }
        }
    }
};
/**
 *
 *
 */
PMProcess.prototype.setShapeValues = function (type, options) {
    var newShape;
    switch(type) {
        case "TASK":
        case "SUB_PROCESS":
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.id = options.act_uid;
            options.labels = [
                {
                    message: options.act_name
                }
            ];
            break;
        case "START":
        case "END":
        case "INTERMEDIATE":
            options.id = options.evn_uid;
            options.labels = [
                {
                    message: options.evn_name
                }
            ];
            break;
        
        case "TEXT_ANNOTATION":  case "GROUP":
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.id = options.art_uid;
            options.labels = [
                {
                    message: options.art_name
                }
            ];
            break;
        case "COMPLEX":
        case "EXCLUSIVE":
        case "PARALLEL":
        case "INCLUSIVE":
            options.id = options.gat_uid;
            options.labels = [
                {
                    message: options.gat_name
                }
            ];
            break;
        case "DATAOBJECT":
        case "DATASTORE":
        case "DATAINPUT":
        case "DATAOUTPUT":
            options.id = options.dat_uid;
            options.labels = [
                {
                    message: options.dat_name
                }
            ];
            break;
        case "PARTICIPANT":
            options.id = options.par_uid;
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.labels = [
                {
                    message: options.par_name
                }
            ];
            break;
        case "POOL":
            options.id = options.lns_uid;
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.labels = [
                {
                    message: options.par_name
                }
            ];
            break;
        case "LANE":
            options.id = options.lan_uid;
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.labels = [
                {
                    message: options.par_name
                }
            ];
            break;
    }
    return options;
};

PMProcess.prototype.propertiesReview = function (type, currenShape) {
    var passed = true, shape, i;

    shape = {
        laneset: [],
        lanes: [],
        activities: [
            "act_uid",
            "act_name",
            "act_type"
        ],
        events: [
            "evn_uid",
            "evn_name",
            "evn_type"
        ],
        gateways: [
            "gat_uid",
            "gat_name",
            "gat_type"
        ],
        flows: [
            "flo_uid",
            "flo_type",
            "flo_element_dest",
            "flo_element_origin",
            "flo_x1",
            "flo_x2",
            "flo_y1",
            "flo_y2"
        ],
        artifacts: [],
        startMessageEvent : [
            "evn_uid",
            "evn_name",
            "evn_type"
        ],
        startTimerEvent : [
            "evn_uid",
            "evn_name",
            "evn_type"
        ]

    };

    if (shape[type]) {
        for (i = 0; i< shape[type].length; i+=1) {
            //Verify if the property
            if (currenShape[shape[type][i]]) {
                if (currenShape[shape[type][i]] === null && currenShape[shape[type][i]] === "") {
                    currenShape[shape[type][i]] = " ";
                }
            }
        }
    }

    return true;
};
/**
 * @class Snapper
 * Class snapper represents the helper shown while moving shapes.
 * @extend JCoreObject
 *
 * @constructor Creates an instance of the class Snapper
 * @param {Object} options Initialization options
 * @cfg {Point} [orientation="horizontal"] The default orientation of this snapper
 */
var PMSnapper = function (options) {
    PMUI.draw.Snapper.call(this, options);
    /**
     * Orientation of this snapper, it can be either "horizontal" or "vertical".
     * @property {string} [orientation=null]
     */
    this.orientation = null;
    /**
     * Data saved to define the positioning of this snapper in the canvas.
     * @property {Array} [data=[]]
     */
    this.data = [];
    /**
     * The visibility of this snapper.
     * @property {boolean} [visible=false]
     */
    this.visible = false;

    PMSnapper.prototype.initObject.call(this, options);
};

PMSnapper.prototype = new PMUI.draw.Snapper();

/**
 * The type of each instance of this class
 * @property {String}
 */
PMSnapper.prototype.type = "Snapper";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance.
 * @param {Object} options The object that contains the config
 * @private
 */
PMSnapper.prototype.initObject = function (options) {

    var defaults = {
        orientation: "horizontal"
    };

    // extend recursively the defaultOptions with the given options
    $.extend(true, defaults, options);

    // call setters using the defaults object
    this.setOrientation(defaults.orientation);
    this.setDimension(defaults.width,defaults.height);

    // create the html (it's hidden initially)
    this.hide();
};
PMSnapper.prototype.getHTML = function () {
    if (!this.html) {
        this.createHTML();
    }
    return this.html;
};
/**
 * Creates the HTML representation of the snapper.
 * @returns {HTMLElement}
 */
PMSnapper.prototype.createHTML = function () {
    if (!this.html) {
        this.html = document.createElement("div");
        
        this.style.applyStyle();

        this.style.addProperties({
            position: "absolute",
            left: this.zoomX,
            top: this.zoomY,
            width: this.zoomWidth,
            height: this.zoomHeight,
            zIndex: this.zOrder
        });

        this.html.id = this.id;
        this.canvas.html.appendChild(this.html);
        this.setZOrder(99);
        this.html.className = 'mafe-snapper';

        if(this.getOrientation() === 'horizontal') {
            this.html.id = 'guide-h';
            this.html.style.borderTop = '1px dashed #55f';
            this.html.style.width = '100%';
            //this.html.style.position = "absolute"
        } else {
            this.html.id = 'guide-v';
            this.html.style.borderLeft = '1px dashed #55f';
            this.html.style.height = '100%';
            //this.html.style.position = "absolute"
        }

        
    }
    return this.html;
};

/**
 * Hides the snapper.
 * @chainable
 */
PMSnapper.prototype.hide = function () {
    this.visible = false;
    this.setVisible(this.visible);
    return this;
};

/**
 * Shows the snapper.
 * @chainable
 */
PMSnapper.prototype.show = function () {
    this.visible = true;
    this.setVisible(this.visible);
    return this;
};

/**
 * Fills the data for the snapper (using customShapes and regularShapes).
 * The data considered for each shape is:
 *
 * - Its absoluteX
 * - Its absoluteY
 * - Its absoluteX + width
 * - Its absoluteY + height
 *
 * @chainable
 */
PMSnapper.prototype.createSnapData = function () {
    var i,
        index = 0,
        shape,
        border = 0;

    // clear the data before populating it
    this.data = [];

    // populate the data array using the customShapes
    for (i = 0; i < this.canvas.customShapes.getSize(); i += 1) {
        shape = this.canvas.customShapes.get(i);
        if (!this.canvas.currentSelection.find('id', shape.getID())) {
            border = parseInt($(shape.getHTML()).css('borderTopWidth'), 10);
            if (this.orientation === 'horizontal') {
                this.data[index * 2] = shape.getAbsoluteY() - border;
                this.data[index * 2 + 1] = shape.getAbsoluteY() + shape.getZoomHeight();
            } else {
                this.data[index * 2] = shape.getAbsoluteX() - border;
                this.data[index * 2 + 1] = shape.getAbsoluteX() + shape.getZoomWidth();
            }
            index += 1;
        }

    }

    // populate the data array using the regularShapes
    for (i = 0; i < this.canvas.regularShapes.getSize(); i += 1) {
        shape = this.canvas.regularShapes.get(i);
        border = parseInt($(shape.getHTML()).css('borderTopWidth'), 10);
        if (this.orientation === 'horizontal') {
            this.data[index * 2] = shape.getAbsoluteY() - border;
            this.data[index * 2 + 1] = shape.getAbsoluteY() +
                shape.getZoomHeight();
        } else {
            this.data[index * 2] = shape.getAbsoluteX() - border;
            this.data[index * 2 + 1] = shape.getAbsoluteX() +
                shape.getZoomWidth();
        }
        index += 1;
    }
    return this;
};

/**
 * Sorts the data using the builtin `sort()` function, so that there's an strictly increasing order.
 * @chainable
 */
PMSnapper.prototype.sortData = function () {
    this.data.sort(function (a, b) {
        return a > b;
    });
    return this;
};

/**
 * Performs a binary search for `value` in `this.data`, return true if `value` was found in the data.
 * @param {number} value
 * @return {boolean}
 */
PMSnapper.prototype.binarySearch = function (value) {
    var low = 0,
        up = this.data.length - 1,
        mid;

    while (low <= up) {
        mid = parseInt((low + up) / 2, 10);
        if (this.data[mid] === value) {
            return value;
        }
        if (this.data[mid] > value) {
            up = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return false;
};

/**
 * Attaches listeners to this snapper, currently it only has the
 * mouseMove event which hides the snapper.
 * @param {Snapper} snapper
 * @chainable
 */
PMSnapper.prototype.attachListeners = function (snapper) {
    var $snapper = $(snapper.html).mousemove(
        function () {
            snapper.hide();
        }
    );
    return this;
};

/**
 * Sets the orientation of this snapper.
 * @param {string} orientation
 * @chainable
 */
PMSnapper.prototype.setOrientation = function (orientation) {
    if (orientation === "horizontal" || orientation === "vertical") {
        this.orientation = orientation;
    } else {
        throw new Error("setOrientation(): parameter is not valid".translate());
    }
    return this;
};

/**
 * Gets the orientation of this snapper.
 * @return {string}
 */
PMSnapper.prototype.getOrientation = function () {
    return this.orientation;
};
var PMCanvas = function (options) {
    PMUI.draw.Canvas.call(this, options);
    this.project = null;
    this.items = null;
    /**
     * Minimum distance to "snap" to a guide
     * @type {number}
     */
    this.MIN_DISTANCE = 4;
    /**
     * Array which contains a list of all coordinates  to snap
     * @type {number}
     */
    this.guides = []; // no guides available ...

    this.attachedListeners = null;

    this.hasClickEvent = false;
    this.isDragging = false;
    this.dragConnectHandlers = new PMUI.util.ArrayList();
    this.dropConnectHandlers = new PMUI.util.ArrayList();
    this.isDraggingConnectHandler = false;
    this.businessObject = null;
    PMCanvas.prototype.init.call(this, options);
};

PMCanvas.prototype = new PMUI.draw.Canvas();

PMCanvas.prototype.type = "PMCanvas";

this.canvasContainerBehavior = null;

PMCanvas.prototype.init = function (options) {
    var defaults = {
        project: null,
        snapToGuide : true,
        enabledMenu: false,
        hasClickEvent: false
    };
    jQuery.extend(true, defaults, options);
    this.setProject(defaults.project)
        .setEnabledMenu(defaults.enabledMenu)
        .setHasClickEvent(defaults.hasClickEvent)
        .setSnapToGuide(defaults.snapToGuide);

    this.items = new PMUI.util.ArrayList();
    this.attachedListeners = false;
};


PMCanvas.prototype.setHasClickEvent = function  (value) {
    this.hasClickEvent = value;
    return this;
};
PMCanvas.prototype.setEnabledMenu = function  (value) {
    this.enabledMenu = value;
    return this;
};
PMCanvas.prototype.setParent = function (parent) {
    this.parent = parent;
    return this;
};

PMCanvas.prototype.setProject = function (project) {
    if (project instanceof PMProject) {
        this.project = project;
    }
    return this;
};
PMCanvas.prototype.onCreateElementHandler = function (element) {
    var id,
        label,
        menuElement;
    if (this.project) {

        this.project.addElement(element);
        if (!this.project.loadingProcess) {
            this.project.updateElement([]);
        }
        if (element.type === "Connection") {
             return;
        }
    }
};

/**
 * Factory of pool behaviors. It uses lazy instantiation to create
 * instances of the different container behaviors
 * @param {String} type An string that specifies the container behavior we want
 * an instance to have, it can be regular or nocontainer
 * @return {ContainerBehavior}
 */
PMCanvas.prototype.containerBehaviorFactory = function (type) {
    if (type === 'pmcanvas') {
        if (!this.canvasContainerBehavior) {
            this.canvasContainerBehavior = new CanvasContainerBehavior();
        }
        return this.canvasContainerBehavior;
    } else {
        return PMShape.prototype.containerBehaviorFactory.call(this, type);
    }
};

PMCanvas.prototype.triggerTextChangeEvent = function (element, oldText, newText) {
    var valid, reg, e, nText, mp, id;
    if (this.existThatName(element.parent, newText)) {
        newText = oldText;
        PMDesigner.msgFlash('This name already exists.'.translate(), document.body, 'error', 3000, 5);
    }
    reg = /<[^\s]/g;
    nText = newText.trim();
    e = reg.test(nText);
    if (e) {
        nText = nText.replace(/</g, '< ');
    }

    this.updatedElement = [{
        id : element.parent.id,
        type : element.parent.type,
        parent : element.parent,
        fields : [{
            field : "name",
            oldVal : oldText,
            newVal : nText
        }]
    }];
    element.parent.setName(nText);
    element.parent.setBPPMName(nText);
    if (element.parent.atachedDiagram) {
        //var options = PMDesigner.canvasList.options;
        //console.log(options);
        id = PMDesigner.canvasList.getID();
        $('#' + id + ' option[value=' + element.parent.atachedDiagram.getID() + ']')
            .text(nText);
    }

    jQuery(this.html).trigger("changeelement");
};
PMCanvas.prototype.updateDimensionLabel = function (element) {
    var width,
        newWidth;
    width = element.relatedObject.width;
    newWidth = Math.max(width, this.zoomWidth);
    element.relatedObject.label.setWidth(width);
    return this;
};
PMCanvas.prototype.onChangeElementHandler = function (element) {
    var textNode,
        currentElement;
    if (this.project && element.length > 0) {
        try {
            this.project.updateElement(element);

        } catch (e) {
            throw new Error( "Error, There are problems updating the element".translate(), e );
        }
    }
};
PMCanvas.prototype.onRemoveElementHandler = function (element) {
    var i;
    if (this.project) {

        this.project.removeElement(element);

        //PMDesigner.moddle.toXML(PMDesigner.businessObject, function(err, xmlStrUpdated) {
        //    // xmlStrUpdated contains new id and the added project
        //
        //});
        try {
            for (i = 0; i < element.length; i++) {
                if (element[i].type === "Connection") {
                    break;
                }
            }
        } catch(e){
            throw new Error( "Error, There are problems removing the element".translate(), e );
        }
    }
};
PMCanvas.prototype.onSelectElementHandler = function (element) {
    PMUI.removeCurrentMenu();
    if (element.length === 1 ) {
        switch(element[0].type) {
            case 'PMActivity':
            case 'PMEvent':
            case 'PMGateway':
                break;
        }

    }
    if(this.currentLabel != null){
        if(this.canvas.getCurrentSelection().asArray()[0].label != this.currentLabel) {
            this.hideAllFocusedLabels();
        }
    }
    this.isSelected = true;
    this.hideDragConnectHandlers();
    return this;
};

PMCanvas.prototype.defineEvents = function () {
    return PMUI.draw.Canvas.prototype.defineEvents.call(this);
};
PMCanvas.prototype.getContextMenu = function (){
    return {
    };
};
PMCanvas.prototype.onRightClick = function (){
    var that = this;
    return function (a,b,c){
        /*that.menu = new PMUI.ui.Menu(c.getContextMenu());
        document.body.appendChild(that.menu.getHTML());
        that.menu.setPosition(b.pageX, b.PageY);
        that.menu.defineEvents();*/
    };
};
/**
 * Set guide Lines to canvas and create vertican and horizontal snappers
 * @param {Boolean} snap new value to verify if canvas has enabled snappes
 * @chainable
 */
PMCanvas.prototype.setSnapToGuide = function (snap) {
    this.snapToGuide = snap;
    // create snappers

        this.horizontalSnapper = new PMSnapper({
            orientation: 'horizontal',
            canvas: this,
            width : 4000,
            height: 1
        });


        this.verticalSnapper = new PMSnapper({
            orientation: 'vertical',
            canvas: this,
            width : 1,
            height :4000
        });

    return this;
};
/**
 * Build the data of the snappers recreating the arrays,
 * this method is called from {@link RegularDragBehavior#onDragStart} (it might
 * be an overrided method `onDragStart` if the instance of {@link RegularDragBehavior} was changed).
 * @chainable
 */
PMCanvas.prototype.startSnappers = function (event) {
    var shape, i, parent;
    this.horizontalSnapper.getHTML();
    this.verticalSnapper.getHTML();
    this.guides = [];
    for (i = 0; i < this.customShapes.getSize(); i += 1) {
        shape = this.customShapes.get(i);
        if (!this.currentSelection.find('id', shape.getID())) {
            this.computeGuidesForElement(shape);
        }
    }
    return this;

};

PMCanvas.prototype.computeGuidesForElement = function (shape) {
    var x = shape.getAbsoluteX(), y = shape.getAbsoluteY(),
    //var x = jQuery(shape.html).offset().left, 
    //    y = jQuery(shape.html).offset().top,
        w, h;

    w = shape.getZoomWidth() - 1;
    h = shape.getZoomHeight() - 1;
    this.guides.push(
        { type: "h", x: x, y: y },
        { type: "h", x: x, y: y + h },
        { type: "v", x: x, y: y },
        { type: "v", x: x + w, y: y }
    );
    return this;
};

/**
 * Process the snappers according to this criteria and show and hide:
 *
 * - To show the vertical snapper
 *      - `shape.absoluteX` must equal a value in the data of `this.verticalSnapper`
 *      - `shape.absoluteX + shape.width` must equal a value in the data of `this.verticalSnapper`
 *
 * - To show the horizontal snapper
 *      - `shape.absoluteY` must equal a value in the data of `this.horizontalSnapper`
 *      - `shape.absoluteY + shape.height` must equal a value in the data of `this.horizontalSnapper`
 *
 * @param {Object} e
 * @parem {Object} ui
 * @param {Shape} customShape
 * @chainable
 */
PMCanvas.prototype.processGuides = function (e, ui, customShape){
    // iterate all guides, remember the closest h and v guides
    var guideV,
        guideH,
        distV = this.MIN_DISTANCE + 1,
        distH = this.MIN_DISTANCE + 1,
        offsetV,
        offsetH,
        mouseRelX,
        mouseRelY,
        pos,
        w = customShape.getZoomWidth() - 1,
        h = customShape.getZoomHeight() - 1,
        d;

    mouseRelY = e.originalEvent.pageY - ui.offset.top;
    mouseRelX = e.originalEvent.pageX - ui.offset.left;
    pos = {
        top: e.originalEvent.pageY - customShape.canvas.getY() - mouseRelY
            + customShape.canvas.getTopScroll(),
        left: e.originalEvent.pageX - customShape.canvas.getX() - mouseRelX
            + customShape.canvas.getLeftScroll()
    };
    $.each(this.guides, function (i, guide) {
        if (guide.type === "h"){
            d = Math.abs(pos.top - guide.y);
            if (d < distH) {
                distH = d;
                guideH = guide;
                offsetH = 0;
            }
            d = Math.abs(pos.top - guide.y + h);
            if (d < distH) {
                distH = d;
                guideH = guide;
                offsetH = h;
            }
        }
        if (guide.type === "v") {
            d = Math.abs(pos.left - guide.x);
            if (d < distV) {
                distV = d;
                guideV = guide;
                offsetV = 0;
            }
            d = Math.abs(pos.left - guide.x + w);
            if (d < distV) {
                distV = d;
                guideV = guide;
                offsetV = w;
            }
        }
    });

    if (distH <= this.MIN_DISTANCE) {
        $("#guide-h").css("top", guideH.y-this.absoluteY).show();
        if (customShape.parent.family !== 'canvas') {
            ui.position.top = guideH.y - offsetH - customShape.parent.getAbsoluteY();
            customShape.setPosition(ui.helper.position().left / this.zoomFactor,
                guideH.y - offsetH - customShape.parent.getAbsoluteY());
        } else {
            ui.position.top = guideH.y - offsetH;
            customShape.setPosition(ui.helper.position().left / this.zoomFactor,
                guideH.y - offsetH);
        }
    //        customShape.setPosition(ui.helper.position().left / this.zoomFactor,
    //            guideH.y - offsetH);
    } else {
        $("#guide-h").hide();
        //ui.position.top = pos.top;
        //customShape.setPosition(this.getX(), pos.top);
    }

    if (distV <= this.MIN_DISTANCE) {
        $("#guide-v").css("left", guideV.x-this.absoluteX).show();
        if (customShape.parent.family !== 'canvas') {
            ui.position.left = guideV.x - offsetV - customShape.parent.getAbsoluteX();
            customShape.setPosition(
                guideV.x - offsetV - customShape.parent.getAbsoluteX(),
                ui.helper.position().top / this.zoomFactor
            );
        } else {
            ui.position.left = guideV.x - offsetV;
            customShape.setPosition(guideV.x - offsetV,
                ui.helper.position().top / this.zoomFactor);
        }

    } else{
        $("#guide-v").hide();
       // customShape.setPosition(pos.left, this.getY());
       // ui.position.left = pos.left;
    }
    return this;
};

/**
 * Fires the {@link PMUI.draw.Canvas#event-changeelement} event, and elaborates the structure of the object that will
 * be passed to the handlers, the structure contains the following fields (considering old values and new values):
 *
 * - x
 * - y
 * - parent (the shape that is parent of this shape)
 * - state (of the connection)
 *
 * @param {PMUI.draw.Port} port The port updated
 * @chainable
 */
PMCanvas.prototype.triggerPortChangeEvent = function (port) {
    var direction = port.connection.srcPort.getID() === port.getID() ?
            "src" : "dest",
        map = {
            src: {
                x: "x1",
                y: "y1",
                parent: "element_origin",
                type: 'element_origin_type'
            },
            dest: {
                x: "x2",
                y: "y2",
                parent: "element_dest",
                type: 'element_dest_type'
            }
        },
        point,
        state,
        zomeedState = [],
        i;

    // save the points of the new connection
    port.connection.savePoints();
    state = port.connection.getPoints();

    for (i = 0; i < state.length; i += 1) {
        point = port.connection.points[i];
        zomeedState.push(new PMUI.util.Point(point.x / this.zoomFactor, point.y / this.zoomFactor));
    }
    point = direction === "src" ? zomeedState[0] : zomeedState[state.length - 1];

    this.updatedElement = [{
        id: port.connection.getID(),
        type: port.connection.type,
        fields: [
            {
                field: map[direction].x,
                oldVal: point.x,        // there's no old value
                newVal: point.x
            },
            {
                field: map[direction].y,
                oldVal: point.y,        // there's no old value
                newVal: point.y
            },
            {
                field: map[direction].parent,
                oldVal: (port.getOldParent()) ? port.getOldParent().getID() : null,
                newVal: port.getParent().getID()
            },
            {
                field: map[direction].type,
                oldVal: port.connection.getNativeType(port.getParent()).type,
                newVal: port.connection.getNativeType(port.getParent()).type
            },
            {
                field: "state",
                oldVal: port.connection.getOldPoints(),
                newVal: zomeedState
            },
            {
                field: "condition",
                oldVal: "",
                newVal: port.connection.getFlowCondition()
            }
        ],
        relatedObject: port
    }];
    $(this.html).trigger('changeelement');
    this.hideDragConnectHandlers();
};

/**
 * Attaches event listeners to this canvas, it also creates some custom triggers
 * used to save the data (to send it to the database later).
 *
 * The events attached to this canvas are:
 *
 * - {@link PMUI.draw.Canvas#event-mousedown Mouse down event}
 * - {@link PMUI.draw.Canvas#event-mousemove Mouse move event}
 * - {@link PMUI.draw.Canvas#event-mouseup Mouse up event}
 * - {@link PMUI.draw.Canvas#event-click Click event}
 * - {@link PMUI.draw.Canvas#event-scroll Scroll event}
 *
 * The custom events are:
 *
 * - {@link PMUI.draw.Canvas#event-createelement Create element event}
 * - {@link PMUI.draw.Canvas#event-removeelement Remove element event}
 * - {@link PMUI.draw.Canvas#event-changeelement Change element event}
 * - {@link PMUI.draw.Canvas#event-selectelement Select element event}
 * - {@link PMUI.draw.Canvas#event-rightclick Right click event}
 *
 * This method also initializes jQueryUI's droppable plugin (instantiated as `this.dropBehavior`)
 * @chainable
 */
PMCanvas.prototype.attachListeners = function () {
    if (this.attachedListeners === false) {
        var $canvas = $(this.html).click(this.onClick(this)),
        $canvasContainer = $canvas.parent();
        $canvas.dblclick(this.onDblClick(this));
        $canvas.mousedown(this.onMouseDown(this));
        $canvasContainer.scroll(this.onScroll(this, $canvasContainer));
        if (!this.readOnly) {
            $canvas.mousemove(this.onMouseMove(this));
            $canvas.mouseup(this.onMouseUp(this)); 
            $canvas.mouseup(this.onMouseLeave(this)); 
        }
        
        $canvas.on("createelement", this.onCreateElement(this));
        $canvas.on("removeelement", this.onRemoveElement(this));
        $canvas.on("changeelement", this.onChangeElement(this));
        $canvas.on("selectelement", this.onSelectElement(this));
        $canvas.on("rightclick", this.onRightClick(this));
        $canvas.on("contextmenu", function (e) {
            e.preventDefault();
        });
        this.updateBehaviors();
        this.attachedListeners = true;
    }
    return this;
};

PMCanvas.prototype.onDblClick = function (canvas) {
    return function (e, ui) {
        var currentLabel = canvas.currentLabel, figure, realPoint, realPoint, oldConnection;                
        realPoint = canvas.relativePoint(e);
        figure = canvas.getBestConnecion(realPoint);
        if(figure!==null){
            figure.label.getFocus();
        }
    };
};

PMCanvas.prototype.hideAllFocusedLabels =  function () {
    if(this.currentLabel != null)
        this.currentLabel.loseFocus();
    return true;
};

 PMCanvas.prototype.onClick = function (canvas) {
        return function (e, ui) {
            var currentLabel = canvas.currentLabel, figure, realPoint, realPoint, oldConnection;
            //console.log('current:'+ current);
            if (currentLabel) {
                currentLabel.loseFocus();
                $(currentLabel.textField).focusout();
            }
            realPoint = canvas.relativePoint(e);
            figure = canvas.getBestConnecion(realPoint);
            canvas.hideDragConnectHandlers();
            canvas.hideDropConnectHandlers();
            if(figure!==null && !canvas.isMouseDown){
                oldConnection = canvas.currentConnection;
                canvas.emptyCurrentSelection();
                if (oldConnection) {
                    oldConnection.hidePortsAndHandlers();
                }
                figure.showPortsAndHandlers();
                canvas.currentConnection = figure;
            }
            
        };
    };

/**
 * @event mousemove
 * MouseMove handler of the canvas, it does the following:
 *
 * - Updates the position and dimension of `canvas.multipleSelectionContainer`
 *
 * @param {PMUI.draw.Canvas} canvas
 */
PMCanvas.prototype.onMouseMove = function (canvas) {
    return function (e, ui) {
        if (canvas.isMouseDown && !canvas.rightClick) {
            canvas.isMouseDownAndMove = true;
            var x = e.pageX - canvas.getX() + canvas.getLeftScroll() - canvas.getAbsoluteX(),
                y = e.pageY - canvas.getY() + canvas.getTopScroll() - canvas.getAbsoluteY(),
                topLeftX,
                topLeftY,
                bottomRightX,
                bottomRightY,
                parameterX = 0,
                parameterY = 0;
            topLeftX = Math.min(x, canvas.multipleSelectionHelper.oldX);
            topLeftY = Math.min(y, canvas.multipleSelectionHelper.oldY);
            bottomRightX = Math.max(x, canvas.multipleSelectionHelper.oldX);
            bottomRightY = Math.max(y, canvas.multipleSelectionHelper.oldY);
            canvas.multipleSelectionHelper.setPosition(
                topLeftX / canvas.zoomFactor,
                topLeftY / canvas.zoomFactor
            );
            canvas.multipleSelectionHelper.setDimension(
                (bottomRightX - topLeftX) / canvas.zoomFactor,
                (bottomRightY - topLeftY) / canvas.zoomFactor
            );


            if (e.screenY <= 90) {
                window.scrollBy(0,-1);
            }
            if (parseInt(e.screenX+10, 10) >= parseInt(document.body.clientWidth, 10)) {
                window.scrollBy(1,0);
            }
            if (e.screenX < 10) {
                window.scrollBy(-1,0);
            }
            if (parseInt(e.screenY-75, 10) >= parseInt(document.body.clientHeight, 10)) {
                window.scrollBy(0,1);
            }

        }
    };
};

PMCanvas.prototype.onMouseLeave = function (canvas) {
    return function (e, ui) {
        if (parseInt(e.screenX+10, 10) >= parseInt(document.body.clientWidth, 10)) {
            window.scrollBy(1,0);
        }

        if (parseInt(e.screenY-75, 10) >= parseInt(document.body.clientHeight, 10)) {
            window.scrollBy(0,1);
        }
    };
};
/**
 * Parses `options` creating shapes and connections and placing them in this canvas.
 * It does the following:
 *
 * - Creates each shape (in the same order as it is in the array `options.shapes`)
 * - Creates each connection (in the same order as it is in the array `options.connections`)
 * - Creates the an instance of {@link PMUI.command.CommandPaste} (if possible)
 *
 * @param {Object} options
 * @param {Array} [options.shapes=[]] The config options of each shape to be placed in this canvas.
 * @param {Array} [options.connections=[]] The config options of each connection to be placed in this canvas.
 * @param {boolean} [options.uniqueID=false] If set to true, it'll assign a unique ID to each shape created.
 * @param {boolean} [options.selectAfterFinish=false] If set to true, it'll add the shapes that are
 * direct children of this canvas to `this.currentSelection` arrayList.
 * @param {string} [options.prependMessage=""] The message to be prepended to each shape's label.
 * @param {boolean}  [options.createCommand=true] If set to true it'll create a command for each creation
 * of a shape and connection (see {@link PMUI.command.CommandCreate}, 
 {@link PMUI.command.CommandConnect}) and save them in
 * a {@link PMUI.command.CommandPaste} (for undo-redo purposes).
 * @param {number} [options.diffX=0] The number of pixels on the x-coordinate to move the shape on creation
 * @param {number} [options.diffY=0] The number of pixels on the y-coordinate to move the shape on creation
 * @chainable
 */
PMCanvas.prototype.parse = function (options) {
    var defaults = {
            shapes: [],
            connections: [],
            uniqueID: false,
            selectAfterFinish: false,
            prependMessage: "",
            createCommand: true,
            diffX: 0,
            diffY: 0
        },
        i,
        j,
        id,
        oldID,
        shape,
        points,
        shapeOptions,
        connection,
        connectionOptions,
        sourcePort,
        sourcePortOptions,
        sourceShape,
        sourceBorder,
        destPort,
        destPortOptions,
        destShape,
        destBorder,
        command,
        diffX,
        diffY,
        stackCommandCreate = [],
        stackCommandConnect = [],
        canvasID = this.getID(),
        mapOldId = {},              // {oldId: newId}
        map = {};                   // {newId: reference to the shape}
    $.extend(true, defaults, options);
    // set the differentials (if the shapes are pasted in the canvas)
    diffX = defaults.diffX;
    diffY = defaults.diffY;
    // map the canvas
    map[canvasID] = this;
    mapOldId[canvasID] = canvasID;
    // empty the current selection and sharedConnections as a consequence
    // (so that the copy is selected after)
    if (defaults.selectAfterFinish) {
        this.emptyCurrentSelection();
    }
    for (i = 0; i < defaults.shapes.length; i += 1) {
        shapeOptions = {};
        $.extend(true, shapeOptions, defaults.shapes[i]);

        // set the canvas of <shape>
        shapeOptions.canvas = this;

        // create a map of the current id with a new id
        oldID = shapeOptions.id;

        // generate a unique id on user request
        if (defaults.uniqueID) {
            shapeOptions.id = PMUI.generateUniqueId();
        }
        mapOldId[oldID] = shapeOptions.id;

        // change labels' messages (using prependMessage)
        if (shapeOptions.labels) {
            for (j = 0; j < shapeOptions.labels.length; j += 1) {
                shapeOptions.labels[j].message = defaults.prependMessage +
                    shapeOptions.labels[j].message;
            }
        }

        // create an instance of the shape based on its type
        shape = this.shapeFactory(shapeOptions.extendedType, shapeOptions);

        // map the instance with its id
        map[shapeOptions.id] = shape;

        // if the shapes don't have a valid parent then set the parent
        // to be equal to the canvas
        // TODO: ADD shapeOptions.topLeftOnCreation TO EACH SHAPE
        if (!mapOldId[shapeOptions.parent]) {
            this.addElement(shape,
                shapeOptions.x + diffX, shapeOptions.y + diffY, true);
        } else if (shapeOptions.parent !== canvasID) {
            // get the parent of this shape
            map[mapOldId[shapeOptions.parent]].addElement(shape, shapeOptions.x,
                shapeOptions.y, true);
        } else {
            // move the shapes a little (so it can be seen that
            // they were duplicated)
            map[mapOldId[shapeOptions.parent]].addElement(shape,
                shapeOptions.x + diffX, shapeOptions.y + diffY, true);
        }

        // perform some extra actions defined for each shape
        shape.parseHook();

        shape.attachListeners();
        // execute command create but don't add it to the canvas.commandStack
        command = new PMUI.command.CommandCreate(shape);
        command.execute();
        stackCommandCreate.push(command);
    }   
    for (i = 0; i < defaults.connections.length; i += 1) {
        connectionOptions = {};
        $.extend(true, connectionOptions, defaults.connections[i]);

        // state of the connection
        points = connectionOptions.state || [];

        // determine the shapes
        sourcePortOptions = connectionOptions.srcPort;
        sourceShape = map[mapOldId[sourcePortOptions.parent]];
        sourceBorder = sourceShape.getBorderConsideringLayers();

        destPortOptions = connectionOptions.destPort;
        destShape = map[mapOldId[destPortOptions.parent]];
        destBorder = destShape.getBorderConsideringLayers();

        // populate points if points has no info (backwards compatibility,
        // e.g. the flow state is null)
        if (points.length === 0) {
            points.push({
                x: sourcePortOptions.x + sourceShape.getAbsoluteX(),
                y: sourcePortOptions.y + sourceShape.getAbsoluteY()
            });
            points.push({
                x: destPortOptions.x + destShape.getAbsoluteX(),
                y: destPortOptions.y + destShape.getAbsoluteY()
            });
        }

        //create the ports
        sourcePort = new PMUI.draw.Port({
            width: 8,
            height: 8
        });
        destPort = new PMUI.draw.Port({
            width: 8,
            height: 8
        });
        // add the ports to the shapes
        // LOGIC: points is an array of points relative to the canvas.
        // CustomShape.addPort() requires that the point passed as an argument
        // is respect to the shape, so transform the point's coordinates (also
        // consider the border)
        sourceShape.addPort(
            sourcePort,
            points[0].x + diffX + sourceBorder -
                sourceShape.getAbsoluteX(),
            points[0].y + diffX + sourceBorder -
                sourceShape.getAbsoluteY()
        );
        destShape.addPort(
            destPort,
            points[points.length - 1].x + diffX + destBorder -
                destShape.getAbsoluteX(),
            points[points.length - 1].y + diffY + destBorder -
                destShape.getAbsoluteY(),
            false,
            sourcePort
        );

        connection = this.connectionFactory(
            connectionOptions.type,
            {
                srcPort : sourcePort,
                destPort: destPort,
                segmentColor: new PMUI.util.Color(92, 156, 204),
                canvas : this,
                segmentStyle: connectionOptions.segmentStyle
            }
        );
        connection.id = connectionOptions.id || PMUI.generateUniqueId();
        if (defaults.uniqueID) {
            connection.id = PMUI.generateUniqueId();
        }
        //set its decorators
        connection.setSrcDecorator(new PMUI.draw.ConnectionDecorator({
            width: 1,
            height: 1,
            canvas: this,
            decoratorPrefix: connectionOptions.srcDecoratorPrefix,
            decoratorType: "source",
            parent: connection
        }));
        connection.setDestDecorator(new PMUI.draw.ConnectionDecorator({
            width: 1,
            height: 1,
            canvas: this,
            decoratorPrefix: connectionOptions.destDecoratorPrefix,
            decoratorType: "target",
            parent: connection
        }));

        command = new PMUI.command.CommandConnect(connection);
        stackCommandConnect.push(command);

        // connect the two ports
        if (points.length >= 3) {
            connection.connect({
                algorithm: 'user',
                points: connectionOptions.state,
                dx: defaults.diffX,
                dy: defaults.diffY
            });
        } else {
            // use manhattan
    //            console.log("manhattan");
            connection.connect();
        }
        connection.setSegmentMoveHandlers();

        // add the connection to the canvas, that means insert its html to
        // the DOM and adding it to the connections array
        this.addConnection(connection);

        // now that the connection was drawn try to create the intersections
        connection.checkAndCreateIntersectionsWithAll();

        //attaching port listeners
        sourcePort.attachListeners(sourcePort);
        destPort.attachListeners(destPort);

        this.triggerCreateEvent(connection, []);
    }

    // finally add to currentSelection each shape if possible (this method is
    // down here because of the zIndex problem with connections)
    if (defaults.selectAfterFinish) {
        for (id in map) {
            if (map.hasOwnProperty(id)) {
                if (map[id].family !== 'Canvas') {
                    this.addToSelection(map[id]);
                }
            }
        }
    }

    // create command if possible
    if (defaults.createCommand) {
        this.commandStack.add(new PMUI.command.CommandPaste(this, {
            stackCommandCreate: stackCommandCreate,
            stackCommandConnect: stackCommandConnect
        }));
    }
    return this;
};

/**
 * Fires the {@link PMUI.draw.Canvas#event-removeelement} event, 
 and elaborates the structure of the object that will
 * be passed to the handlers.
 * @param {PMUI.draw.CustomShape} shape The shape created
 * @param {Array} relatedElements The array with the other elements created
 * @chainable
 */
PMCanvas.prototype.triggerRemoveEvent = function (shape, relatedElements) {
    if (relatedElements.length === 0) {
        if (shape) {
            relatedElements.push(shape);
        }
    }
    this.updatedElement = {
        id : (shape && shape.id) || null,
        type : (shape && shape.type) || null,
        relatedObject: shape,
        relatedElements : relatedElements
    };
    this.canvas.hideDragConnectHandlers();
    $(this.html).trigger('removeelement');
    return this;
};







PMCanvas.prototype.createConnectHandlers = function (resizableStyle, nonResizableStyle) {
       // if (type === "Oval") {
            var i,
                number = 20,
                connectHandler;
            
            //add the rest to the mid list
            for (i = 0; i < number; i += 1) {
                connectHandler =  new PMConnectHandler({
                                        parent: this,
                                        zOrder: PMUI.util.Style.MAX_ZINDEX + 4,
                                        representation: new PMUI.draw.Rectangle(),
                                        //orientation: this.midPointIdentifiers[i],
                                        resizableStyle: resizableStyle,
                                        nonResizableStyle: nonResizableStyle
                                    });
                this.dragConnectHandlers.insert(
                   connectHandler
                );
                if (!this.html) {
                       return;
                }
                this.html.appendChild(connectHandler.getHTML());
                connectHandler.setPosition(100, 100);
                connectHandler.setCategory("dragConnectHandler");
                    connectHandler.attachListeners();
                connectHandler.paint();
                //connectHandler.setVisible(true);
            }

            for (i = 0; i < number; i += 1) {
                connectHandler =  new PMConnectHandler({
                                        parent: this,
                                        zOrder: PMUI.util.Style.MAX_ZINDEX + 1,
                                        representation: new PMUI.draw.Rectangle(),
                                        //orientation: this.midPointIdentifiers[i],
                                        resizableStyle: resizableStyle,
                                        nonResizableStyle: nonResizableStyle
                                    });
                this.dropConnectHandlers.insert(
                   connectHandler
                );
                if (!this.html) {
                       return;
                }
                this.html.appendChild(connectHandler.getHTML());
                connectHandler.setPosition(400, 100);
                connectHandler.setCategory("dropConnectHandler");
                    connectHandler.attachListeners();

                connectHandler.paint();
                //connectHandler.setVisible(true);

            }
        //}
    return this;
     
};


PMCanvas.prototype.hideDragConnectHandlers = function () {
    for (i = 0; i < this.dragConnectHandlers.getSize(); i += 1) {
        connectHandler = this.dragConnectHandlers.get(i);
        connectHandler.setVisible(false);
    }
return this;
};

PMCanvas.prototype.hideDropConnectHandlers = function () {
    for (i = 0; i < this.dropConnectHandlers.getSize(); i += 1) {
        connectHandler = this.dropConnectHandlers.get(i);
        connectHandler.setVisible(false);
    }
    return this;
};

PMCanvas.prototype.applyZoom = function (scale) {
    this.hideDragConnectHandlers();
    this.hideDropConnectHandlers();
    PMUI.draw.Canvas.prototype.applyZoom.call(this, scale);
    return this;
};
PMCanvas.prototype.existThatName = function (element, name) {
    var i,
        shape,
        result = false;
    for(i = 0; i < this.customShapes.getSize(); i += 1) {
        shape = this.customShapes.get(i);
        if (shape.getID() !== element.getID() && shape.getName()=== element.getName()) {
            result = true;
            break;
        }
    }

  return result;
};
PMCanvas.prototype.addConnection = function (conn) {
    PMUI.draw.Canvas.prototype.addConnection.call(this, conn);
    if (conn.flo_state) {
        conn.disconnect(true).connect({
            algorithm: 'manhattan',
            points: conn.flo_state
        });
        conn.setSegmentMoveHandlers();
    }
};
/**
 * This method hide all flows into a container (shape);
 * @param {BPMNShape} shape
 */
PMCanvas.prototype.hideFlowRecursively = function (shape) {
    var i,
        child,
        j,
        flow;
    for (i = 0; i < shape.getChildren().getSize(); i += 1) {
        child = shape.getChildren().get(i);
        for (j = 0; j < child.getPorts().getSize(); j += 1) {
            flow = child.getPorts().get(j).connection;
            flow.disconnect();
        }
        if (child.getChildren().getSize() > 0 ) {
            this.hideFlowRecursively(child);
        }
    }
};

/**
 * Remove all selected elements, it destroy the shapes and all references to them.
 * @chainable
 */
PMCanvas.prototype.removeElements = function () {
    // destroy the shapes (also destroy all the references to them)
    var shape,
        command;

    command = new PMCommandDelete(this);
    this.commandStack.add(command);
    command.execute();
    return this;
};

PMCanvas.prototype.triggerTaskTypeChangeEvent = function (element) {
    this.updatedElement = [{
        id : element.id,
        type : element.type,
        fields : [
            {
                field : "act_task_type",
                oldVal : '',
                newVal : this.act_task_type
            },
            {
                field : "act_task_type",
                oldVal : '',
                newVal : this.act_task_type
            }
        ],
        relatedObject: element
    }];
    $(this.html).trigger('changeelement');
    return this;
};

PMCanvas.prototype.buildDiagram = function (diagram) {
    var di,that = this;
    this.buildingDiagram = true;
    //this.setDiagramId(diagram.dia_uid);
    //this.setDiagramName(diagram.dia_name);
    if (!this.businessObject) {
        di = this.createBPMNDiagram();
        this.businessObject = PMDesigner.mainProcess;
        this.businessObject.di = di;
    }

    jQuery.each(diagram.laneset, function(index, val) {
        laneset = diagram.laneset[index];
        if (that.propertiesReview("laneset", laneset)) {
            that.loadShape('POOL', laneset, true);
        }
    });

    jQuery.each(diagram.lanes, function(index, val) {
        lanes = diagram.lanes[index];
        if (that.propertiesReview("lanes", lanes)) {
            that.loadShape('LANE', lanes, true);

        }
    });


    jQuery.each(diagram.activities, function(index, val) {
        activities = diagram.activities[index];
        if (that.propertiesReview("activities", activities)) {
            that.loadShape(activities.act_type, activities, true);
        }
    });
    jQuery.each(diagram.events, function(index, val) {
        events = diagram.events[index];
        if (that.propertiesReview("events", events)) {
            that.loadShape(events.evn_type, events, true);
        }
    });
    jQuery.each(diagram.gateways, function(index, val) {
        gateways = diagram.gateways[index];
        if (that.propertiesReview("gateways", gateways)) {
            that.loadShape(gateways.gat_type, gateways, true);
        }
    });
    jQuery.each(diagram.artifacts, function(index, val) {
        artifacts = diagram.artifacts[index];
        if (that.propertiesReview("artifacts", artifacts)) {
            that.loadShape(artifacts.art_type, artifacts, true);
        }
    });
    jQuery.each(diagram.data, function(index, val) {
        data = diagram.data[index];
        if (that.propertiesReview("data", data)) {
            that.loadShape(data.dat_type, data, true);
        }
    });
    jQuery.each(diagram.participants, function(index, val) {
        participants = diagram.participants[index];
        if (that.propertiesReview("participants", participants)) {
            that.loadShape('PARTICIPANT', participants, true);
        }
    });
    jQuery.each(diagram.flows, function(index, val) {
        connections = diagram.flows[index];
        if (that.propertiesReview("flows", connections)) {
            that.loadFlow(connections, true);
        }
    });
    this.buildingDiagram = false;
};


PMCanvas.prototype.propertiesReview = function (type, currenShape) {
    var passed = true, shape, i;

    shape = {
        laneset: [],
        lanes: [],
        activities: [
            "act_uid",
            "act_name",
            "act_type"
        ],
        events: [
            "evn_uid",
            "evn_name",
            "evn_type"
        ],
        gateways: [
            "gat_uid",
            "gat_name",
            "gat_type"
        ],
        flows: [
            "flo_uid",
            "flo_type",
            "flo_element_dest",
            "flo_element_origin",
            "flo_x1",
            "flo_x2",
            "flo_y1",
            "flo_y2"
        ],
        artifacts: [],
        startMessageEvent : [
            "evn_uid",
            "evn_name",
            "evn_type"
        ],
        startTimerEvent : [
            "evn_uid",
            "evn_name",
            "evn_type"
        ]

    };

    if (shape[type]) {
        for (i = 0; i< shape[type].length; i+=1) {
            //Verify if the property
            if (currenShape[shape[type][i]]) {
                if (currenShape[shape[type][i]] === null && currenShape[shape[type][i]] === "") {
                    currenShape[shape[type][i]] = " ";
                }
            }
        }
    }

    return true;
};

PMCanvas.prototype.loadShape = function (type, shape, fireTrigger) {
    var customShape,
        command,
        transformShape,
        container;

    transformShape = this.setShapeValues(type, shape);
    customShape = this.shapeFactory(type, transformShape);

    if (customShape) {
        customShape.extendedType = type;
        if (shape.bou_container === 'bpmnDiagram') {
            //container = this;
            this.addElement(customShape, parseInt(shape.bou_x, 10), parseInt(shape.bou_y, 10), true);
        } else {
            container = this.customShapes.find('id', shape.bou_element);
            container.addElement(customShape, parseInt(shape.bou_x, 10), parseInt(shape.bou_y, 10), true);
        }
        //customShape.attachListeners();    //Important! was detected double call to the events recorded
        this.updatedElement = customShape;

        //this.html.appendChild(customShape.getHTML());
        this.addToList(customShape);
        customShape.showOrHideResizeHandlers(false);
        if (fireTrigger) {
            this.triggerCreateEvent(customShape, []);
        }

        //command = new PMUI.command.CommandCreate(customShape);
        //this.canvas.commandStack.add(command);
        //command.execute();
    }
};


PMCanvas.prototype.setShapeValues = function (type, options) {
    var newShape;
    switch(type) {
        case "TASK":
        case "SUB_PROCESS":
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.id = options.act_uid;
            options.labels = [
                {
                    message: options.act_name
                }
            ];
            break;
        case "START":
        case "END":
        case "INTERMEDIATE":
            options.id = options.evn_uid;
            options.labels = [
                {
                    message: options.evn_name
                }
            ];
            break;

        case "TEXT_ANNOTATION":  case "GROUP":
        options.width = parseInt(options.bou_width, 10);
        options.height = parseInt(options.bou_height, 10);
        options.id = options.art_uid;
        options.labels = [
            {
                message: options.art_name
            }
        ];
        break;
        case "COMPLEX":
        case "EXCLUSIVE":
        case "PARALLEL":
        case "INCLUSIVE":
            options.id = options.gat_uid;
            options.labels = [
                {
                    message: options.gat_name
                }
            ];
            break;
        case "DATAOBJECT":
        case "DATASTORE":
        case "DATAINPUT":
        case "DATAOUTPUT":
            options.id = options.dat_uid;
            options.labels = [
                {
                    message: options.dat_name
                }
            ];
            break;
        case "PARTICIPANT":
            options.id = options.par_uid;
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.labels = [
                {
                    message: options.par_name
                }
            ];
            break;
        case "POOL":
            options.id = options.lns_uid;
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.labels = [
                {
                    message: options.par_name
                }
            ];
            break;
        case "LANE":
            options.id = options.lan_uid;
            options.relPosition = options.bou_rel_position;
            options.width = parseInt(options.bou_width, 10);
            options.height = parseInt(options.bou_height, 10);
            options.labels = [
                {
                    message: options.lan_name
                }
            ];
            break;
    }
    return options;
};



PMCanvas.prototype.loadFlow = function (conn, trigger) {
    var sourceObj,
        targetObj,
        startPoint,
        endPoint,
        sourcePort,
        targetPort,
        connection,
        //positionX,
        //positionY,
        segmentMap = {
            'SEQUENCE' : 'regular',
            'MESSAGE' : 'segmented',
            'DATAASSOCIATION' : 'dotted',
            'ASSOCIATION' : 'dotted',
            'DEFAULT' : 'regular',
            'CONDITIONAL' : 'regular'
        },
        srcDecorator = {
            'SEQUENCE' : 'mafe-decorator',
            'MESSAGE' : 'mafe-message',
            'DATAASSOCIATION' : 'mafe-association',
            'ASSOCIATION' : 'mafe-decorator',
            'DEFAULT' : 'mafe-default',
            'CONDITIONAL' : 'mafe-decorator_conditional'
        },
        destDecorator = {
            //'SEQUENCE' : 'mafe-decorator',
            'SEQUENCE' : 'mafe-sequence',
            'MESSAGE' : 'mafe-message',
            'DATAASSOCIATION' : 'mafe-association',
            'ASSOCIATION' : 'mafe-decorator_association',
            'DEFAULT' : 'mafe-sequence',
            'CONDITIONAL' : 'mafe-sequence'
        },
        positionSourceX,
        positionSourceY,
        positionTargetX,
        positionTargetY;

    sourceObj = this.getElementByUid(conn.flo_element_origin);
    targetObj = this.getElementByUid(conn.flo_element_dest);

    if (typeof sourceObj === "object" && typeof targetObj === "object") {
        startPoint = new PMUI.util.Point(conn.flo_x1, conn.flo_y1);
        endPoint = new PMUI.util.Point(conn.flo_x2, conn.flo_y2);

        sourcePort = new PMUI.draw.Port({
            width: 10,
            height: 10
        });

        targetPort = new PMUI.draw.Port({
            width: 10,
            height: 10
        });

        positionSourceX = startPoint.x - sourceObj.absoluteX + this.canvas.absoluteX;
        positionSourceY = startPoint.y - sourceObj.absoluteY + this.canvas.absoluteY;

        positionTargetX = endPoint.x - targetObj.absoluteX + this.canvas.absoluteX;
        positionTargetY = endPoint.y - targetObj.absoluteY + this.canvas.absoluteY;

        sourceObj.addPort(sourcePort, positionSourceX, positionSourceY);
        targetObj.addPort(targetPort, positionTargetX, positionTargetY, false, sourcePort);

        connection = new PMFlow({
            id : conn.flo_uid,
            srcPort : sourcePort,
            destPort : targetPort,
            canvas : this.canvas,
            segmentStyle : segmentMap[conn.flo_type],
            segmentColor: new PMUI.util.Color(0, 0, 0),
            flo_type : conn.flo_type,
            name : conn.flo_name,
            flo_condition : conn.flo_condition,
            flo_state : conn.flo_state
        });

        connection.setSrcDecorator(new PMUI.draw.ConnectionDecorator({
            decoratorPrefix : srcDecorator[conn.flo_type],
            decoratorType : "source",
            style : {
                cssClasses: []
            },
            width : 11,
            height : 11,
            canvas : this.canvas,
            parent : connection
        }));

        connection.setDestDecorator(new PMUI.draw.ConnectionDecorator({
            decoratorPrefix : destDecorator[conn.flo_type],
            decoratorType : "target",
            style : {
                cssClasses : []
            },
            width : 11,
            height : 11,
            canvas : this.canvas,
            parent : connection
        }));

        //connection.connect();


        connection.setSegmentMoveHandlers();

        //add the connection to the canvas, that means insert its html to
        // the DOM and adding it to the connections array
        this.addConnection(connection);

        // Filling mafeFlow fields
        connection.setTargetShape(targetPort.parent);
        connection.setOriginShape(sourcePort.parent);
        connection.savePoints();

        // now that the connection was drawn try to create the intersections
        connection.checkAndCreateIntersectionsWithAll();

        //attaching port listeners
        sourcePort.attachListeners(sourcePort);
        targetPort.attachListeners(targetPort);
        this.updatedElement = connection;
        if (trigger) {
            this.triggerCreateEvent(connection, []);
        }
    } else {
        throw new Error ("No elements found to connect.".translate());
    }
};

PMCanvas.prototype.getElementByUid = function (uid) {
    var element;
    element = this.items.find('id', uid);
    if (!element) {
        element = this.getCustomShapes().find('id', uid);
    }
    return element.relatedObject;
};

PMCanvas.prototype.createBPMNDiagram = function () {
    var bpmnDia =  PMDesigner.moddle.create('bpmndi:BPMNDiagram', { id: 'dia_' + PMUI.generateUniqueId() });
    var bpmnPlane =  PMDesigner.moddle.create('bpmndi:BPMNPlane', { 'bpmnElement': PMDesigner.mainProcess});
    //var businessObject;
    bpmnDia.plane = bpmnPlane;
    PMDesigner.businessObject.get('diagrams').push(bpmnDia);
    return bpmnPlane;
};
/**
 * @class PMEvent
 * @param {Object} options
 */
var PMEvent = function (options) {
    PMShape.call(this, options);
    /**
     * Defines the alphanumeric unique code
     * @type {String}
     */
    this.evn_uid = null;
    /**
     * Defines the name
     * @type {String}
     */
    this.evn_name = null;
    /**
     * Defines the event type
     * @type {String}
     */
    this.evn_type = null;
    /**
     * Defines the event marker supported
     * @type {String}
     */
    this.evn_marker = null;
    /**
     * Defines id the event interrups or not the execution
     * @type {Boolean}
     */
    this.evn_is_interrupting = true;
    /**
     * Defines the activity attachec when the event is a boundary element
     * @type {String}
     */
    this.evn_attached_to = null;
    /**
     * Defines if the event can cancel the activity attached to
     * @type {Boolean}
     */
    this.evn_cancel_activity = false;
    /**
     * Define the activity related when event is playing as transactional event
     * @type {String}
     */
    this.evn_activity_ref = null;
    /**
     * Defines if the event needs to wait for completation status
     * @type {Boolean}
     */
    this.evn_wait_for_completion = false;
    /**
     * Defines the error name when event is playing like an error event
     * @type {String}
     */
    this.evn_error_name = null;
    /**
     * Defines the error code when event is playing like an error event
     * @type {String}
     */
    this.evn_error_code = null;
    /**
     * Defines the escalation name when event is playing like
     * an escalation event
     * @type {String}
     */
    this.evn_escalation_name = null;
    /**
     * Defines the escalation name when event is playing like
     * an escalation event
     * @type {String}
     */
    this.evn_escalation_code = null;
    /**
     * Defines the condition on the event
     * @type {String}
     */
    this.evn_condition = null;
    /**
     * Defines the message association
     * @type {String}
     */
    this.evn_message = null;
    /**
     * Defines the operation tom be executed when event is used like
     * a transactional event
     * @type {String}
     */
    this.evn_operation_name = null;
    /**
     * XXXX
     * @type {String}
     */
    this.evn_operation_implementation_ref = null;
    /**
     * Defines the date to be executed a timer event
     * @type {String}
     */
    this.evn_time_date = null;
    /**
     * Defines the time cycle to be executed a timer event
     * @type {String}
     */
    this.evn_time_cycle = null;
    /**
     * Defines the duration of the timer event
     * @type {String}
     */
    this.evn_time_duration = null;
    /**
     * Define the behavior of the event. Valid values are: CATCH, THROW
     * @type {String}
     */
    this.evn_behavior = null;

    /**
     * Defines the order of the boundary event when is attached to an activity
     * @type {Number}
     */
    this.numberRelativeToActivity = 0;

    PMEvent.prototype.init.call(this, options);
};

PMEvent.prototype = new PMShape();
/**
 * Defines the object type
 * @type {String}
 */
PMEvent.prototype.type = 'PMEvent';
/**
 * Initialize the object with default values
 * @param {Object} options
 */

/**
 * Initialize the object with default values
 * @param {Object} options
 */
PMEvent.prototype.mapBpmnType = {
    'START' : {
        'MESSAGECATCH': 'bpmn:MessageEventDefinition',
        'TIMER' : 'bpmn:TimerEventDefinition',
        'CONDITIONAL' : 'bpmn:ConditionalEventDefinition',
        'SIGNALCATCH' : 'bpmn:SignalEventDefinition'
        //'MULTIPLECATCH' : 'bpmn:MultipleEventDefinition',
        //'PARALLELCATCH' : 'bpmn:MultipleEventDefinition'
    },
    'INTERMEDIATE': {
        'MESSAGETHROW': 'bpmn:MessageEventDefinition',
        'MESSAGECATCH': 'bpmn:MessageEventDefinition',
        'TIMER': 'bpmn:TimerEventDefinition',
        'CONDITIONAL': 'bpmn:ConditionalEventDefinition',
        'LINKCATCH': 'bpmn:LinkEventDefinition',
        'SIGNALCATCH': 'bpmn:SignalEventDefinition',
        'LINKTHROW': 'bpmn:LinkEventDefinition',
        'COMPENSATIONTHROW': 'bpmn:CompensateEventDefinition',
        'SIGNALTHROW': 'bpmn:SignalEventDefinition'

    },
    'END': {
        'MESSAGETHROW': 'bpmn:MessageEventDefinition',
        'SIGNALTHROW': 'bpmn:SignalEventDefinition',
        'ERRORTHROW': 'bpmn:ErrorEventDefinition',
        'CANCELHROW': 'bpmn:EscalationEventDefinition',
        'COMPENSATIONTHROW': 'bpmn:CompensateEventDefinition',
        'TERMINATETHROW': 'bpmn:TerminateEventDefinition',
        'CANCELTHROW': 'bpmn:CancelEventDefinition',
    }
};

PMEvent.prototype.init = function (options) {
    var defaults = {
        evn_uid: '',
        evn_is_interrupting: true,
        evn_message: '',
        evn_name: '',
        evn_marker: 'EMPTY',
        evn_type: 'START',
        evn_behavior: 'CATCH'
    };
    jQuery.extend(true, defaults, options);
    this.setEventUid(defaults.evn_uid)
        .setEventType(defaults.evn_type)
        .setEventMarker(defaults.evn_marker)
        .setEventMessage(defaults.evn_message)
        .setBehavior(defaults.evn_behavior)
        .setCondition(defaults.evn_condition)
        .setAttachedTo(defaults.evn_attached_to)
        .setIsInterrupting(defaults.evn_is_interrupting);
    if (defaults.evn_name) {
        this.setName(defaults.evn_name);
    }
    this.setOnBeforeContextMenu(this.beforeContextMenu);
};

/**
 * Sets the label element
 * @param {String} value
 * @return {*}
 */
PMEvent.prototype.setName = function (name) {
    if (typeof name !== 'undefined') {
        this.evn_name = name;
        if (this.label) {
            this.label.setMessage(name);
        }
    }
    return this;
};

PMEvent.prototype.getDataObject = function () {
    var container,
        element_id,
        name = this.getName();
    if (this.evn_type === 'BOUNDARY') {
        container = 'bpmnActivity';
        element_id = this.evn_attached_to;
    } else {
        //container = 'bpmnDiagram';
        //element_id = this.canvas.id;
        if (this.parent.type === 'PMCanvas') {
            container = 'bpmnDiagram';
            element_id = this.canvas.id;
        } else {
            container = 'bpmnPool';
            element_id = this.parent.id;
        }

    }
    return {
        evn_uid: this.id,
        evn_name: name,
        evn_type: this.evn_type,
        evn_marker: this.evn_marker,
        evn_is_interrupting: this.evn_is_interrupting,
        evn_attached_to: this.evn_attached_to,
        evn_cancel_activity: this.evn_cancel_activity,
        evn_activity_ref: this.evn_activity_ref,
        evn_wait_for_completion: this.evn_wait_for_completion,
        evn_error_name: this.evn_error_name,
        evn_error_code: this.evn_error_code,
        evn_escalation_name: this.evn_escalation_name,
        evn_escalation_code: this.evn_escalation_code,
        evn_condition: this.evn_condition,
        evn_message: this.evn_message,
        evn_operation_name: this.evn_operation_name,
        evn_operation_implementation_ref: this.evn_operation_implementation_ref,
        evn_time_date: this.evn_time_date,
        evn_time_cycle: this.evn_time_cycle,
        evn_time_duration: this.evn_time_duration,
        evn_behavior: this.evn_behavior,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: container,
        element_id: element_id,
        _extended: this.getExtendedObject()
    };
};

/**
 * Sets the event uid property
 * @param {String} id
 * @return {*}
 */
PMEvent.prototype.setEventUid = function (id) {
    this.evn_uid = id;
    return this;
};

/**
 * Sets the event type property
 * @param {String} type
 * @return {*}
 */
PMEvent.prototype.setEventType = function (type) {
    type = type.toLowerCase();
    var defaultTypes = {
        start: 'START',
        end: 'END',
        intermediate: 'INTERMEDIATE',
        boundary: 'BOUNDARY'
    };
    if (defaultTypes[type]) {
        this.evn_type = defaultTypes[type];
    } else {
        //console.error("Error, problems with the evn_type property");
    }
    return this;
};

/**
 * Sets the event marker property
 * @param {String} marker
 * @return {*}
 */
PMEvent.prototype.setEventMarker = function (marker) {
    this.evn_marker = marker;
    return this;
};

/**
 * Sets if the event interrups the execution or not
 * @param {Boolean} value
 * @return {*}
 */
PMEvent.prototype.setIsInterrupting = function (value) {
    if (typeof value === "boolean") {
        this.evn_is_interrupting = value;
    }
    return this;
};

/**
 * Sets the event behavior property
 * @param {String} behavior
 * @return {*}
 */
PMEvent.prototype.setBehavior = function (behavior) {
    behavior = behavior.toLowerCase();
    var defaultBehaviors = {
        "catch": 'CATCH',
        "throw": 'THROW'
    };
    if (defaultBehaviors[behavior]) {
        this.evn_behavior = defaultBehaviors[behavior];
    }
    return this;
};

/**
 * Sets the activity id where the event is attached to
 * @param {String} value
 * @param {Boolean} [cancel]
 * @return {*}
 */
PMEvent.prototype.setAttachedTo = function (value, cancel) {
    if (typeof cancel !== 'undefined') {
        if (typeof cancel === "boolean") {
            this.evn_cancel_activity = cancel;
        }
    } else {
        this.evn_cancel_activity = this.evn_cancel_activity || false;
    }
    this.evn_attached_to = value;
    return this;
};

/**
 * Destroy a event
 * @returns {PMEvent}
 */
PMEvent.prototype.destroy = function () {
    if (this.getType() === 'PMEvent' && this.getEventType() === 'BOUNDARY') {
        if (this.parent.boundaryPlaces && this.numberRelativeToActivity !== null) {
            this.parent.boundaryPlaces
                .get(this.numberRelativeToActivity)
                .available = true;
            this.parent.boundaryArray.remove(this);

        }
    }
    return this;
};

/**
 * Sets the event message
 * @param {String} msg
 * @return {*}
 */
PMEvent.prototype.setEventMessage = function (msg) {
    this.evn_message = msg;
    return this;
};

/**
 * Sets the event condition property
 * @param {String} value
 * @return {*}
 */
PMEvent.prototype.setCondition = function (value) {
    this.evn_condition = value;
    return this;
};

/**
 * Set the compensation properties
 * @param {String} activity
 * @param {Boolean} wait
 * @return {*}
 */
PMEvent.prototype.setCompensationActivity = function (activity, wait) {
    if (typeof wait !== 'undefined') {
        if (typeof wait === "boolean") {
            this.evn_wait_for_completion = wait;
        }
    } else {
        this.evn_wait_for_completion = this.evn_wait_for_completion || false;
    }
    this.evn_activity_ref = activity;
    return this;
};

/**
 * Sets the error properties
 * @param {String} name  Error Name
 * @param {String} code  Error Code
 * @return {*}
 */
PMEvent.prototype.setEventError = function (name, code) {
    this.evn_error_name = name;
    this.evn_error_code = code;
    return this;
};

/**
 * Sets the escalation properties
 * @param {String} name Escalation Name
 * @param {String} code Escalation Code
 * @return {*}
 */
PMEvent.prototype.setEventEscalation = function (name, code) {
    this.evn_escalation_name = name;
    this.evn_escalation_code = code;
    return this;
};

/**
 * Sets the event operation properties
 * @param {String} name
 * @param {String} implementation
 * @return {*}
 */
PMEvent.prototype.setEventOperation = function (name, implementation) {
    this.evn_operation_name = name;
    this.evn_operation_implementation_ref = implementation;
    return this;
};

/**
 * Sets the event timer properties
 * @param {String} date
 * @param {String} cycle
 * @param {String} duration
 * @return {*}
 */
PMEvent.prototype.setEventTimer = function (date, cycle, duration) {
    this.evn_time_date = date;
    this.evn_time_cycle = cycle;
    this.evn_time_duration = duration;
    return this;
};

/**
 * Sets te default_flow property
 * @param value
 * @return {*}
 */
PMEvent.prototype.setDefaultFlow = function (value) {
    PMShape.prototype.setDefaultFlow.call(this, value);
    this.evn_default_flow = value;
    return this;
};

/**
 * Attach the event to an activity
 * @return {*}
 */
PMEvent.prototype.attachToActivity = function () {
    var numBou = this.parent.getAvailableBoundaryPlace();
    if (numBou !== false) {
        this.parent.setBoundary(this, numBou);
        this.setNumber(numBou);
    } else {
        this.destroy();
        this.saveAndDestroy();
    }
    return this;
};

/**
 * Sets the number/order of the current event when is attached to an activity
 * @param {Number} num
 * @return {*}
 */
PMEvent.prototype.setNumber = function (num) {
    this.numberRelativeToActivity = num;
    return this;
};

PMEvent.prototype.getEventType = function () {
    return this.evn_type;
};

PMEvent.prototype.getEventMarker = function () {
    return this.evn_marker;
};

PMEvent.prototype.getEventMessage = function () {
    return this.evn_message;
};

/**
 * Change an event marker
 * @return {Object}
 */
PMEvent.prototype.changeMarkerTo = function (type) {
    var command = new CommandChangeEventMarker(this, type);
    this.canvas.commandStack.add(command);
    command.execute();
    return this;
};

PMEvent.prototype.beforeContextMenu = function () {
    var items, i,
        menuItem,
        hasMarker = false;
    switch (this.getEventType()) {
    case 'END':
        items = this.menu.items.find('id', 'result').childMenu.items;
        break;
    case 'INTERMEDIATE':
    case 'START':
        if (this.evn_behavior === 'CATCH') {
            items = this.menu.items.find('id', 'trigger').childMenu.items;
        } else {
            items = this.menu.items.find('id', 'result').childMenu.items;
        }
        break;
    default:
        items = new PMUI.util.ArrayList();
        break;
    }
    for (i = 0; i < items.getSize(); i += 1) {
        menuItem = items.get(i);
        if (menuItem.id === this.getEventType().toLowerCase() +
            this.getEventMarker().toLowerCase()) {
            menuItem.disable();
            hasMarker = true;
        } else {
            menuItem.enable();
        }
    }
};
/**
 * Stringifies the PMEvent object
 * @return {Object}
 */
PMEvent.prototype.stringify = function () {
    var inheritedJSON = PMShape.prototype.stringify.call(this),
        thisJSON = {
            //evn_type: this.getType(),
            evn_marker: this.getEventMarker(),
            evn_message: this.getEventMessage(),
            //evn_behavior: this.evn_behavior,
            evn_condition: this.evn_condition,
            evn_attached_to: this.evn_attached_to,
            evn_is_interrupting: this.evn_is_interrupting,
            evn_behavior: this.evn_behavior
        };
    jQuery.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

/**
 * create bpmn object and attach to businessObject event
 */

PMEvent.prototype.createWithBpmn = function(bpmnElementType) {
    PMShape.prototype.createWithBpmn.call(this, bpmnElementType, 'businessObject');
    this.businessObject.eventDefinitions = [];
    this.createEventDefinition();
};

PMEvent.prototype.createEventDefinition = function () {
    var def, type;
    if (this.getEventMarker() !== 'EMPTY'
        && this.getEventMarker() !==  'MULTIPLECATCH'
        && this.getEventMarker() !==  'PARALLELCATCH') {
        type = this.mapBpmnType[this.getEventType()][this.getEventMarker()];
        def = PMDesigner.bpmnFactory.create(type, {id: 'def_' + PMUI.generateUniqueId()});
        this.businessObject.eventDefinitions.push(def);
    }
};

PMEvent.prototype.updateBpmEventMarker = function (newBpmnType) {
    this.removeBpmn();
    this.businessObject = null;
    this.createBpmn(newBpmnType);
};
/**
 * @class PMActivity
 * @param {Object} options
 */
var PMActivity = function (options) {
	PMShape.call(this, options);
	
    /**
     * Activity Alphanumeric unique identifier
     * @type {String}
     */
    this.act_uid = null;
    /**
     * Activity name
     * @type {String}
     */
    this.act_name = null;
    /**
     * Activity Type
     * @type {String}
     */
    this.act_type = null;
    /**
     * Define if the task is for compensation (BPMN)
     * @type {Boolean}
     */
    this.act_is_for_compensation = null;
    /**
     * Define the quantity needed to start the activity
     * @type {Number}
     */
    this.act_start_quantity = null;
    /**
     * Define the quantity needed to complete the activity
     * @type {Number}
     */
    this.act_completion_quantity = null;
    /**
     * Define the task type.
     * @type {String}
     */
    this.act_task_type = null;
    /**
     * Define the activity implementation
     * @type {String}
     */
    this.act_implementation = null;
    /**
     * Define the instatiation status
     * @type {Boolean}
     */
    this.act_instantiate = null;
    /**
     * Define the script type supported
     * @type {String}
     */
    this.act_script_type = null;
    /**
     * Define the script
     * @type {String}
     */
    this.act_script = null;
    /**
     * Defines the loop type accepted
     * @type {String}
     */
    this.act_loop_type = null;
    /**
     * Define if the test to complete the loop would be executed before o later
     * @type {Boolean}
     */
    this.act_test_before = null;
    /**
     * Defines the maximum value of loops allowed
     * @type {Number}
     */
    this.act_loop_maximum = null;
    /**
     * Defines the loop condition
     * @type {String}
     */
    this.act_loop_condition = null;
    /**
     * Defines the loop cardinality
     * @type {String}
     */
    this.act_loop_cardinality = null;
    /**
     * Defines the loop behavior
     * @type {String}
     */
    this.act_loop_behavior = null;
    /**
     * Define if the activity has an adhoc behavior
     * @type {Boolean}
     */
    this.act_is_adhoc = null;
    /**
     * Defines if the activity is collapsed
     * @type {Boolean}
     */
    this.act_is_collapsed = null;
    /**
     * Defines the condition needed to complete the activity
     * @type {String}
     */
    this.act_completion_condition = null;
    /**
     * Define the order to be executed when exists several task in parallel mode
     * @type {Number}
     */
    this.act_ordering = null;
    /**
     * Defines if into a loop all instances would be cancelled
     * @type {Boolean}
     */
    this.act_cancel_remaining_instances = null;
    /**
     * Defines the protocol used for the transaction activities
     * @type {String}
     */
    this.act_protocol = null;
    /**
     * Define the method to be used when activity consume/execute a web service
     * @type {String}
     */
    this.act_method = null;
    /**
     * Define the scope of the activity
     * @type {Boolean}
     */
    this.act_is_global = null;
    /**
     * Define the referer to another object (Process, Participant or Another Activity)
     * @type {String}
     */
    this.act_referer = null;
    /**
     * Defines the default flow when activity is related to two or more flows
     * @type {String}
     */
    this.act_default_flow = null;
    /**
     * Defines the diagram related when activity plays as subprocess
     * @type {String}
     */
    this.act_master_diagram = null;
    /**
     * Array of Boundary places created to receive boundary events
     * @type {Array}
     */
    this.boundaryPlaces = new PMUI.util.ArrayList();
    /**
     * Array of Boundary events attached to this activity
     * @type {Array}
     */
    this.boundaryArray = new PMUI.util.ArrayList();
  
	PMActivity.prototype.init.call(this, options);
};

/**
 * Point the prototype to the PMShape Object
 * @type {PMShape}
 */
PMActivity.prototype = new PMShape();
/**
 * Defines the object type
 * @type {String}
 */
PMActivity.prototype.type = 'PMActivity';
/**
 * Points to container behavior object
 * @type {Object}
 */
PMActivity.prototype.activityContainerBehavior = null;
/**
 * Points to the resize behavior object
 * @type {Object}
 */
PMActivity.prototype.activityResizeBehavior = null;

PMActivity.prototype.mapBpmnType = {
    'EMPTY': 'bpmn:Task',
    'SENDTASK': 'bpmn:SendTask',
    'RECEIVETASK' : 'bpmn:ReceiveTask',
    'USERTASK' : 'bpmn:UserTask',
    'SERVICETASK' : 'bpmn:ServiceTask',
    'SCRIPTTASK' : 'bpmn:ScriptTask',
    'MANUALTASK' : 'bpmn:ManualTask',
    'BUSINESSRULE' : 'bpmn:BusinessRuleTask'
};
/**
 * Initialize object with default values
 * @param options
 */
PMActivity.prototype.init = function (options) {
    var defaults = {
        act_type: 'TASK',
        act_name: 'Task',
        act_loop_type: 'NONE',
        act_is_for_compensation: false,
        act_task_type: 'EMPTY',
        act_is_collapsed: false,
        act_is_global: false,
        act_loop_cardinality: 0,
        act_loop_maximum: 0,
        act_start_quantity: 1,
        act_is_adhoc: false,
        act_cancel_remaining_instances: true,
        act_instantiate: false,
        act_completion_quantity: 0,
        act_implementation: '',
        act_script: '',
        act_script_type: '',
        act_default_flow: 0,
        minHeight: 50,
        minWidth: 100,
        maxHeight: 500,
        maxWidth: 600
    };
    jQuery.extend(true, defaults, options);
    this.setActivityUid(defaults.act_uid)
        .setActName(defaults.act_name)
        .setActivityType(defaults.act_type)
        .setLoopType(defaults.act_loop_type)
        .setIsForCompensation(defaults.act_is_for_compensation)
        .setTaskType(defaults.act_task_type)
        .setIsCollapsed(defaults.act_is_collapsed)
        .setIsGlobal(defaults.act_is_global)
        .setLoopCardinality(defaults.act_loop_cardinality)
        .setLoopMaximun(defaults.act_loop_maximum)
        .setStartQuantity(defaults.act_start_quantity)
        .setIsAdhoc(defaults.act_is_adhoc)
        .setCancelRemainingInstances(defaults.act_cancel_remaining_instances)
        .setInstantiate(defaults.act_instantiate)
        .setImplementation(defaults.act_implementation)
        .setCompletionQuantity(defaults.act_completion_quantity)
        .setScript(defaults.act_script)
        .setScriptType(defaults.act_script_type)
        .setDefaultFlow(defaults.act_default_flow)
        .setMinHeight(defaults.minHeight)
        .setMinWidth(defaults.minWidth)
        .setMaxHeight(defaults.maxHeight)
        .setMaxWidth(defaults.maxWidth);
};
/**
 * Sets the label element
 * @param {String} value
 * @return {*}
 */
PMActivity.prototype.setName = function (name) {
    if (typeof name !== 'undefined') {
        this.act_name = name;
        if (this.label) {
            this.label.setMessage(name);
        }
    }
    return this;
};
/**
 * Returns the activity type property
 * @return {String}
 */
PMActivity.prototype.getActivityType = function () {
    return this.act_type;
};

/**
 * Returns the is for compensation property
 * @return {Boolean}
 */
PMActivity.prototype.getIsForCompensation = function () {
    return this.act_is_for_compensation;
};

/**
 * Returns if the activity cancel remaining instances when is cancelled
 * @return {Boolean}
 */
PMActivity.prototype.getCancelRemainingInstances = function () {
    return this.act_cancel_remaining_instances;
};

/**
 * Returns the quantity needed to complete an activity
 * @return {Number}
 */
PMActivity.prototype.getCompletionQuantity = function () {
    return this.act_completion_quantity;
};

/**
 * Set is the activity is global (scope)
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.getIsGlobal = function () {
    return this.act_is_global;
};

/**
 * Returns the start quantity needed to start an activity
 * @return  {Number}
 */
PMActivity.prototype.getStartQuantity = function () {
    return this.act_start_quantity;
};

/**
 * Returns if the instance is active
 * @return {Boolean}
 */
PMActivity.prototype.getInstantiate = function () {
    return this.act_instantiate;
};

/**
 * Returns the implementation property
 * @return {String}
 */
PMActivity.prototype.getImplementation = function () {
    return this.act_implementation;
};

/**
 * Return the Script property
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.getScript = function () {
    return this.act_script;
};

/**
 * Return the Script Type property
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.getScriptType = function () {
    return this.act_script_type;
};

/**
 * Return the minimun height of an activity
 * @return {*}
 */
PMActivity.prototype.getMinHeight = function () {
    return this.minHeight;
};

/**
 * Return the minimun width of an activity
 * @return {*}
 */
PMActivity.prototype.getMinWidth = function () {
    return this.minWidth;
};
/**
 * Return the maximun height of an activity
 * @return {*}
 */
PMActivity.prototype.getMaxHeight = function () {
    return this.maxHeight;
};

/**
 * Return the maximun width of an activity
 * @return {*}
 */
PMActivity.prototype.getMaxWidth = function () {
    return this.maxWidth;
};
/**
 * Sets the act_uid property
 * @param {String} value
 * @return {*}
 */
PMActivity.prototype.setActivityUid = function (value) {
    this.act_uid = value;
    return this;
};

/**
 * Sets the activity type property
 * @param {String} type
 * @return {*}
 */
PMActivity.prototype.setActivityType = function (type) {
    this.act_type = type;
    return this;
};

/**
 * Sets the implementation property
 * @param {String} type
 * @return {*}
 */
PMActivity.prototype.setImplementation = function (type) {
    this.act_implementation = type;
    return this;
};

/**
 * Set the loop type property
 * @param {String} type
 * @return {*}
 */
PMActivity.prototype.setLoopType = function (type) {
    this.act_loop_type = type;
    return this;
};

/**
 * Sets the collapsed property
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.setIsCollapsed = function (value) {
    if (typeof value === "boolean") {
        this.act_is_collapsed = value;
    }
    return this;
};

/**
 * Sets the is for compensation property
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.setIsForCompensation = function (value) {
    if (typeof value === "boolean") {
        this.act_is_for_compensation = value;
    }
    return this;
};

/**
 * Sets the activity task type
 * @param {String} type
 * @return {*}
 */
PMActivity.prototype.setTaskType = function (type) {
    this.act_task_type = type;
    return this;
};

/**
 * Set is the activity is global (scope)
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.setIsGlobal = function (value) {
    if (typeof value === "boolean") {
        this.act_is_global = value;
    }
    return this;
};

/**
 * Set the loop cardinality of the activity
 * @param {String} value
 * @return {*}
 */
PMActivity.prototype.setLoopCardinality = function (value) {
    this.act_loop_cardinality = value;
    return this;
};

/**
 * Sets the loop maximun value
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setLoopMaximun = function (value) {
    this.act_loop_maximum = value;
    return this;
};

/**
 * Sets the start quantity needed to start an activity
 * @param  {Number} value
 * @return {*}
 */
PMActivity.prototype.setStartQuantity = function (value) {
    this.act_start_quantity = value;
    return this;
};

/**
 * Sets if the activity has an adhoc behavior
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.setIsAdhoc = function (value) {
    if (typeof value === "boolean") {
        this.act_is_adhoc = value;
    }
    return this;
};

/**
 * Sets if the activity cancel remaining instances when is cancelled
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.setCancelRemainingInstances = function (value) {
    if (typeof value === "boolean") {
        this.act_cancel_remaining_instances = value;
    }
    return this;
};

/**
 * Sets if the instance is active
 * @param {Boolean} value
 * @return {*}
 */
PMActivity.prototype.setInstantiate = function (value) {
    if (typeof value === "boolean") {
        this.act_instantiate = value;
    }
    return this;
};

/**
 * Sets the quantity needed to complete an activity
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setCompletionQuantity = function (value) {
    this.act_completion_quantity = value;
    return this;
};

/**
 * Sets the Script property
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setScript = function (value) {
    this.act_script = value;
    return this;
};

/**
 * Sets the Script Type property
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setScriptType = function (value) {
    this.act_script_type = value;

    return this;
};

/**
 * Sets te default_flow property
 * @param value
 * @return {*}
 */
PMActivity.prototype.setDefaultFlow = function (value) {
    if (this.html) {
        PMShape.prototype.setDefaultFlow.call(this, value);
        this.canvas.triggerCommandAdam(this, ['act_default_flow'], [this.act_default_flow], [value]);
    }
    this.act_default_flow = value;
    return this;
};
/**
 * Sets the minimun height
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setMinHeight = function (value) {
    this.minHeight = value;
    return this;
};

/**
 * Sets the minimun with
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setMinWidth = function (value) {
    this.minWidth = value;

    return this;
};
/**
 * Sets the maximun height
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setMaxHeight = function (value) {
    this.maxHeight = value;
    return this;
};

/**
 * Sets the maximun with
 * @param {Number} value
 * @return {*}
 */
PMActivity.prototype.setMaxWidth = function (value) {
    this.maxWidth = value;

    return this;
};

PMActivity.prototype.setActType = function (type) {
	this.act_type = type;
	return this;
};

PMActivity.prototype.setActName = function (name) {
	this.act_name = name;
	return this;
};

PMActivity.prototype.getDataObject = function () {
	var name = this.getName();
    return {
		act_uid: this.id,
		act_name: name,
		act_type: this.act_type,
		act_task_type: this.act_task_type,
        act_is_for_compensation: this.act_is_for_compensation,
        act_start_quantity: this.act_start_quantity,
        act_completion_quantity: this.act_completion_quantity,
        act_implementation: this.act_implementation,
        act_instantiate: this.act_instantiate,
        act_script_type: this.act_script_type,
        act_script: this.act_script,
        act_loop_type: this.act_loop_type,
        act_test_before: this.act_test_before,
        act_loop_maximum: this.act_loop_maximum,
        act_loop_condition: this.act_loop_condition,
        act_loop_cardinality: this.act_loop_cardinality,
        act_loop_behavior: this.act_loop_behavior,
        act_is_adhoc: this.act_is_adhoc,
        act_is_collapsed: this.act_is_collapsed,
        act_completion_condition: this.act_completion_condition,
        act_ordering: this.act_ordering,
        act_cancel_remaining_instances: this.act_cancel_remaining_instances,
        act_protocol: this.act_protocol,
        act_method: this.act_method,
        act_is_global: this.act_is_global,
        act_referer: this.act_referer,
        act_default_flow: this.act_default_flow,
        act_master_diagram: this.act_master_diagram,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};



/**
 * Create/Initialize the boundary places array
 * @return {*}
 */
PMActivity.prototype.makeBoundaryPlaces = function () {
    var bouX,
        bouY,
        factor = 3,
        space,
        number = 0,
        shape = this.boundaryArray.getFirst(),
        numBottom = 0,
        numLeft = 0,
        numTop = 0,
        numRight = 0;

    //BOTTON
    bouY = shape.parent.getHeight() - shape.getHeight() / 2; // Y is Constant
    bouX = shape.parent.getWidth() - (numBottom + 1) * (shape.getWidth() + factor);
    while (bouX + shape.getWidth() / 2 > 0) {
        space = {};
        space.x = bouX;
        space.y = bouY;
        space.available = true;
        space.number = number;
        space.location = 'BOTTOM';
        shape.parent.boundaryPlaces.insert(space);
        number += 1;
        numBottom += 1;
        bouX = shape.parent.getWidth() - (numBottom + 1) * (shape.getWidth() + factor);
    }

    //LEFT
    bouY = shape.parent.getHeight() - (numLeft + 1) * (shape.getHeight() + factor);
    bouX = -shape.getHeight() / 2;   // X is Constant
    while (bouY + shape.getHeight() / 2 > 0) {
        space = {};
        space.x = bouX;
        space.y = bouY;
        space.available = true;
        space.number = number;
        space.location = 'LEFT';
        shape.parent.boundaryPlaces.insert(space);
        number += 1;
        numLeft += 1;
        bouY = shape.parent.getHeight() - (numLeft + 1) * (shape.getHeight() + factor);
    }

    //TOP
    bouY = -shape.getWidth() / 2; // X is Constant
    bouX = numTop * (shape.getWidth() + factor);
    while (bouX + shape.getWidth() / 2 < shape.parent.getWidth()) {
        space = {};
        space.x = bouX;
        space.y = bouY;
        space.available = true;
        space.number = number;
        space.location = 'TOP';
        shape.parent.boundaryPlaces.insert(space);
        number += 1;
        numTop += 1;
        bouX = numTop * (shape.getWidth() + factor);
    }

    //RIGHT
    bouY = numRight * (shape.getHeight() + factor);
    bouX = shape.parent.getWidth() - shape.getWidth() / 2; // Y is Constant
    while (bouY + shape.getHeight() / 2 < shape.parent.getHeight()) {
        space = {};
        space.x = bouX;
        space.y = bouY;
        space.available = true;
        space.number = number;
        space.location = 'RIGHT';
        shape.parent.boundaryPlaces.insert(space);
        number += 1;
        numRight += 1;
        bouY = numRight * (shape.getHeight() + factor);
    }
    return this;
};

/**
 * Sets the boundary element to a selected boundary place
 * @param {PMEvent} shape
 * @param {Number} number
 * @return {*}
 */
PMActivity.prototype.setBoundary = function (shape, number) {
    var bouPlace = this.boundaryPlaces.get(number);
    bouPlace.available = false;
    shape.setPosition(bouPlace.x, bouPlace.y);
    return this;
};

/**
 * Returns the current place available to attach boundary events.
 * Retuns false if there's not place available
 * @return {Number/Boolean}
 */
PMActivity.prototype.getAvailableBoundaryPlace = function () {
    var place = 0,
        bouPlace,
        sw = true,
        i;
    for (i = 0; i < this.boundaryPlaces.getSize(); i += 1) {
        bouPlace = this.boundaryPlaces.get(i);
        if (bouPlace.available && sw) {
            place = bouPlace.number;
            sw = false;
        }
    }
    if (sw) {
        place = false;
    }
    return place;
};

/**
 * Update Boundary Places Array
 * @return {*}
 */
PMActivity.prototype.updateBoundaryPlaces = function () {
    var i,
        aux,
        k = 0;
    aux =  new PMUI.util.ArrayList();
    for (i = 0; i < this.boundaryPlaces.getSize(); i += 1) {
        aux.insert(this.boundaryPlaces.get(i));
    }

    this.boundaryPlaces.clear();
    this.makeBoundaryPlaces();

    for (i = 0; i < this.boundaryPlaces.getSize(); i += 1) {
        if (k < aux.getSize()) {
            this.boundaryPlaces.get(i).available = aux.get(k).available;
            k += 1;
        }
    }
    return this;
};

/**
 * Returns the number of boundary events attached to this activity
 * @return {Number}
 */
PMActivity.prototype.getNumberOfBoundaries = function () {
    var child,
        i,
        bouNum = 0;

    for (i = 0; i < this.getChildren().getSize(); i += 1) {
        child = this.getChildren().get(i);
        if (child.getType() === 'PMEvent' && child.evn_type === 'BOUNDARY') {
            bouNum = bouNum + 1;
        }
    }
    return bouNum;
};
/**
 * Updates boundary positions when exists a change into the boundary array
 * @param {Boolean} createIntersections
 */
PMActivity.prototype.updateBoundaryPositions = function (createIntersections) {
    var child,
        port,
        i,
        j;

    if (this.getNumberOfBoundaries() > 0) {

        this.updateBoundaryPlaces();
        for (i = 0; i < this.getChildren().getSize(); i += 1) {
            child = this.getChildren().get(i);
            if (child.getType() === 'PMEvent'
                && child.evn_type === 'BOUNDARY') {
                child.setPosition(this.boundaryPlaces.get(child.numberRelativeToActivity).x,
                    this.boundaryPlaces.get(child.numberRelativeToActivity).y
                );
                for (j = 0; j < child.ports.getSize(); j += 1) {
                    port = child.ports.get(j);
                    port.setPosition(port.x, port.y);
                    port.connection.disconnect().connect();
                    if (createIntersections) {
                        port.connection.setSegmentMoveHandlers();
                        port.connection.checkAndCreateIntersectionsWithAll();
                    }
                }
            }
        }
    }
};

PMActivity.prototype.getActivityType = function () {
    return this.act_type;
};

PMActivity.prototype.getContextMenu = function () {
};
PMActivity.prototype.getTaskType = function () {
    return this.act_task_type;
};

PMActivity.prototype.updateDefaultFlow = function (destID) {
    this.act_default_flow = destID;
    return this;
};

PMActivity.prototype.updateTaskType = function (newType) {
    return this;
};

PMActivity.prototype.updateScriptType = function (newType) {
    return this;
};


PMActivity.prototype.changeColor = function (newTheme) {
    switch (newTheme) {
        case 'red':
            newClass = 'mafe-activity-task-' + newTheme;
        break;
        case 'green':
            newClass = 'mafe-activity-task-' + newTheme;
        break;
        case 'orange':
            newClass = 'mafe-activity-task-' + newTheme;
        break;
        case 'silver':
            newClass = 'mafe-activity-task-' + newTheme;
        break;
        default:
            newClass = 'mafe-activity-task';
        break;
    
    }
    var firstLayer = this.getLayers().asArray()[0];
    //remove custom clasess
    firstLayer.style.removeClasses(['mafe-activity-task','mafe-activity-task-red', 'mafe-activity-task-green','mafe-activity-task-orange', 'mafe-activity-task-silver']);
    //add the new class
    firstLayer.style.addClasses([newClass]);
    return this;
};

PMActivity.prototype.setResizeBehavior = function (behavior) {
        var factory = new PMUI.behavior.BehaviorFactory({
                products: {
                    "regularresize": PMUI.behavior.RegularResizeBehavior,
                    "Resize": PMUI.behavior.RegularResizeBehavior,
                    "yes": PMUI.behavior.RegularResizeBehavior,
                    "resize": PMUI.behavior.RegularResizeBehavior,
                    "noresize": PMUI.behavior.NoResizeBehavior,
                    "NoResize": PMUI.behavior.NoResizeBehavior,
                    "no": PMUI.behavior.NoResizeBehavior,
                    "activityResize": PMActivityResizeBehavior
                },
                defaultProduct: "noresize"
            });
        this.resizeBehavior = factory.make(behavior);
        if (this.html) {
            this.resize.init(this);
        }
        return this;
};


/**
 * Change task type 
 * @param {String} type
 * @returns {*}
 */
PMActivity.prototype.switchTaskType= function(type){
    var marker = this.markersArray.get(0),
        lowerType = type.toLowerCase();
    marker.removeAllClasses();
    marker.setMarkerZoomClasses([
                                "mafe-" + lowerType + "-marker-10",
                                "mafe-" + lowerType + "-marker-15",
                                "mafe-" + lowerType + "-marker-21",
                                "mafe-" + lowerType + "-marker-26",
                                "mafe-" + lowerType + "-marker-31"
                            ]);
    marker.paint(true);
    this.setTaskType(type);

    this.updateBpmnTaskType(this.mapBpmnType[this.getTaskType()]);

    return this;
};

PMActivity.prototype.updateBpmnTaskType = function(newBpmnType) {
   this.removeBpmn();
   this.businessObject = null;
   this.createBpmn(newBpmnType);
};

PMActivity.prototype.getBpmnElementType = function () {
    if (this.extendedType === 'SUB_PROCESS') {
        return 'bpmn:SubProcess';
    } else {
        return this.mapBpmnType[this.getTaskType()];
    }

};
/**
 * @class PMGateway
 * @param {Object} options
 */
var PMGateway = function (options) {
    PMShape.call(this, options);
    /**
     * Gateway id
     * @type {String}
     */
    this.gat_uid = null;
    /**
     * Gateway name
     * @type {String}
     */
    this.gat_name = null;
    /**
     * Gateway type, accept only: 'exclusive' and 'parallel' values
     * @type {String}
     */
    this.gat_type = null;
    /**
     * Gateway Direction, accept only 'unspecified', 'converging', 'diverging',
     * 'mixed'
     * @type {String}
     */
    this.gat_direction = null;
    /**
     * Instantiate property
     * @type {String}
     */
    this.gat_instantiate = null;
    /**
     * Event Gatewat Type property
     * @type {String}
     */
    this.gat_event_gateway_type = null;
    /**
     * Activation Count property
     * @type {Number}
     */
    this.gat_activation_count = null;
    /**
     * WaitingForStart property
     * @type {Boolean}
     */
    this.gat_waiting_for_start = null;
    /**
     * Default Flow property
     * @type {null}
     */
    this.gat_default_flow = null;
    this.defaltFlowMenuItem = null;
    PMGateway.prototype.init.call(this, options);
};

PMGateway.prototype = new PMShape();
/**
 * Defines the object type
 * @type {String}
 */
PMGateway.prototype.type = 'PMGateway';
/**
 * Get data about object
 *
 */

PMGateway.prototype.mapBpmnType = {
    'EXCLUSIVE' : 'bpmn:ExclusiveGateway',
    'INCLUSIVE' : 'bpmn:InclusiveGateway',
    'PARALLEL' : 'bpmn:ParallelGateway',
    'COMPLEX' : 'bpmn:ComplexGateway',
    'EVENTBASED' : 'bpmn:EventBasedGateway'
    //'EXCLUSIVEEVENTBASED': 'bpmn:ExclusiveEventBasedGateway',
    //'PARALLELEVENTBASED' : 'bpmn:ParallelEventBasedGateway'
};

PMGateway.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        gat_uid: this.gat_uid,
        gat_name: name,
        gat_type: this.gat_type,
        gat_direction: this.gat_direction,
        gat_instantiate: this.gat_instantiate,
        gat_event_gateway_type: this.gat_event_gateway_type,
        gat_activation_count: this.gat_activation_count,
        gat_waiting_for_start: this.gat_waiting_for_start,
        gat_default_flow: this.gat_default_flow,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};
/**
 * Initialize the PMGateway object
 * @param options
 */
PMGateway.prototype.init = function (options) {
    var defaults = {
        gat_direction: 'DIVERGING',
        gat_instantiate: false,
        gat_event_gateway_type: 'NONE',
        gat_activation_count: 0,
        gat_waiting_for_start: true,
        gat_type: 'COMPLEX',
        gat_name: "Gateway",
        gat_default_flow: 0
    };
    jQuery.extend(true, defaults, options);
    this.setGatewayUid(defaults.gat_uid)
        .setGatewayType(defaults.gat_type)
        .setDirection(defaults.gat_direction)
        .setInstantiate(defaults.gat_instantiate)
        .setEventGatewayType(defaults.gat_event_gateway_type)
        .setActivationCount(defaults.gat_activation_count)
        .setWaitingForStart(defaults.gat_waiting_for_start)
        .setDefaultFlow(defaults.gat_default_flow);
    if (defaults.gat_name) {
        this.setName(defaults.gat_name);
    }
    this.setOnBeforeContextMenu(this.beforeContextMenu);
};

/**
 * Sets the Gateway ID
 * @param id
 * @return {*}
 */
PMGateway.prototype.setGatewayUid = function (id) {
    this.gat_uid = id;
    return this;
};
/**
 * Sets the label element
 * @param {String} value
 * @return {*}
 */
PMGateway.prototype.setName = function (name) {
    if (typeof name !== 'undefined') {
        this.gat_name = name;
        if (this.label) {
            this.label.setMessage(name);
        }
    }
    return this;
};
/**
 * Sets the gateway type
 * @param type
 * @return {*}
 */
PMGateway.prototype.setGatewayType = function (type) {
    type = type.toUpperCase();
    var defaultTypes = {
        COMPLEX: 'COMPLEX',
        EXCLUSIVE: 'EXCLUSIVE',
        PARALLEL: 'PARALLEL',
        INCLUSIVE: 'INCLUSIVE',
        EVENTBASED: 'EVENTBASED',
        EXCLUSIVEEVENTBASED: 'EXCLUSIVEEVENTBASED',
        PARALLELEVENTBASED: 'PARALLELEVENTBASED'

    };
    if (defaultTypes[type]) {
        this.gat_type = defaultTypes[type];
    }
    return this;
};
/**
 * Sets the Gateway direction
 * @param direction
 * @return {*}
 */
PMGateway.prototype.setDirection = function (direction) {
    direction = direction.toLowerCase();
    var defaultDir = {
        unspecified: 'UNSPECIFIED',
        diverging: 'DIVERGING',
        converging: 'CONVERGING',
        mixed: 'MIXED'
    };
    if (defaultDir[direction]) {
        this.gat_direction = defaultDir[direction];
    }
    return this;
};
/**
 * Sets the instantiate property
 * @param value
 * @return {*}
 */
PMGateway.prototype.setInstantiate = function (value) {
    this.gat_instantiate = value;
    return this;
};
/**
 * Sets the event_gateway_type property
 * @param value
 * @return {*}
 */
PMGateway.prototype.setEventGatewayType = function (value) {
    this.gat_event_gateway_type = value;
    return this;
};
/**
 * Sets the activation_count property
 * @param value
 * @return {*}
 */
PMGateway.prototype.setActivationCount = function (value) {
    this.gat_activation_count = value;
    return this;
};
/**
 * Sets the waiting_for_start property
 * @param value
 * @return {*}
 */
PMGateway.prototype.setWaitingForStart = function (value) {
    this.gat_waiting_for_start = value;
    return this;
};
/**
 * Sets te default_flow property
 * @param value
 * @return {*}
 */
PMGateway.prototype.setDefaultFlow = function (value) {
    if (this.html) {
        PMShape.prototype.setDefaultFlow.call(this, value);
        //this.canvas.triggerCommandAdam(this, ['gat_default_flow'],
        // [this.gat_default_flow], [value]);
    }
    this.gat_default_flow = value;
    return this;
};

PMGateway.prototype.getGatewayType = function () {
    return this.gat_type;
};


PMGateway.prototype.createConfigureAction = function () {

};

PMGateway.prototype.cleanFlowConditions = function () {
    var i, port, connection, oldValues;
    for (i = 0; i < this.getPorts().getSize(); i += 1) {
        port = this.getPorts().get(i);
        connection = port.connection;
        if (connection.srcPort.parent.getID() === this.getID()) {
            oldValues = {
                condition: connection.getFlowCondition(),
                type: connection.getFlowType()
            };
            connection.setFlowCondition('');
            connection.canvas
                .triggerFlowConditionChangeEvent(connection, oldValues);
        }
    }
};
PMGateway.prototype.updateGatewayType = function (newType) {

};

PMGateway.prototype.updateDirection = function (newDirection) {

};

PMGateway.prototype.updateDefaultFlow = function (destID) {

};

PMGateway.prototype.changeTypeTo = function (type) {
    var command = new CommandChangeGatewayType(this, type);
    this.canvas.commandStack.add(command);
    command.execute();
    return this;
};

/**
 * Sets te default_flow property
 * @param value
 * @return {*}
 */
PMGateway.prototype.setDefaultFlow = function (value) {
    if (this.html) {
        PMShape.prototype.setDefaultFlow.call(this, value);
        //this.canvas.triggerCommandAdam(this, ['gat_default_flow'],
        // [this.gat_default_flow], [value]);
    }
    this.gat_default_flow = value;
    return this;
};

PMGateway.prototype.beforeContextMenu = function () {
    var i, port, connection, shape, defaultflowItems = [], items, item, name,
        target, menuItem, hasMarker;

    items = this.menu.items.find('id', 'gatewaytype').childMenu.items;
    for (i = 0; i < items.getSize(); i += 1) {
        menuItem = items.get(i);
        if (menuItem.id === 'gateway' +
            this.getGatewayType().toLowerCase()) {
            menuItem.disable();
            hasMarker = true;
        } else {
            menuItem.enable();
        }
    }

    for (i = 0; i < this.getPorts().getSize(); i += 1) {
        port = this.getPorts().get(i);
        connection = port.connection;
        if (connection.srcPort.parent.getID() === this.getID()) {
            shape = connection.destPort.parent;
            switch (shape.getType()) {
            case 'PMActivity':
                name = (shape.getName() !== '') ? shape.getName() : 'Task'
                    .translate();
                break;
            case 'PMEvent':
                name = (shape.getName() !== '') ? shape.getName() : 'Event'
                    .translate();
                break;
            case 'PMGateway':
                name = (shape.getName() !== '') ? shape.getName() : 'Gateway'
                    .translate();
                break;
            }
            defaultflowItems.push(
                {
                    text: name,
                    //icon: "mafe-menu-edit-label-action",
                    id: connection.getID(),
                    disabled: (connection.getID() === this.gat_default_flow)
                        ? true : false,
                    onClick: function (menuOption) {
                        target = menuOption.getMenuTargetElement();
                        //target.setDefaultFlow(menuOption.id);
                        var cmd = new CommandDefaultFlow(target, menuOption.id);
                        cmd.execute();
                        target.canvas.commandStack.add(cmd);

                    }
                });

        }
    }

    if (this.defaltFlowMenuItem) {
        this.menu.removeItem('defaultflowMenu');
    }
    if (defaultflowItems.length > 0) {
        this.defaltFlowMenuItem = {
            id: 'defaultflowMenu',
            text: "Default Flow".translate(),
            items: defaultflowItems
        };
        this.menu.addItem(this.defaltFlowMenuItem);
    }

};

PMGateway.prototype.updateBpmGatewayType = function(newBpmnType) {
    this.removeBpmn();
    this.businessObject = null;
    this.createBpmn(newBpmnType);
};

var PMLine = function (options) {
    PMUI.draw.RegularShape.call(this, options);
    /**
     * Defines the type artifact
     * @type {String}
     */
    this.art_type = null;
    /**
     * Defines the unique identifier
     * @type {String}
     */
    this.art_uid = null;
	this.art_orientation = null;
    this.label = null;
    this.box = null;
    this.extended = null;
    this.extendedType = null;
    this.relationship = null;
    PMLine.prototype.init.call(this, options);
};
/**
 * Constant that represents that a drag behavior for moving the shape should be
 * used
 * @property {Number}
 */
PMLine.prototype = new PMUI.draw.RegularShape();

PMLine.prototype.type = "PMArtifact";
PMLine.prototype.family = "RegularShape";

PMLine.prototype.init = function (options) {
    var defaults = {
        art_orientation: "vertical",
        label: "",
        art_type: 'PMArtifact',
        art_name: "",
        art_uid: PMUI.generateUniqueId()
    };
    jQuery.extend(true, defaults, options);
    this.setOrientation(defaults.art_orientation)
        .setLabel(defaults.label)
        .setArtifactUid(defaults.art_uid)
        .setArtifactType(defaults.art_type)
        .setName(defaults.art_name);
};

PMLine.prototype.setOrientation = function (orientation) {
    var availableOpt, option;
    orientation = orientation.toLowerCase();
    availableOpt = {
        "vertical": "vertical",
        "horizontal": "horizontal"
    };
    option = (availableOpt[orientation]) ? orientation: "vertical";
    this.art_orientation = option;
    this.style.addClasses(["mafe-line-"+this.art_orientation]);
    //this.style.applyStyle();

    return this;
};
PMLine.prototype.setLabel = function (label) {

    return this;
};
/**
 * Sets the label element
 * @param {String} value
 * @return {*}
 */
PMLine.prototype.setName = function (value) {
    if (this.label) {
        this.label.setMessage(value);
    }
    return this;
};
/**
 * Returns the label text
 * @return {String}
 */
PMLine.prototype.getName = function () {
    var text = "";
    if (this.label) {
        text = this.label.getMessage();
    }
    return text;
};
PMLine.prototype.setExtendedType = function (type) {
    this.extendedType = type;
    return this;
};

PMLine.prototype.setRelationship = function (relationship) {
    this.relationship = relationship;
    return this;
};
PMLine.prototype.addRelationship = function (object) {
    if (typeof object === "object") {
        jQuery.extend(true, this.relationship, object);    
    }
    return this;
};
PMLine.prototype.setExtended = function (extended) {
    var ext;
    ext = (typeof extended === 'object')? extended : {};
    this.extended = ext;
    return this;
};

/**
 * Sets the artifact type property
 * @param {String} type
 * @return {*}
 */
PMLine.prototype.setArtifactType = function (type) {
    this.art_type = type;
    return this;
};
/**
 * Sets the artifact unique identifier
 * @param {String} value
 * @return {*}
 */
PMLine.prototype.setArtifactUid = function (value) {
    this.art_uid = value;
    return this;
};
PMLine.prototype.getExtendedObject = function () {
    this.extended = {
        extendedType: this.extendedType
    };
    return this.extended;
};
/**
 * Returns the clean object to be sent to the backend
 * @return {Object}
 */
PMLine.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        art_uid: this.art_uid,
        art_name: name,
        art_type: this.art_type,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};

PMLine.prototype.getArtifactType = function () {
    return this.art_type;
};

/**
 * @event mousedown
 * Moused down callback fired when the user mouse downs on the `shape`
 * @param {PMUI.draw.Shape} shape
 */
PMLine.prototype.onMouseDown = function (shape) {
    return function (e, ui) {
        e.stopPropagation();
    };
};

PMLine.prototype.createHTML = function () {
    var width = this.width || 20000, 
        height = this.height || 20000;
    PMUI.draw.RegularShape.prototype.createHTML.call(this);
    this.style.removeAllProperties();
    this.style.addProperties({
        position: "absolute",
        cursor: "move"
    });

    if (this.art_orientation === "vertical") {
        this.height = height;
        this.width = 5;
        this.style.addProperties({
            width: "5px",
            height: height+"px",
            top: -parseInt(height / 3, 10)
        });
    } else {
        this.width = width;
        this.height = 5;
        this.style.addProperties({
            width: width+"px",
            height: "5px",
            left: -parseInt(width / 3, 10)
        });
    }   

    return this.html;
};

var CustomLayer = function (options){
    PMUI.draw.Layer.call(this, options);

    this.tooltip =  null;
    this.listeners = {
        click: function(){}
    };
    
    CustomLayer.prototype.init.call(this, options);
};
CustomLayer.prototype = new PMUI.draw.Layer();

CustomLayer.prototype.type = "customLayer";

CustomLayer.prototype.init = function (options) {
    var defaults = {
        tooltip: "",
        listeners: {
            click: function(event, layer, shape) {}
        }   
    };
    jQuery.extend(true, defaults, options);
    
    this.setTooltipMessage(defaults.tooltip)
        .setListeners(defaults.listeners);
};
CustomLayer.prototype.setTooltipMessage = function (message) {
    if (typeof message === "string") {
        this.tooltip = message;
    }
    if (this.html) {
        jQuery(this.html).attr("title","");
        jQuery(this.html).tooltip({ content: this.tooltip, tooltipClass: "mafe-action-tooltip" });
    }
    return this;
};
CustomLayer.prototype.setListeners = function (events) {
    if (typeof events === "object") {
        this.listeners.click = events.click;
    }
    return this;
};
CustomLayer.prototype.createHTML = function (modifying) {
    this.setProperties();
    PMUI.draw.Layer.prototype.createHTML.call(this, modifying);
    this.setTooltipMessage();
    this.defineEvents();
    return this.html;
};
CustomLayer.prototype.defineEvents = function () {
    var that = this;

    jQuery(that.html).on("click", function(event){
        that.listeners.click(event, that, that.parent);
        event.stopPropagation();
    });
};
/**
 * @class PMArtifact
 * Handle BPMN Annotations
 *
 *
 * @constructor
 * Creates a new instance of the class
 * @param {Object} options
 */
var PMArtifact = function (options) {
    PMShape.call(this, options);
    /**
     * Defines the type artifact
     * @type {String}
     */
    this.art_type = null;
    /**
     * Defines the unique identifier
     * @type {String}
     */
    this.art_uid = null;

    PMArtifact.prototype.initObject.call(this, options);
};
PMArtifact.prototype = new PMShape();

/**
 * Defines the object type
 * @type {String}
 */
PMArtifact.prototype.type = "PMArtifact";
PMArtifact.prototype.PMArtifactResizeBehavior = null;

/**
 * Initialize the object with the default values
 * @param {Object} options
 */
PMArtifact.prototype.initObject = function (options) {
    var defaults = {
        art_type: 'TEXT_ANNOTATION',
        art_name: ""
    };

    jQuery.extend(true, defaults, options);
    this.setArtifactUid(defaults.art_uid);
    this.setArtifactType(defaults.art_type);
    this.setName(defaults.art_name);

};

/**
 * Sets the artifact type property
 * @param {String} type
 * @return {*}
 */
PMArtifact.prototype.setArtifactType = function (type) {
    this.art_type = type;
    return this;
};
/**
 * Sets the artifact unique identifier
 * @param {String} value
 * @return {*}
 */
PMArtifact.prototype.setArtifactUid = function (value) {
    this.art_uid = value;
    return this;
};
/**
 * Returns the clean object to be sent to the backend
 * @return {Object}
 */
PMArtifact.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        art_uid: this.id,
        art_name: name,
        art_type: this.art_type,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};

PMArtifact.prototype.getArtifactType = function () {
    return this.art_type;
};
PMArtifact.prototype.createLayer = function (options) {

    var layer;
    options.parent = this;
    layer = new CustomLayer(options);
    this.addLayer(layer);
    return layer;
};
PMArtifact.prototype.updateHTML = function () {
    var height, width;
    height = this.height;
    width = this.width;
    PMShape.prototype.updateHTML.call(this);
    this.setDimension(width, height);
    return this;
};

/**
 * Extends the paint method to draw text annotation lines
 */
PMArtifact.prototype.paint = function () {
    if (this.getArtifactType() === 'GROUP') {
        PMShape.prototype.paint.call(this);
    } else {
        if (!this.graphics || this.graphics === null) {
            this.graphics = new JSGraphics(this.id);
        } else {
            this.graphics.clear();
        }
        this.graphics.setStroke(1);
        this.graphics.drawLine(0, 0, 0, this.getZoomHeight());
        this.graphics.drawLine(0, 0, Math.round(this.getZoomWidth() * 0.25), 0);
        this.graphics.drawLine(0, this.getZoomHeight(), Math.round(this.getZoomWidth() * 0.25), this.getZoomHeight());
        this.graphics.paint();
        if (PMDesigner.project.loaded) {
            this.canvas.hideAllFocusLabels();
            this.label.getFocus();
        }
    }
};

PMArtifact.prototype.setResizeBehavior = function (behavior) {
    var factory = new PMUI.behavior.BehaviorFactory({
        products: {
            "regularresize": PMUI.behavior.RegularResizeBehavior,
            "Resize": PMUI.behavior.RegularResizeBehavior,
            "yes": PMUI.behavior.RegularResizeBehavior,
            "resize": PMUI.behavior.RegularResizeBehavior,
            "noresize": PMUI.behavior.NoResizeBehavior,
            "NoResize": PMUI.behavior.NoResizeBehavior,
            "no": PMUI.behavior.NoResizeBehavior,
            "annotationResize": PMArtifactResizeBehavior
        },
        defaultProduct: "noresize"
    });
    this.resizeBehavior = factory.make(behavior);
    if (this.html) {
        this.resize.init(this);
    }
    return this;
};

PMArtifact.prototype.createWithBpmn = function() {

    var bpmnElementType = this.getBpmnElementType();


    var businessObject = PMDesigner.bpmnFactory.create(bpmnElementType, {id: this.id, text: this.getName()});

    if (!businessObject.di) {
        if (this.type === 'Connection') {
            businessObject.di = PMDesigner.bpmnFactory.createDiEdge(businessObject, [], {
                id: businessObject.id + '_di'
            });
        } else {
            businessObject.di = PMDesigner.bpmnFactory.createDiShape(businessObject, {}, {
                id: businessObject.id + '_di'
            });
        }
    }
    this.businessObject = businessObject;

};
/**
 * Return an incremental name based of the type of the shape
 * @param {Object} pmCanvas The current canvas
 */
var IncrementNameCanvas = function (pmCanvas) {
    var random,
            elementsName = {
        TASK: "Task".translate(),
        SUB_PROCESS: "Sub-process".translate(),
        START: "Start Event".translate(),
        START_MESSAGE: "Start Message Event".translate(),
        START_TIMER: "Start Timer Event".translate(),
        END: "End Event".translate(),
        SELECTION: "Selection".translate(),
        EVALUATION: "Evaluation".translate(),
        PARALLEL: "Parallel Gateway".translate(),
        INCLUSIVE: "Inclusive Gateway".translate(),
        EXCLUSIVE: "Exlusive Gateway".translate(),
        PARALLEL_EVALUATION: "Parallel by Evaluation".translate(),
        PARALLEL_JOIN: "Parallel Join".translate(),
        TEXT_ANNOTATION: "Annotation".translate(),
        VERTICAL_LINE: "Vertical line".translate(),
        HORIZONTAL_LINE: "Horizontal line".translate(),
        H_LABEL: "Horizontal Text".translate(),
        V_LABEL: "Vertical Text".translate(),
        DATASTORE: "Data Store".translate(),
        DATAOBJECT: "Data Object".translate(),
        PARTICIPANT: "Black Box Pool".translate(),
        POOL: "Pool".translate(),
        INTERMEDIATE_SENDMESSAGE: "Intermediate Send Message Event".translate(),
        INTERMEDIATE_RECEIVEMESSAGE: "Intermediate Receive Message Event".translate(),
        LANE: "Lane".translate(),
        GROUP: "Group".translate()
    };
    random = false;
    return {
        id: Math.random(),
        get: function (type) {
            var i,
                    j,
                    k = pmCanvas.getCustomShapes().getSize(),
                    exists,
                    index = 1;
            for (i = 0; i < k; i += 1) {
                exists = false;
                for (j = 0; j < k; j += 1) {
                    if (pmCanvas.getCustomShapes().get(j).getName() === elementsName[type] + " # " + (i + 1)) {
                        exists = true;
                        break;
                    }
                }
                if (!exists) {
                    break;
                }
            }

            return elementsName[type] + " # " + (i + 1);
        }
    };
};

var autoResizeScreen = function () {
    var myWidth = 0, myHeight = 0;
    if (typeof(window.innerWidth) === 'number') {
        //No-IE
        myWidth = window.innerWidth;
        myHeight = window.innerHeight;
    } else if (document.documentElement &&
            (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
        //IE 6+
        myWidth = document.documentElement.clientWidth;
        myHeight = document.documentElement.clientHeight;
    } else if (document.body &&
            (document.body.clientWidth || document.body.clientHeight)) {
        //IE 4 compatible
        myWidth = document.body.clientWidth;
        myHeight = document.body.clientHeight;
    }
    return myWidth;
};

var showUID = function (id) {
    var messageWindow = new PMUI.ui.MessageWindow({
        width: 490,
        bodyHeight: 'auto',
        id: 'showMessageWindowUID',
        windowMessageType: 'warning',
        message: id,
        footerItems: [
            {
                text: 'Ok'.translate(),
                height: 40,
                handler: function ()
                {
                    messageWindow.close();
                }
            }
        ]
    });
    messageWindow.setTitle("ID".translate());
    messageWindow.open();
    messageWindow.showFooter();
    $(messageWindow.dom.icon).removeClass();
};

var applyStyleWindowForm = function (win) {
    $(win.body).removeClass("pmui-background");
    win.footer.html.style.textAlign = 'right';
    (function searchForm (items) {
        var i;
        for (i = 0; i < items.length; i += 1) {
            if (items[i].footer && items[i].footer.setVisible) {
                $(win.body).addClass("pmui-background");
                items[i].footer.setVisible(false);
            }
            searchForm(items[i].getItems ? items[i].getItems() :
                    (items[i].getPanel ? items[i].getPanel().getItems() : []));
        }
    }(win.getItems()));
};

var QuickMessageWindow = function (html, message) {
    if (html === undefined) {
        return;
    }
    QuickMessageWindow.prototype.show.call(this, html, message);
};
QuickMessageWindow.prototype.show = function (html, message) {
    var that = this;
    var factorX = 25;
    var factorY = 20;
    if ($('#tooltipmessagecustom')[0]) {
        $('#tooltipmessagecustom').css({
            'top': $(html).offset().top + factorY,
            'left': $(html).offset().left + factorX
        });
        $('#tooltipmessagecustombody').html(message);
    } else {
        var button = $('<div></div>')
                .css({'cursor': 'pointer', 'float': 'right'})
                .append($('<a></a>')
                .html('X')
                .on('click', function () {
            $('#tooltipmessagecustom').remove();
        }));
        $('body').append($('<div></div>')
                .append(button)
                .append($('<div></div>')
                .attr('id', 'tooltipmessagecustombody')
                .css({'float': 'left'})
                .html(message))
                .addClass('pmui pmui-pmtooltipmessage')
                .attr('id', 'tooltipmessagecustom')
                .css({
            'box-sizing': 'border-box', 'position': 'absolute',
            'background-color': '#EEF1F6', 'width': '200px', 'min-height': '150px',
            'z-index': '100', 'padding': '10px 10px 10px 10px', 'font-size': '10',
            'top': $(html).offset().top + factorY,
            'left': $(html).offset().left + factorX
        })).on('mousedown', function (evt) {
            that.closeEvent(evt);
        }).on('click', function (evt) {
            that.closeEvent(evt);
        }).on('mouseup', function (evt) {
            that.closeEvent(evt);
        });
        $(window).scroll(function () {
            that.close();
        });
    }
};
QuickMessageWindow.prototype.close = function () {
    $('#tooltipmessagecustom').remove();
};
QuickMessageWindow.prototype.closeEvent = function (evt) {
    var element = evt.target || evt.srcElement;
    if ($('#tooltipmessagecustom')[0] && element !== $('#tooltipmessagecustom')[0] && element !== $('#tooltipmessagecustom')[0].children[1]) {
        $('#tooltipmessagecustom').remove();
    }
};

var ButtonFormPanel = function (options) {
    options.labelVisible = false;
    this.onclick = options.onclick;
    this.parameter = options.parameter;
    PMUI.field.TextField.call(this, options);
    ButtonFormPanel.prototype.init.call(this, options);
};
ButtonFormPanel.prototype = new PMUI.field.TextField();
ButtonFormPanel.prototype.init = function (options) {
    var defaults = {};
    jQuery.extend(true, defaults, options);
};
ButtonFormPanel.prototype.createHTML = function () {
    PMUI.field.TextField.prototype.createHTML.call(this);
    var that = this, button = new PMUI.ui.Button({
        id: this.id,
        text: this.getLabel(),
        handler: function () {
            that.onclick(that);
        }
    });
    this.dom.controlContainer.appendChild(button.getHTML());
    this.dom.controlContainer.getElementsByTagName('input')[0].style.display = 'none';
    button.defineEvents();
    this.button = button;
    return this.html;
};

var LabelFormPanel = function (options) {
    PMUI.field.TextField.call(this, options);
    LabelFormPanel.prototype.init.call(this, options);
};
LabelFormPanel.prototype = new PMUI.field.TextField();
LabelFormPanel.prototype.init = function (options) {
    var defaults = {};
    jQuery.extend(true, defaults, options);
};
LabelFormPanel.prototype.createHTML = function () {
    PMUI.field.TextField.prototype.createHTML.call(this);
    this.dom.controlContainer.getElementsByTagName('input')[0].style.display = 'none';
    return this.html;
};

var messagePageGrid = function (currentPage, pageSize, numberItems, criteria, filter) {
    if (numberItems === 0) {
        return '';
    }
    var msg = 'Page'.translate() + ' ' + (currentPage + 1) + ' ' + 'of'.translate() + ' ' + Math.ceil(numberItems / pageSize);
    return msg;
};

/*
 * Function: validateKeysField
 * valid characteres for file name:
 * http://support.microsoft.com/kb/177506/es
 * 
 * (A-z)letter
 * (0-9)number
 *  ^   Accent circumflex (caret)
 *  &   Ampersand
 *  '   Apostrophe (single quotation mark)
 *  @   At sign
 *  {   Brace left
 *  }   Brace right
 *  [   Bracket opening
 *  ]   Bracket closing
 *  ,   Comma
 *  $   Dollar sign
 *  =   Equal sign
 *  !   Exclamation point
 *  -   Hyphen
 *  #   Number sign
 *  (   Parenthesis opening
 *  )   Parenthesis closing
 *  %   Percent
 *  .   Period
 *  +   Plus
 *  ~   Tilde
 *  _   Underscore
 *  
 *  Example: only backspace, number and letter.
 *  validateKeysField(objectHtmlInput, ['isbackspace', 'isnumber', 'isletter']);
 *  
 *  Aditional support:
 *  :   Colon
 *  
 */
var validateKeysField = function (object, validates) {
    object.onkeypress = function (e) {
        var key = document.all ? e.keyCode : e.which;
        if (key === 0)
            return true;
        var isbackspace = key === 8;
        var isnumber = key > 47 && key < 58;
        var isletter = (key > 96 && key < 123) || (key > 64 && key < 91);
        var isaccentcircumflex = key === 94;
        var isampersand = key === 41;
        var isapostrophe = key === 145;
        var isatsign = key === 64;
        var isbraceleft = key === 123;
        var isbraceright = key === 125;
        var isbracketopening = key === 91;
        var isbracketclosing = key === 93;
        var iscomma = key === 130;
        var isdollarsign = key === 36;
        var isequalsign = key === 61;
        var isexclamationpoint = key === 33;
        var ishyphen = key === 45;
        var isnumbersign = key === 35;
        var isparenthesisopening = key === 40;
        var isparenthesisclosing = key === 41;
        var ispercent = key === 37;
        var isperiod = key === 46;
        var isplus = key === 43;
        var istilde = key === 126;
        var isunderscore = key === 95;
        var iscolon = key === 58;

        var sw = eval(validates[0]);
        for (var i = 1; i < validates.length; i++) {
            sw = sw || eval(validates[i]);
        }
        return sw;
    };
};

var applyStyleTreePanel = function (treePanel, fontStyle) {
    if (fontStyle !== false) {
        $(treePanel.getHTML()).find('a').css('font-weight', 'bold');
        $(treePanel.getHTML()).find('a').css('color', 'black');
        $(treePanel.getHTML()).find('ul li ul li>a').css('font-weight', 'normal');
        $(treePanel.getHTML()).find('ul li ul li>a').css('color', 'black');
    }
};

/*
 * Convert time format HH:MM:SS to decimal value.
 */
var timeToDecimal = function (value) {
    var s = value.toString().replace(/\s/g, '').split(':');
    var hour = parseInt(s[0]) || 0;
    var min = parseInt(s[1]) || 1;
    var sec = parseInt(s[2]) || 1;
    return (hour + min / 60 + sec / 3600);
};

/*
 * Convert decimal to time format HH:MM:SS.
 */
var decimalToTime = function (value, second) {
    var num = typeof value === 'number' ? value : 1;

    var hour = parseInt(num);
    num = num - parseInt(num);
    num = num.toFixed(13);
    num = num * 60;

    var min = parseInt(num);
    num = num - parseInt(num);
    num = num.toFixed(13);
    num = num * 60;

    var sec = parseInt(num);

    hour = hour.toString().length === 1 ? '0' + hour : hour;
    min = min.toString().length === 1 ? '0' + min : min;
    sec = sec.toString().length === 1 ? '0' + sec : sec;

    return second === true ? hour + ':' + min + ':' + sec : hour + ':' + min;
};

/**
 * 
 * @type type
 */var Mafe = {};

/**
 * 
 * @param {type} settings
 * @returns {undefined}
 */
Mafe.Window = function (settings) {
    this.views = [];
    PMUI.ui.Window.call(this, settings);
    Mafe.Window.prototype.init.call(this, settings);
};
Mafe.Window.prototype = new PMUI.ui.Window();
Mafe.Window.prototype.init = function (settings) {
    this.setHeight(DEFAULT_WINDOW_HEIGHT);
    this.setWidth(DEFAULT_WINDOW_WIDTH);
    this.hideFooter();
    this.setButtonPanelPosition('top');
};
Mafe.Window.prototype.createHTML = function () {
    PMUI.ui.Window.prototype.createHTML.call(this);
//    applyStyleWindowForm(this);
    this.footer.html.style.textAlign = 'right';
    return this.html;
};
Mafe.Window.prototype.resetView = function () {
    this.hideFooter();
    var items = this.items.asArray();
    for (var i = 0; i < items.length; i++) {
        if (items[i].setVisible) {
            items[i].setVisible(false);
        }
        if (items[i].reset) {
            items[i].reset();
        }
    }
};
Mafe.Window.prototype.setButtons = function (buttons) {
    this.clearFooterItems();
    this.setFooterItems(buttons);
    this.showFooter();
};

/**
 * 
 * @param {type} settings
 * @returns {undefined}
 */
Mafe.Grid = function (settings) {
    var defaults = {
        pageSize: 10,
        width: '96%',
        filterPlaceholder: 'Text to Search'.translate(),
        emptyMessage: 'No records found'.translate(),
        nextLabel: 'Next'.translate(),
        previousLabel: 'Previous'.translate(),
        style: {cssClasses: ['mafe-gridPanel']},
        customStatusBar: function (currentPage, pageSize, numberItems, criteria, filter) {
            return messagePageGrid(currentPage, pageSize, numberItems, criteria, filter);
        }
    };
    jQuery.extend(true, defaults, settings);
    PMUI.grid.GridPanel.call(this, defaults);
    Mafe.Grid.prototype.init.call(this, defaults);
};
Mafe.Grid.prototype = new PMUI.grid.GridPanel();
Mafe.Grid.prototype.init = function (settings) {
    var defaults = {};
    jQuery.extend(true, defaults, settings);
};
Mafe.Grid.prototype.createHTML = function () {
    PMUI.grid.GridPanel.prototype.createHTML.call(this);
    $(this.html).find('.pmui-textcontrol').css({'margin-top': '5px', width: '250px'});
    return this.html;
};

/**
 * 
 * @param {type} settings
 * @returns {undefined}
 */
Mafe.Form = function (settings) {
    this.onYesConfirmCancellation = new Function();
    var defaults = {
        width: DEFAULT_WINDOW_WIDTH - 3,
        height: 'auto'
    };
    jQuery.extend(true, defaults, settings);
    PMUI.form.Form.call(this, defaults);
    Mafe.Form.prototype.init.call(this);
};
Mafe.Form.prototype = new PMUI.form.Form();
Mafe.Form.prototype.init = function (settings) {
    var defaults = {};
    jQuery.extend(true, defaults, settings);
};
Mafe.Form.prototype.getConfirmCancellationToLoseChanges = function () {
    return this.confirmCancellationToLoseChanges;
};
Mafe.Form.prototype.loseChanges = function () {
    var that = this;
    if (that.isDirty()) {
        var confirmCancellation = new Mafe.ConfirmCancellation();
        confirmCancellation.onYes = function () {
            that.onYesConfirmCancellation();
        };
    } else {
        that.onYesConfirmCancellation();
    }
};

/**
 * 
 * @returns {undefined}
 */
Mafe.ConfirmDeletion = function () {
    var that = this;
    that.onDelete = new Function();
    that.onCancel = new Function();
    var defaults = {
        id: 'idConfirmDeletion',
        width: 490,
        bodyHeight: 'auto',
        windowMessageType: 'error',
        message: 'Do you want to delete this Element?'.translate(),
        footerItems: [{
                id: 'idDeleteConfirmDeletion',
                text: 'Delete'.translate(),
                visible: true,
                height: 40,
                handler: function () {
                    that.onDelete();
                    that.close();
                }
            }, {
                pmType: 'label',
                text: 'or'.translate()
            }, {
                id: 'idCancelConfirmDeletion',
                text: 'Cancel'.translate(),
                buttonType: 'link',
                visible: true,
                handler: function () {
                    that.onCancel();
                    that.close();
                }
            }
        ]
    };
    PMUI.ui.MessageWindow.call(this, defaults);
    Mafe.ConfirmDeletion.prototype.init.call(this);
};
Mafe.ConfirmDeletion.prototype = new PMUI.ui.MessageWindow();
Mafe.ConfirmDeletion.prototype.init = function () {
    this.open();
    this.showFooter();
};

/**
 * 
 * @returns {undefined}
 */
Mafe.ConfirmCancellation = function () {
    var that = this;
    that.onYes = new Function();
    that.onNo = new Function();
    var defaults = {
        id: 'idConfirmCancellation',
        title: 'Confirm'.translate(),
        width: 490,
        bodyHeight: 'auto',
        windowMessageType: 'warning',
        message: 'Do you want to cancel this action? All your changes will be lost if you cancel it.'.translate(),
        footerItems: [{
                id: 'idDeleteConfirmCancellation',
                text: 'Yes'.translate(),
                visible: true,
                height: 40,
                handler: function () {
                    that.onYes();
                    that.close();
                }
            }, {
                pmType: 'label',
                text: 'or'.translate()
            }, {
                id: 'idCancelConfirmCancellation',
                text: 'No'.translate(),
                buttonType: 'link',
                visible: true,
                handler: function () {
                    that.onNo();
                    that.close();
                }
            }
        ]
    };
    PMUI.ui.MessageWindow.call(this, defaults);
    Mafe.ConfirmCancellation.prototype.init.call(this);
};
Mafe.ConfirmCancellation.prototype = new PMUI.ui.MessageWindow();
Mafe.ConfirmCancellation.prototype.init = function () {
    this.open();
    this.showFooter();
};

/**
 * 
 * @param {type} settings
 * @returns {undefined}
 */
Mafe.Tree = function (settings) {
    if (settings && settings.width) {
        this._width = settings.width;
    } else {
        this._width = 210;
    }
    var defaults = {
        id: 'idMafeTree',
        filterable: true,
        filterPlaceholder: 'Text to Search'.translate(),
        emptyMessage: 'No records found'.translate(),
//        behavior: 'dragclone',
        autoBind: true,
        nodeDefaultSettings: {
            autoBind: true,
//            behavior: 'drag',
            collapsed: false,
            labelDataBind: 'labelDataBind',
            itemsDataBind: 'itemsDataBind',
            childrenDefaultSettings: {
                labelDataBind: 'labelDataBind',
                autoBind: true
            }
        }
    };
    jQuery.extend(true, defaults, settings);
    PMUI.panel.TreePanel.call(this, defaults);
    Mafe.Tree.prototype.init.call(this, defaults);
};
Mafe.Tree.prototype = new PMUI.panel.TreePanel();
Mafe.Tree.prototype.init = function (defaults) {
    var that = this;
    that.style.addProperties({overflow: 'auto'});
};
Mafe.Tree.prototype.createHTML = function () {
    PMUI.panel.TreePanel.prototype.createHTML.call(this);
    this.setWidth(this._width);
    return this.html;
};

/**
 * 
 * @param {type} settings
 * @returns {undefined}
 */
Mafe.Accordion = function (settings) {
    if (settings && settings.width) {
        this._width = settings.width;
    }
    var defaults = {
        id: 'idAccordion',
        hiddenTitle: true,
        heightItem: 'auto',
        title: '',
        multipleSelection: true,
        listeners: {
            select: function (accordionItem, event) {
            }
        }
    };
    jQuery.extend(true, defaults, settings);
    PMUI.panel.AccordionPanel.call(this, defaults);
    Mafe.Accordion.prototype.init.call(this);
};
Mafe.Accordion.prototype = new PMUI.panel.AccordionPanel();
Mafe.Accordion.prototype.init = function () {
    var that = this;
    that.style.addProperties({'vertical-align': 'top'});
};
Mafe.Accordion.prototype.createHTML = function () {
    PMUI.panel.AccordionPanel.prototype.createHTML.call(this);
    this.setWidth(this._width);
    return this.html;
};

'use strict';

/**
 * Failsafe remove an element from a collection
 *
 * @param  {Array<Object>} [collection]
 * @param  {Object} [element]
 *
 * @return {Object} the element that got removed or undefined
 */
var CollectionRemove = function(collection, element) {

    if (!collection || !element) {
        return;
    }

    var idx = collection.indexOf(element);
    if (idx === -1) {
        return;
    }

    collection.splice(idx, 1);

    return element;
};

function setEncoded(link, name, data) {
    var encodedData = encodeURIComponent(data);

    if (data) {
        link.addClass('active').attr({
            'href': 'data:application/bpmn20-xml;charset=UTF-8,' + encodedData,
            'download': name
        });
    } else {
        link.removeClass('active');
    }
}

/**
 * FullScreen class
 */
var FullScreen = function(options) {
    this.element = null;
    this.onReadyScreen = null;
    this.onCancelScreen = null;
    FullScreen.prototype.init.call(this, options);
};
/**
 * [init description]
 * @param  {Object} options Config options
 */
FullScreen.prototype.init = function(options) {
    var defaults = {
        element: document.documentElement,
        onReadyScreen: function(){},
        onCancelScreen: function(){}
    };
    jQuery.extend(true, defaults, options);
    this.element = defaults.element;
    this.onReadyScreen = defaults.onReadyScreen;
    this.onCancelScreen = defaults.onCancelScreen;
};
FullScreen.prototype.cancel = function () {
    var requestMethod,fnCancelScreen, wscript, el;
    if (parent.document.documentElement === document.documentElement) {
        el = document;
    } else {
        el = parent.document;
    }
    requestMethod = el.cancelFullScreen || 
                    el.webkitCancelFullScreen || 
                    el.mozCancelFullScreen || 
                    el.exitFullscreen;
    if (requestMethod) {
        requestMethod.call(el);
        try {
            fnCancelScreen = this.onCancelScreen;
            fnCancelScreen(el);
        } catch (e) {
            throw new Error(e);
        }
    } else if (typeof window.ActiveXObject !== "undefined") { // Older IE.
        wscript = new ActiveXObject("WScript.Shell");
        if (wscript !== null) {
            wscript.SendKeys("{F11}");
        }
    }
};

FullScreen.prototype.applyZoom = function () {
    var requestMethod, wscript, fnReadyScreen, el = this.element;
    requestMethod = el.requestFullScreen || 
                    el.webkitRequestFullScreen || 
                    el.mozRequestFullScreen || 
                    el.msRequestFullScreen;

    if (requestMethod) {
        requestMethod.call(el); 
        try {
            fnReadyScreen = this.onReadyScreen;
            fnReadyScreen(el);
        } catch (e) {
            throw new Error(e);
        }
    } else if (typeof window.ActiveXObject !== "undefined") {
        wscript = new ActiveXObject("WScript.Shell");
        if (wscript !== null) {
            wscript.SendKeys("{F11}");
        }
    }
    return false
};
FullScreen.prototype.toggle = function () {
    var el, isInFullScreen;
    if (parent.document.documentElement === document.documentElement) {
        el = document;
    } else {
        el = parent.document;
    }
    isInFullScreen = (el.fullScreenElement && el.fullScreenElement !== null) ||  (el.mozFullScreen || el.webkitIsFullScreen);
    if (isInFullScreen) {
        this.cancel();
    } else {
        this.applyZoom();
    }
    return false;
};

var PMIframe = function (settings) {
	PMUI.core.Element.call(this, settings);

    this.src = null;
    this.name = null;
    this.scrolling = null;
    this.frameborder = null;
    this.errorMessage = null;
    this.data = null;

    PMIframe.prototype.init.call(this, settings);
};

PMIframe.prototype = new PMUI.core.Element();

PMIframe.prototype.type = "PMPMIframe";

PMIframe.prototype.family = 'PMPMIframe';

PMIframe.prototype.init = function (settings) {
    var defaults = {
    	src: "",
    	name: "",
        width:  770,
        height: 305,
        scrolling: 'no',
        frameborder: "0"
    };

    jQuery.extend(true, defaults, settings);

    this.setSrc(defaults.src)
        .setName(defaults.name)
        .setWidth(defaults.width)
        .setHeight(defaults.height)
        .setScrolling(defaults.scrolling)
        .setFrameborder(defaults.frameborder);
};

PMIframe.prototype.setSrc = function (src){
    this.src = src;
    return this;
};
PMIframe.prototype.setName = function (name){
    this.name = name;
    return this;
};
PMIframe.prototype.setScrolling = function (scrolling){
    this.scrolling = scrolling;
    return this;
};
PMIframe.prototype.setFrameborder = function (frameborder){
    this.frameborder = frameborder;
    return this;
};


PMIframe.prototype.createHTML = function (){
    var input;

    if(this.html){
        return this.html;
    }

    input = PMUI.createHTMLElement("iframe");
    input.className = "PMIframeWin";
    input.id = this.id;
    input.name = "PMIframeWindow";
    input.src = this.src;
    
    this.html = input;
    this.applyStyle();
    return this.html;
};


var PMTiny = function (options) {
    PMUI.control.HTMLControl.call(this, options);

    this.theme = null;
    this.plugins = null;
    this.mode = null;
    this.editorSelector = null;
    this.widthTiny = null;
    this.heightTiny = null;
    this.directionality = null;
    this.verifyHtml = null;
    this.themeAdvancedButtons1 = null;
    this.themeAdvancedButtons2 = null;
    this.popupCss = null;
    this.skin = null;
    this.skinVariant = null;
    this.processID = null;
    this.domainURL = null;
    this.baseURL = null;

    PMTiny.prototype.init.call(this, options);
};

PMTiny.prototype = new PMUI.control.HTMLControl();

PMTiny.prototype.type = "PMTiny";
PMTiny.prototype.family = 'PMCodeMirrorControl';

PMTiny.prototype.init = function (options) {
    var defaults = {
        theme: "advanced",
        plugins: "advhr,advimage,advlink,advlist,autolink,autoresize,contextmenu,directionality,emotions,example,example_dependency,fullpage,fullscreen,iespell,inlinepopups,insertdatetime,layer,legacyoutput,lists,media,nonbreaking,noneditable,pagebreak,paste,preview,print,save,searchreplace,style,tabfocus,table,template,visualblocks,visualchars,wordcount,xhtmlxtras,pmSimpleUploader,pmVariablePicker,pmGrids,style",
        mode: "specific_textareas",
        editorSelector: "tmceEditor",
        widthTiny:  DEFAULT_WINDOW_WIDTH-60,
        heightTiny: DEFAULT_WINDOW_HEIGHT-100,
        directionality: 'ltr',
        verifyHtml: false,
        themeAdvancedButtons1: "pmSimpleUploader,|,pmVariablePicker,|,pmGrids,|,bold,italic,underline,|,justifyleft,justifycenter,justifyright,justifyfull,|,fontselect,fontsizeselect,|,cut,copy,paste,|,bullist,numlist,|,outdent,indent,blockquote",
        themeAdvancedButtons2: "tablecontrols,|,undo,redo,|,link,unlink,image,|,forecolor,backcolor,styleprops,|,hr,removeformat,visualaid,|,sub,sup,|,ltr,rtl,|,code",
        popupCss : "/js/tinymce/jscripts/tiny_mce/themes/advanced/skins/default/dialog.css",
        skin : "o2k7",
        skinVariant : "silver",
        processID:null,
        domainURL:"/sys"+ WORKSPACE +"/"+LANG+"/"+SKIN+"/",
        baseURL:"/js/tinymce/jscripts/tiny_mce"
    };

    jQuery.extend(true, defaults, options);

    this.setTheme(defaults.theme)
        .setPlugins(defaults.plugins)
        .setMode(defaults.mode)
        .setEditorSelector(defaults.editorSelector)
        .setDirectionality(defaults.directionality)
        .setVerifyHtml(defaults.verifyHtml)
        .setThemeAdvancedButtons1(defaults.themeAdvancedButtons1)
        .setThemeAdvancedButtons2(defaults.themeAdvancedButtons2)
        .setPopupCss(defaults.popupCss)
        .setSkin(defaults.skin)
        .setSkinVariant(defaults.skinVariant)
        .setProcessID(defaults.processID)
        .setDomainURL(defaults.domainURL)
        .setBaseURL(defaults.baseURL)
        .setHeightTiny(defaults.heightTiny)
        .setWidthTiny(defaults.widthTiny);
};

PMTiny.prototype.setTheme = function (theme){
    this.theme = theme;
    return this;
};
PMTiny.prototype.setPlugins = function (plugins){
    this.plugins = plugins;
    return this;
};
PMTiny.prototype.setMode = function (mode){
    this.mode = mode;
    return this;
};
PMTiny.prototype.setEditorSelector = function (editorSelector){
    this.editorSelector = editorSelector;
    return this;
};
PMTiny.prototype.setDirectionality = function (directionality){
    this.directionality = directionality;
    return this;
};
PMTiny.prototype.setVerifyHtml = function (verifyHtml){
    this.verifyHtml = verifyHtml;
    return this;
};
PMTiny.prototype.setThemeAdvancedButtons1 = function (themeAdvancedButtons1){
    this.themeAdvancedButtons1 = themeAdvancedButtons1;
    return this;
};
PMTiny.prototype.setThemeAdvancedButtons2 = function (themeAdvancedButtons2){
    this.themeAdvancedButtons2 = themeAdvancedButtons2;
    return this;
};
PMTiny.prototype.setPopupCss = function (popupCss){
    this.popupCss = popupCss;
    return this;
};
PMTiny.prototype.setSkin = function (skin){
    this.skin = skin;
    return this;
};
PMTiny.prototype.setSkinVariant = function (skinVariant){
    this.skinVariant = skinVariant;
    return this;
};
PMTiny.prototype.setProcessID = function (processID){
    this.processID = processID;
    return this;
};
PMTiny.prototype.setDomainURL = function (domainURL){
    this.domainURL = domainURL;
    return this;
};
PMTiny.prototype.setBaseURL = function (baseURL){
    this.baseURL = baseURL;
    return this;
};
PMTiny.prototype.setWidthTiny = function (widthTiny){
    this.widthTiny = widthTiny;
    return this;
};
PMTiny.prototype.setHeightTiny = function (heightTiny){
    this.heightTiny = heightTiny;
    return this;
};


PMTiny.prototype.setParameterTiny = function (){
    var that = this;
    tinyMCE.baseURL = this.baseURL;
    var domainURL   = this.domainURL;
    //$serverConf =& serverConf::getSingleton();
    //var formProcessID = document.getElementById("form[PRO_UID]").value;
    tinyMCE.init({
        theme: this.theme,
        plugins: this.plugins,
        mode: this.mode,
        editor_selector: this.editorSelector,
        width:  this.widthTiny,
        height: this.heightTiny,
        directionality: this.directionality,
        //"' . ($serverConf->isRtl(SYS_LANG) ? 'rtl' : 'ltr') . '",
        verify_html: this.verifyHtml,
        theme_advanced_buttons1: this.themeAdvancedButtons1,
        theme_advanced_buttons2: this.themeAdvancedButtons2,
        popup_css : this.popupCss,
        skin : this.skin,
        skin_variant : this.skinVariant,
        oninit: function () {
            tinyMCE.activeEditor.processID = PMDesigner.project.id;
            tinyMCE.activeEditor.domainURL = domainURL;
            //added the tinyeditor reference to the PMUI control
            that.controlEditor = tinyMCE.activeEditor;
            tinyMCE.execCommand('mceFocus',false,'tinyeditor');
        },
        onchange_callback: function(inst) {
            that.onChangeHandler();
            if(inst.isDirty()) {
                inst.save();
            }
            return true;
        },
        handle_event_callback : function(e) {
            if(this.isDirty()) {
                this.save();
            }
            return true;
        }
    });
};

PMTiny.prototype.createHTML = function (){
    var input;

    if (this.html) {
        return this.html;
    }

    input = PMUI.createHTMLElement("textArea");
    input.className = "tmceEditor";
    input.id = "tinyeditor";
    input.name = "tinyeditor";
    input.width = this.width;
    input.height = this.height;

    this.html = input;
    return this.html;
};

PMTiny.prototype.setValueTiny = function (value){
    if (this.html) {
        if (this.html.id) {
            $('#' + this.html.id + '_ifr').height ('100%');
        }
        if (this.controlEditor) {
            this.controlEditor.setContent(value);
        }
    }

    return this;
};

PMTiny.prototype.getValue = function (value){
    if (this.html) {
        if (this.controlEditor) {
            return this.controlEditor.getContent(value);
        }
    }

    return '';
};

PMTiny.prototype.setVisible = function (visible) {
    visible = !!visible;
    this.visible = visible;

    if (this.html) {
        if (this.html.id) {
            if (visible) {
                $('#' + this.html.id + '_tbl').css("display", "block");
            } else {
                $('#' + this.html.id + '_tbl').css("display", "none");
            }
        }
    }

    return this;
};



var PMTinyField = function (settings) {
    PMUI.form.Field.call(this, settings);
    PMTinyField.prototype.init.call(this, settings);
};

PMTinyField.prototype = new PMUI.form.Field();

PMTinyField.prototype.type = "PMTinyField";

PMTinyField.prototype.family = 'PMTinyField';

PMTinyField.prototype.init = function (settings) {
    var defaults = {
        theme: "advanced",
        plugins: "advhr,advimage,advlink,advlist,autolink,autoresize,contextmenu,directionality,emotions,example,example_dependency,fullpage,fullscreen,iespell,inlinepopups,insertdatetime,layer,legacyoutput,lists,media,nonbreaking,noneditable,pagebreak,paste,preview,print,save,searchreplace,style,tabfocus,table,template,visualblocks,visualchars,wordcount,xhtmlxtras,pmSimpleUploader,pmVariablePicker,pmGrids,style",
        mode: "specific_textareas",
        editorSelector: "tmceEditor",
        widthTiny:  DEFAULT_WINDOW_WIDTH-60,
        heightTiny: DEFAULT_WINDOW_HEIGHT-100,
        directionality: 'rtl',
        verifyHtml: false,
        themeAdvancedButtons1: "pmSimpleUploader,|,pmVariablePicker,|,pmGrids,|,bold,italic,underline,|,justifyleft,justifycenter,justifyright,justifyfull,|,fontselect,fontsizeselect,|,cut,copy,paste,|,bullist,numlist,|,outdent,indent,blockquote",
        themeAdvancedButtons2: "tablecontrols,|,undo,redo,|,link,unlink,image,|,forecolor,backcolor,styleprops,|,hr,removeformat,visualaid,|,sub,sup,|,ltr,rtl,|,code",
        popupCss : "/js/tinymce/jscripts/tiny_mce/themes/advanced/skins/default/dialog.css",
        skin : "o2k7",
        skinVariant : "silver",
        processID:null,
        domainURL:"/sys"+ WORKSPACE +"/"+LANG+"/"+SKIN+"/",
        baseURL:"/js/tinymce/jscripts/tiny_mce"
    };

    jQuery.extend(true, defaults, settings);

    this.setTheme(defaults.theme)
        .setPlugins(defaults.plugins)
        .setMode(defaults.mode)
        .setEditorSelector(defaults.editorSelector)
        .setDirectionality(defaults.directionality)
        .setVerifyHtml(defaults.verifyHtml)
        .setThemeAdvancedButtons1(defaults.themeAdvancedButtons1)
        .setThemeAdvancedButtons2(defaults.themeAdvancedButtons2)
        .setPopupCss(defaults.popupCss)
        .setSkin(defaults.skin)
        .setSkinVariant(defaults.skinVariant)
        .setProcessID(defaults.processID)
        .setDomainURL(defaults.domainURL)
        .setBaseURL(defaults.baseURL)
        .setHeightTiny(defaults.heightTiny)
        .setWidthTiny(defaults.widthTiny)
        .hideLabel(true);
};

PMTinyField.prototype.setTheme = function (theme){
    this.controls[0].setTheme(theme);
    return this;
};
PMTinyField.prototype.setPlugins = function (plugins){
    this.controls[0].setPlugins(plugins);
    return this;
};
PMTinyField.prototype.setMode = function (mode){
    this.controls[0].setMode(mode);
    return this;
};
PMTinyField.prototype.setEditorSelector = function (editorSelector){
    this.controls[0].setEditorSelector(editorSelector);
    return this;
};
PMTinyField.prototype.setDirectionality = function (directionality){
    this.controls[0].setDirectionality(directionality);
    return this;
};
PMTinyField.prototype.setVerifyHtml = function (verifyHtml){
    this.controls[0].setVerifyHtml(verifyHtml);
    return this;
};
PMTinyField.prototype.setThemeAdvancedButtons1 = function (themeAdvancedButtons1){
    this.controls[0].setThemeAdvancedButtons1(themeAdvancedButtons1);
    return this;
};
PMTinyField.prototype.setThemeAdvancedButtons2 = function (themeAdvancedButtons2){
    this.controls[0].setThemeAdvancedButtons2(themeAdvancedButtons2);
    return this;
};
PMTinyField.prototype.setPopupCss = function (popupCss){
    this.controls[0].setPopupCss(popupCss);
    return this;
};
PMTinyField.prototype.setSkin = function (skin){
    this.skin = skin;
    this.controls[0].setSkin(skin);
    return this;
};
PMTinyField.prototype.setSkinVariant = function (skinVariant){
    this.controls[0].setSkinVariant(skinVariant);
    return this;
};
PMTinyField.prototype.setProcessID = function (processID){
    this.controls[0].setProcessID(processID);
    return this;
};
PMTinyField.prototype.setDomainURL = function (domainURL){
    this.controls[0].setDomainURL(domainURL);
    return this;
};
PMTinyField.prototype.setBaseURL = function (baseURL){
    this.controls[0].setBaseURL(baseURL);
    return this;
};
PMTinyField.prototype.setWidthTiny = function (widthTiny) {
    this.controls[0].setWidthTiny(widthTiny);
    return this;
};
PMTinyField.prototype.setHeightTiny = function (heightTiny) {
    this.controls[0].setHeightTiny(heightTiny);
    return this;
};
PMTinyField.prototype.hideLabel = function (value){
    jQuery(this.dom.labelTextContainer).hide();
        this.labelVisible = !value;
        return this;
    return this;
}
PMTinyField.prototype.setParameterTiny = function (){
    this.controls[0].setParameterTiny();
    return this;
}
PMTinyField.prototype.setValueTiny = function (value){
    this.controls[0].setValueTiny(value);
    return this;
}
/*PMTinyField.prototype.createHTML = function () {
    this.controls[0].createHTML();
    return this;
}*/

PMTinyField.prototype.setControls = function () {
    if (this.controls.length) {
         return this;
    }
    this.controls.push(new PMTiny());
    return this;
};




var PMRestClient = function (options) {
    this.endpoint = null;
    this.typeRequest = null;
    this.data = null;
    this.functionSuccess = null;
    this.functionFailure = null;
    this.functionComplete = null;
    this.apiVersion = null;
    this.restProxy = null;
    this.pmProcess = null;
    this.messageError= null;
    this.messageSuccess = null;
    this.flashContainer = null;
    this.flashDuration = null;
    this.flashSeverity = null;
    this.multipart = null;

    PMRestClient.prototype.init.call(this, options);
};

PMRestClient.prototype.type = "PMRestClient";

PMRestClient.prototype.init = function (options) {
    var defaults = {
        endpoint    : '',
        typeRequest : 'get',
        data        : null,
        functionSuccess     : function (resp, data) { },
        functionFailure     : function (resp, data) { },
        functionComplete    : function (resp, data) { },
        apiVersion  : '1.0',
        restProxy   : '',
        processID   : '',
        messageError: false,
        messageSuccess: false,
        flashContainer: document.body,
        flashDuration: 3000,
        flashSeverity: 'success',
        multipart: false
    }

    jQuery.extend(true, defaults, options);

    this.setProcessID()
        .setApiVersion(defaults.apiVersion)
        .setEndpoint(defaults.endpoint)
        .setTypeRequest(defaults.typeRequest)
        .setData(defaults.data)
        .setFunctionSuccess(defaults.functionSuccess)
        .setFunctionFailure(defaults.functionFailure)
        .setFunctionComplete(defaults.functionComplete)
        .setMessageSuccess(defaults.messageSuccess)
        .setMessageError(defaults.messageError)
        .setFlashContainer(defaults.flashContainer)
        .setFlashDuration(defaults.flashDuration)
        .setFlashSeverity(defaults.flashSeverity)
        .setMultipart(defaults.multipart);
}

PMRestClient.prototype.setProcessID = function () {
    this.processID = PMDesigner.project.id;
    return this;
};

PMRestClient.prototype.setEndpoint = function (endpoint) {
    this.endpoint = "/api/" + this.apiVersion + "/" + WORKSPACE + "/project/"+ this.processID + "/" + endpoint;
    return this;
};

PMRestClient.prototype.setBaseEndPoint = function (endpoint) {
    this.endpoint = "/api/" + this.apiVersion + "/" + WORKSPACE + "/" +endpoint;
    return this;
};

PMRestClient.prototype.setTypeRequest = function (typeRequest) {
    this.typeRequest = typeRequest;
    return this;
};

PMRestClient.prototype.setData = function (data) {
    this.data = data;
    return this;
};

PMRestClient.prototype.setFunctionSuccess = function (functionSuccess) {
    this.functionSuccess = functionSuccess;
    return this;
};

PMRestClient.prototype.setFunctionComplete = function (functionComplete) {
    this.functionComplete = functionComplete;
    return this;
};

PMRestClient.prototype.setFunctionFailure = function (functionFailure) {
    this.functionFailure = functionFailure;
    return this;
};

PMRestClient.prototype.setMessageSuccess = function (messageSuccess) {
    this.messageSuccess = (messageSuccess) ? messageSuccess : false;
    return this;
};

PMRestClient.prototype.setMessageError = function (messageError) {
    this.messageError= (messageError) ? messageError : false;
    return this;
};

PMRestClient.prototype.setApiVersion = function (apiVersion) {
    this.apiVersion = apiVersion;
    return this;
};

PMRestClient.prototype.setRestProxy = function () {
    this.restProxy = new PMUI.proxy.RestProxy();
    return this;
};

PMRestClient.prototype.setToken = function () {
    if (this.pmProcess == '' || this.pmProcess == null) {
        this.setProcessID();
    }
    if (this.restProxy == '' || this.restProxy == null) {
        this.setRestProxy();
    }

    var keys = PMDesigner.project.getKeysClient();
    this.restProxy.setDataType("json");
    this.restProxy.setAuthorizationType('oauth2',PMDesigner.project.tokens);
    if (this.multipart) {
        this.restProxy.rc.setHeader('X-Requested-With', 'MULTIPART');
    }

    return this;
};

PMRestClient.prototype.setFlashContainer = function (flashContainer) {
    this.flashContainer = flashContainer;
    return this;
};

PMRestClient.prototype.setFlashDuration = function (flashDuration) {
    this.flashDuration = flashDuration;
    return this;
};

PMRestClient.prototype.setFlashSeverity = function (flashSeverity) {
    this.flashSeverity = flashSeverity;
    return this;
};

PMRestClient.prototype.setMultipart = function (multipart ) {
    this.multipart = multipart ;
    return this;
};

PMRestClient.prototype.setHeader = function (name, value) {
    if (this.restProxy == '' || this.restProxy == null) {
        this.setRestProxy();
    }
    this.restProxy.rc.setHeader(name, value);
    return this;
};

PMRestClient.prototype.executeRestClient = function () {
    if (this.restProxy == '' || this.restProxy == null) {
        this.setRestProxy();
    }
    this.setToken();
    if (this.data != null) {
        if (typeof this.data == 'object') {
            this.setData('data : '+ JSON.stringify(this.data) + ',');
        }
    } else {
        this.setData(" ");
    }
    that = this;
    var rest;
    if (this.multipart) {
        var HTTP_SUCCESS = ["200","201","202","204","207"];
        var showMessage = false;
        var messageMultipart = [];
        var validateMesssage = function (response) {
            for (var i=0; i< response.length; i++) {
                if (HTTP_SUCCESS.indexOf(String(response[i].status)) != -1) {
                    if (that.messageSuccess[i] != null) {
                        showMessage = true;
                        messageMultipart.push(that.messageSuccess[i]);
                    }
                } else {
                    if (that.messageError[i] != null) {
                        showMessage = true;
                        messageMultipart.push(that.messageError[i]);
                        that.setFlashSeverity('error');
                    }
                }
            }
        };

        rest = 'this.restProxy.' + this.typeRequest + '({' +
            'url:"' + this.endpoint + '",' +
            'authorizationOAuth: true,' +
            this.data+
            'success: function (xhr, response) {'+
                'validateMesssage(response);'+
                'if (showMessage) {'+
                    'PMDesigner.msgFlash(messageMultipart, that.flashContainer, that.flashSeverity, that.flashDuration);'+
                '}'+
                'that.functionSuccess( xhr, response );'+
            '},'+
            'failure: function (xhr, response) {'+
                'validateMesssage(response);'+
                'if (showMessage) {'+
                    'PMDesigner.msgFlash(messageMultipart, that.flashContainer, that.flashSeverity, that.flashDuration);'+
                '}'+
                'that.functionFailure( xhr, response );'+
            '},'+
            'complete: function (xhr, response) {'+
                'that.functionComplete( xhr, response );'+
            '}'+
        '});';
    } else {
        rest = 'this.restProxy.' + this.typeRequest + '({' +
            'url:"' + this.endpoint + '",' +
            'authorizationOAuth: true,' +
            this.data+
            'success: function (xhr, response) {'+
                'if (that.messageSuccess) {'+
                    'PMDesigner.msgFlash(that.messageSuccess, that.flashContainer, that.flashSeverity, that.flashDuration);'+
                '}'+
                'that.functionSuccess( xhr, response );'+
            '},'+
            'failure: function (xhr, response) {'+
                'if (xhr.status == 400) {'+
                    'var responseText = jQuery.parseJSON(xhr.responseText);'+
                    'PMDesigner.msgWinError(responseText.error.message);'+
                    'return;'+
                '}'+
                'if (that.messageError) {'+
                    'PMDesigner.msgWinError(that.messageError);'+
                '}'+
                'that.functionFailure( xhr, response );'+
            '},'+
            'complete: function (xhr, response) {'+
                'that.functionComplete( xhr, response );'+
            '}'+
        '});';
    }

    eval (rest);
};



var PMCodeMirror = function (settings) {
	PMUI.control.TextAreaControl.call(this, settings);
	
	this.lineNumbers = null;
	this.matchBrackets = null;
	this.mode = null;
	this.indentUnit = null;
	this.indentWithTabs = null;
	this.enterMode = null;
	this.tabMode = null;
	this.lineWrapping = null; //CodeMirror should scroll or wrap for long lines.
	this.showCursorWhenSelecting = null; //Whether the cursor should be drawn when a selection is active.
	this.autofocus = null;
	this.height = null;
	this.dom = {};
	this.cm = null;

    PMCodeMirror.prototype.init.call(this, settings);
};

PMCodeMirror.prototype = new PMUI.control.TextAreaControl();

PMCodeMirror.prototype.type = "PMCodeMirrorControl";

PMCodeMirror.prototype.family = 'PMCodeMirrorControl';

PMCodeMirror.prototype.init = function (settings) {
    var defaults = {
    	lineNumbers: true,
    	matchBrackets : true,
    	mode : "application/x-httpd-php-open",
    	indentUnit: 4,
    	indentWithTabs: true,
    	enterMode:"keep",
    	tabMode: "shift",
    	lineWrapping: true,
    	showCursorWhenSelecting: true,
    	autofocus: "on",
    	height: 120
    };

    jQuery.extend(true, defaults, settings);
    
    this.setLineNumbers(defaults.lineNumbers)
    	.setMatchBrackets(defaults.matchBrackets)
    	.setMode(defaults.mode)
    	.setIndentUnit(defaults.indentUnit)
    	.setIndentWithTabs(defaults.indentWithTabs)
    	.setEnterMode(defaults.enterMode)
    	.setTabMode(defaults.tabMode)
        .setLineWrapping(defaults.lineWrapping)
        .setShowCursorWhenSelecting(defaults.showCursorWhenSelecting)
        .setAutofocus(defaults.autofocus)
        .setHeight(defaults.height);
	};
	
	PMCodeMirror.prototype.setHeight = function(height){
		this.height = height;
		return this;
	};
	
	PMCodeMirror.prototype.setLineNumbers = function(lineNumbers){
		this.lineNumbers = lineNumbers;
		return this;
	};
	PMCodeMirror.prototype.setMatchBrackets = function(matchBrackets){
		this.matchBrackets = matchBrackets;
		return this;
	};
	PMCodeMirror.prototype.setMode = function(mode){
		this.mode = mode;
		return this;
	};
	
	PMCodeMirror.prototype.setIndentUnit = function(indentUnit){
		this.indentUnit = indentUnit;
		return this;
	};
	PMCodeMirror.prototype.setIndentWithTabs = function(indentWithTabs){
		this.indentWithTabs = indentWithTabs;
		return this;
	};
	PMCodeMirror.prototype.setEnterMode = function(enterMode){
		this.enterMode = enterMode;
		return this;
	};
	PMCodeMirror.prototype.setTabMode = function(tabMode){
		this.tabMode = tabMode;
		return this;
	};
	PMCodeMirror.prototype.setLineWrapping = function(lineWrapping){
		this.lineWrapping = lineWrapping;
		return this;
	};
	PMCodeMirror.prototype.setShowCursorWhenSelecting = function(showCursorWhenSelecting){
		this.showCursorWhenSelecting = showCursorWhenSelecting;
		return this;
	};
	PMCodeMirror.prototype.setAutofocus = function(autofocus){
		this.autofocus = autofocus;
		return this;
	};
	
	
	PMCodeMirror.prototype.setParameterCodeMirror = function (){
		if(!this.html) {
			return this;
		}

		this.cm = CodeMirror.fromTextArea(
			this.dom.textArea,
			{	height : this.height,
		        lineNumbers: this.lineNumbers,
		        matchBrackets: this.matchBrackets,
		        mode: this.mode,
		        indentUnit: this.indentUnit,
		        indentWithTabs: this.indentWithTabs,
		        enterMode: this.enterMode ,
		        tabMode: this.tabMode,
		        lineWrapping: this.lineWrapping,
		        showCursorWhenSelecting: this.showCursorWhenSelecting,
		        autofocus: this.autofocus
		     }
		);
		return this;
	};
	
	PMCodeMirror.prototype.getValueFromRawElement = function() {
		return (this.cm && this.cm.getValue()) || "";
	};
	
	PMCodeMirror.prototype.defineEvents = function() {
		var that = this;
		if(!this.eventsDefined) {
			if(this.cm) {
				this.cm.on("change", function() {
					that.onChangeHandler();
				});
			}
		}
		
		return this;
	};
	
	
	PMCodeMirror.prototype.createHTML = function (){
	    var containerCode;
	
	    if(this.html){
	        return this.html;
	    }

	    PMUI.control.TextAreaControl.prototype.createHTML.call(this);
	    containerCode = PMUI.createHTMLElement("div");
	    containerCode.appendChild(this.html);
	    this.dom.textArea = this.html;
	    this.html = containerCode;
	    this.applyStyle();
	    this.setParameterCodeMirror();
	    return this.html;
	};

var PMCodeMirrorField = function (settings) {
    PMUI.form.Field.call(this, settings);

    PMCodeMirrorField.prototype.init.call(this, settings);
};

PMCodeMirrorField.prototype = new PMUI.form.Field();

PMCodeMirrorField.prototype.type = "PMCodeMirrorField";

PMCodeMirrorField.prototype.family = 'PMCodeMirrorField';

PMCodeMirrorField.prototype.init = function (settings) {
    var defaults = {
        lineNumbers: true,
        matchBrackets : true,
        mode : "application/x-httpd-php-open",
        indentUnit: 4,
        indentWithTabs: true,
        enterMode:"keep",
        tabMode: "shift",
        lineWrapping: true,
        showCursorWhenSelecting: true,
        autofocus: "on"
    };

    jQuery.extend(true, defaults, settings);
    
    this.setLineNumbers(defaults.lineNumbers)
        .setMatchBrackets(defaults.matchBrackets)
        .setMode(defaults.mode)
        .setIndentUnit(defaults.indentUnit)
        .setIndentWithTabs(defaults.indentWithTabs)
        .setEnterMode(defaults.enterMode)
        .setTabMode(defaults.tabMode)
        .setLineWrapping(defaults.lineWrapping)
        .setShowCursorWhenSelecting(defaults.showCursorWhenSelecting)
        .setAutofocus(defaults.autofocus);
    };
    
    PMCodeMirrorField.prototype.setLineNumbers = function(lineNumbers){
        this.controls[0].setLineNumbers(lineNumbers);
        return this;
    };
    PMCodeMirrorField.prototype.setMatchBrackets = function(matchBrackets){
        this.controls[0].setMatchBrackets(matchBrackets);
        return this;
    };
    PMCodeMirrorField.prototype.setMode = function(mode){
        this.controls[0].setMode(mode);
        return this;
    };
    PMCodeMirrorField.prototype.setIndentUnit = function(indentUnit){
        this.controls[0].setIndentUnit(indentUnit);
        return this;
    };
    PMCodeMirrorField.prototype.setIndentWithTabs = function(indentWithTabs){
        this.controls[0].setIndentWithTabs(indentWithTabs);
        return this;
    };
    PMCodeMirrorField.prototype.setEnterMode = function(enterMode){
        this.controls[0].setEnterMode(enterMode);
        return this;
    };
    PMCodeMirrorField.prototype.setTabMode = function(tabMode){
        this.controls[0].setTabMode(tabMode);
        return this;
    };
    PMCodeMirrorField.prototype.setLineWrapping = function(lineWrapping){
        this.controls[0].setLineWrapping(lineWrapping);
        return this;
    };
    PMCodeMirrorField.prototype.setShowCursorWhenSelecting = function(showCursorWhenSelecting){
        this.controls[0].setShowCursorWhenSelecting(showCursorWhenSelecting);
        return this;
    };
    PMCodeMirrorField.prototype.setAutofocus = function(autofocus){
        this.controls[0].setAutofocus(autofocus);
        return this;
    };
    
    PMCodeMirrorField.prototype.setControls = function () {
        if(this.controls.length) {
             return this;
        }

        this.controls.push(new PMCodeMirror());

        return this;
   };

var CriteriaField = function (options) {
    this.renderType = (options && options.renderType) || "text";
    PMUI.field.TextField.call(this, options);
    this.process = null;
    this.workspace = null;
    this.buttonHTML = null;
    this.rows = options.rows;
    CriteriaField.prototype.init.call(this, options);
};

CriteriaField.prototype = new PMUI.field.TextField();

CriteriaField.prototype.setProcess = function (process) {
    this.process = process;
    return this;
};

CriteriaField.prototype.setWorkspace = function (workspace) {
    this.workspace = workspace;
    return this;
};

CriteriaField.prototype.init = function (options) {
    var defaults = {
        process: PMDesigner.project.projectId,
        workspace: WORKSPACE
    };
    jQuery.extend(true, defaults, options);
    this.setProcess(defaults.process)
            .setWorkspace(defaults.workspace);
};

CriteriaField.prototype.createVariablePicker = function () {
    var vp = new VariablePicker({
        relatedField: this,
        processId: this.process
    });
    return vp;
};

CriteriaField.prototype.setControls = function () {
    if (this.controls.length) {
        return this;
    }
    if (this.renderType === 'text') {
        this.controls.push(new PMUI.control.TextControl());
    } else {
        this.controls.push(new PMUI.control.TextAreaControl({style: {cssProperties: {resize: 'vertical'}}}));
    }
    return this;
};

CriteriaField.prototype.createCallBack = function () {
    var that = this, oldValue, newValue, init = 0;
    return {
        success: function (variable) {
            init = that.controls[0].html.selectionStart;
            prevText = that.controls[0].html.value.substr(0, init);
            lastText = that.controls[0].html.value.substr(that.controls[0].html.selectionEnd, that.controls[0].html.value.length);
            newValue = prevText + variable + lastText;
            that.setValue(newValue);
            that.controls[0].html.selectionEnd = init + variable.length;
        }
    };
};

CriteriaField.prototype.createHTML = function () {
    var button, that = this;
    PMUI.field.TextField.prototype.createHTML.call(this);

    button = new PMUI.ui.Button({
        id: 'buttonCriteriaField',
        text: '@@',
        handler: function () {
            that.createVariablePicker().open(that.createCallBack());
        },
        style: {
            cssProperties: {
                background: '#2d3e50',
                fontSize: 18,
                paddingLeft: '15px',
                paddingRight: '15px',
                borderRadius: '4px',
                verticalAlign: 'top'
            }
        }
    });

    this.buttonHTML = button;
    $(this.helper.html).before(button.getHTML())
    this.buttonHTML.style.addProperties({"margin-left": "10px"});
    this.buttonHTML.html.tabIndex = -1;

    if (this.rows != null)
        this.controls[0].setHeight(this.rows);
    button.defineEvents();

    return this.html;
};

// Overwrite original init function for FormItemFactory
PMUI.form.FormItemFactory.prototype.init = function () {
    var defaults = {
        products: {
            "criteria": CriteriaField,
            "field": PMUI.form.Field,
            "panel": PMUI.form.FormPanel,
            "text": PMUI.field.TextField,
            "password": PMUI.field.PasswordField,
            "dropdown": PMUI.field.DropDownListField,
            "radio": PMUI.field.RadioButtonGroupField,
            "checkbox": PMUI.field.CheckBoxGroupField,
            "textarea": PMUI.field.TextAreaField,
            "datetime": PMUI.field.DateTimeField,
            "optionsSelector": PMUI.field.OptionsSelectorField,
            "buttonField": PMUI.field.ButtonField
        },
        defaultProduct: "panel"
    };
    this.setProducts(defaults.products)
            .setDefaultProduct(defaults.defaultProduct);
};

var PMTooltipMessage = function (options) {
    PMUI.ui.Window.call(this, options);
    this.container = null;
    this.message = options.message;   
    PMTooltipMessage.prototype.init.call(this, options);
};

PMTooltipMessage.prototype = new PMUI.ui.Window();
PMTooltipMessage.prototype.type = "PMTooltipMessage";



PMTooltipMessage.prototype.createHTML = function (){
        var containerCode;
    
        if(this.html){
            return this.html;
        }
        
        PMUI.ui.Window.prototype.createHTML.call(this);
        //this.setModal(false);
        //$(this.header).remove('#'+this.closeButton.id);
        //this.closeButton =null;
        this.closeButton.style.removeAllClasses();
        this.closeButton.setText("x");
        this.closeButton.style.addClasses(['mafe-tooltip-close']);
        this.header.appendChild(this.closeButton.getHTML());
        this.container = PMUI.createHTMLElement('div');
        this.container.innerHTML = this.message;
        this.body.appendChild(this.container);
        return this.html;
    };


PMTooltipMessage.prototype.open = function (x,y){
    PMUI.ui.Window.prototype.open.call(this);
    this.setVisible(false);
    this.setX(x);
    this.setY(y);    
    this.header.className = "mafe-tooltip-header";
    this.body.className = "mafe-tooltip-body";
    this.style.addClasses(['mafe-tooltip']);
    this.setTitle("");
    $("#"+this.id).show("drop","fast");
    this.closeButton.defineEvents();
};


PMTooltipMessage.prototype.setMessage = function (message){
    this.message = message;
    if(this.html)
        this.container.innerHTML = message; 
};








var VariablePicker = function (options) {
    this.relatedField = null;
    this.processId = null;
    this.workspace = null;
    this.window = null;
    this.currentVariable = null;
    this.pageSize = 10;
    VariablePicker.prototype.init.call(this, options);
};

VariablePicker.prototype.type = 'VariablePicker';

VariablePicker.prototype.family = 'VariablePicker';

VariablePicker.prototype.init = function (options) {
    var defaults = {
        relatedField: null,
        processId: PMDesigner.project.projectId,
        workspace: WORKSPACE
    };

    jQuery.extend(true, defaults, options);

    this.setRelatedField(defaults.relatedField)
            .setProcessId(defaults.processId)
            .setWorkspace(defaults.workspace);
};

VariablePicker.prototype.setRelatedField = function (field) {
    if (field instanceof PMUI.form.Field) {
        this.relatedField = field;
    }
    return this;
};

VariablePicker.prototype.setProcessId = function (process) {
    this.processId = process;
    return this;
};

VariablePicker.prototype.setWorkspace = function (workspace) {
    this.workspace = workspace;
    return this;
};

VariablePicker.prototype.getURL = function () {
    var url = '/api/1.0/' + this.workspace + '/project/' + this.processId + '/variables';
    return url;
};

VariablePicker.prototype.open = function (callback) {
    var w, rc, fieldC, dataGrid, panel, textField, that = this;

    button = new PMUI.ui.Button({
        id: 'insertVariable',
        text: 'Insert Variable'.translate(),
        handler: function () {
            if (callback && callback.success && typeof callback.success === 'function') {
                that.currentVariable = fieldC.getValue() + that.currentVariable;
                callback.success.call(that, that.currentVariable);
            }
            that.close();
        },
        disabled: true
    });

    textField = new PMUI.field.TextField({
        id: 'textFieldSearch',
        label: '',
        placeholder: 'Text to Search'.translate()
    });

    w = new PMUI.ui.Window({
        id: 'processVariables',
        title: 'Process Variables'.translate(),
        width: 480,
        height: 420,
        closable: true,
        modal: true,
        buttons: [
            button
        ],
        buttonsPosition: 'center'
    });

    fieldC = new PMUI.field.DropDownListField({
        id: 'prefixDropDownListField',
        label: 'Prefix'.translate(),
        helper: '@@ string, @# float, @% integer, @? URL, @$ SQL query, @= original type.'.translate(),
        options: [
            {
                id: 'prefixDropDownListField1',
                label: '@@',
                value: '@@'
            },
            {
                id: 'prefixDropDownListField2',
                label: '@#',
                value: '@#'
            },
            {
                id: 'prefixDropDownListField3',
                label: '@%',
                value: '@%'
            },
            {
                id: 'prefixDropDownListField4',
                label: '@?',
                value: '@?'
            },
            {
                id: 'prefixDropDownListField5',
                label: '@$',
                value: '@$'
            },
            {
                id: 'prefixDropDownListField6',
                label: '@=',
                value: '@='
            }
        ],
        onChange: function (newValue, oldValue) {
        }
    });

    textField = new PMUI.field.TextField({
        id: 'textFieldSearch',
        label: '',
        placeholder: 'Text to search'.translate(),
        width: 150
    });

    dataGrid = new PMUI.grid.GridPanel({
        id: 'gridPanel',
        selectable: true,
        pageSize: this.pageSize,
        nextLabel: 'Next'.translate(),
        previousLabel: 'Previous'.translate(),
        customStatusBar: function (currentPage, pageSize, numberItems, criteria, filter) {
            return messagePageGrid(currentPage, pageSize, numberItems, criteria, filter);
        },
        columns: [
            {
                id: 'gridPanelVariable',
                title: 'Variable'.translate(),
                columnData: 'var_name',
                width: 150,
                sortable: true,
                alignmentCell: 'left'
            },
            {
                id: 'gridPanelLabel',
                title: 'Label'.translate(),
                columnData: 'var_label',
                width: 230,
                sortable: false,
                alignmentCell: 'left'
            }
        ],
        onRowClick: function (row, data) {
            button.enable();
            that.currentVariable = data.var_name;
        }

    });


    panelFilter = new PMUI.core.Panel({
        id: 'panelFilter',
        layout: 'hbox',
        items: [fieldC, textField]
    });

    panel = new PMUI.core.Panel({
        id: 'paneldataGrid',
        layout: 'vbox',
        items: [panelFilter, dataGrid]
    });


    rc = new PMRestClient({
        //endpoint: 'variables',
        typeRequest: 'get',
        functionSuccess: function (xhr, response) {
            that.window = w;
            dataGrid.setDataItems(response);
            w.open();
            w.showFooter();
            w.addItem(panel);
            panelFilter.setWidth(430);
            fieldC.setControlsWidth(70);
            textField.controls[0].onKeyUp = function () {
                dataGrid.filter(textField.controls[0].html.value);
            };
            dataGrid.dom.toolbar.style.display = 'none';
            textField.dom.labelTextContainer.innerHTML = '';
            textField.dom.labelTextContainer.style.marginTop = 5;
            fieldC.dom.labelTextContainer.style.paddingLeft = 20;
            panel.style.addProperties({'padding-left': 20});
            fieldC.dom.labelTextContainer.style.width = 60;
            textField.dom.labelTextContainer.style.display = 'none';
            textField.controls[0].setWidth(200);
        }
    });
    rc.setBaseEndPoint('projects/' + this.processId + '/variables').executeRestClient();


};

VariablePicker.prototype.close = function () {
    if (this.window) {
        this.window.close();
        this.window = null;
    }
};

var PMAction = function (options) {

	this.name = null;
	this.action = null;
    this.selector = null;
    this.tooltip = null;
    this.execute = null;
    this.label = null;
    this.before = null;
    this.after = null;
    this.handler = null;
    this.eventsDefined = false;
	PMAction.prototype.init.call(this, options);
};

PMAction.prototype.type = "action";

PMAction.prototype.events = [
	"click","click"
];

PMAction.prototype.init = function(options){
	var defaults = {
        action:"click",
        selector: "",
        tooltip: "",
        execute: false,
        label: {
            selector: "",
            text: "",
            value:""
        },
        before: function(event){
            event.preventDefault();
            PMUI.removeCurrentMenu();
        },
        after: function(event) {
            event.stopPropagation();
        },
        handler: function(event){}
	};
    jQuery.extend(true, defaults, options);
    
    this.setAction(defaults.action)
        .setSelector(defaults.selector)
        .setExecute(defaults.execute)
        .setLabel(defaults.label)
        .setBefore(defaults.before)
        .setAfter(defaults.after)
        .setHandler(defaults.handler)
        .setText(defaults.label.text)
        .setValue(defaults.label.value)
        .setTooltip(defaults.tooltip)
        .addEventListener();
        
};
PMAction.prototype.setAction = function (action) {
    this.action = action;
    return this;
};
PMAction.prototype.setSelector = function (selector) {
    this.selector = selector;
    return this;
};
PMAction.prototype.setExecute = function (option) {
    this.execute = option;
    return this;
};
PMAction.prototype.setLabel = function (label) {
    this.label = label;
    if (!label.selector) {
        this.label.selector = this.selector;
    }
    return this;
};
PMAction.prototype.setBefore = function (action) {
    this.before = action;
    return this;
};
PMAction.prototype.setAfter = function (action) {
    this.after = action;
    return this;
};
PMAction.prototype.setHandler = function (action) {
    this.handler = action;
    return this;
};
PMAction.prototype.setText = function (text) {
    if (typeof text === "string" && text.length > 0) {
        this.label.text = text;
        jQuery(this.label.selector).text(this.label.text);
    }
    return this;
};
PMAction.prototype.setValue = function (value) {
    if (typeof value === "string" && value.length > 0) {
        this.label.value = value;
        jQuery(this.label.selector).val(this.label.value);
    }
    return this;
};
PMAction.prototype.setTooltip = function (message) {
    var that = this;
    if (typeof message === "string") {
        this.tooltip = message;
        jQuery(this.selector).attr("title","");
        jQuery(this.selector).tooltip({ content: that.tooltip, tooltipClass: "mafe-action-tooltip" });
    }
    return this;
};
PMAction.prototype.addEventListener = function () {
    var that = this;
    if (this.execute === true && this.eventsDefined === false) {

        jQuery(this.selector).on(this.action,function(event){
            try {
                that.before(event);
            } catch (e) {
                throw new Error('Before action '.translate() + e.message);    
            }
            try {
                that.handler(event);
            } catch (e) {
                throw new Error('Handler '.translate() + e.message);    
            }
            try {
                that.after(event);      
            } catch (e) {
                throw new Error('After action '.translate() + e.message);    
            }
        });

        jQuery(this.label.selector).text(this.label.text);
        this.eventsDefined = true;
    }
    return this;
};
PMAction.prototype.defineEvents = function () {
    this.setExecute(true);
    this.addEventListener();
};

var PMSeparatorLine = function (settings) {
	PMUI.control.HTMLControl.call(this, settings);
	this.width = null;
	this.height = null;
	this.color = null;
	this.marginLeft = null;
    PMSeparatorLine.prototype.init.call(this, settings);
};

PMSeparatorLine.prototype = new PMUI.control.HTMLControl();

PMSeparatorLine.prototype.type = "PMSeparatorLine";

PMSeparatorLine.prototype.family = 'PMSeparatorLine';

PMSeparatorLine.prototype.init = function (settings) {
    var defaults = {
    	width: "90%",
        height:'3px',
        color: "#C0C0C0",
        marginLeft: "0%"
    };

    jQuery.extend(true, defaults, settings);
    
    this.setWidth(defaults.width);
    this.setColor(defaults.color);
    this.setHeight(defaults.height);
    this.setMarginLeft(defaults.marginLeft);
};
	
	PMSeparatorLine.prototype.setHeight = function(height){
		this.height = height;
		if (this.html) {
			this.html.style.height = this.height;
		}
		return this;
	};
	
	PMSeparatorLine.prototype.setWidth = function(width){
		this.width = width;
		
		if (this.html){
			this.html.style.width = this.width;
		}
		return this;
	};
	PMSeparatorLine.prototype.setColor = function(color){
		this.color = color;
		if(this.html){
			this.html.style.background = this.color;
		}
		return this;
	};
	PMSeparatorLine.prototype.setMarginLeft = function(marginLeft){
		this.marginLeft = marginLeft;
		
		if(this.html) {
			this.html.style.marginLeft = this.marginLeft;
		}
		return this;
	};
	
	PMSeparatorLine.prototype.createHTML = function (){
	    var input;
	    
	    if(this.html){
	        return this.html;
	    }

	    input = PMUI.createHTMLElement("hr");
	    input.className = "PMSeparatorLine";
	    input.id = this.id;
	    input.name = "PMSeparatorLine";
	    this.html = input;
	    this.setColor(this.color);
	    this.setMarginLeft(this.marginLeft);
	    this.applyStyle();
	    return this.html;
	};

var PMSeparatorLineField = function (settings) {
    PMUI.form.Field.call(this, settings);

    PMSeparatorLineField.prototype.init.call(this, settings);
};

PMSeparatorLineField.prototype = new PMUI.form.Field();

PMSeparatorLineField.prototype.type = "PMSeparatorLineField";

PMSeparatorLineField.prototype.family = 'PMSeparatorLineField';

PMSeparatorLineField.prototype.init = function (settings) {
    var defaults = {
        controlHeight: 1,
        controlColor: "#CDCDCD",
        widthControl : "90%",
        marginLeft: "5%"
    };

    jQuery.extend(true, defaults, settings);
    
    this.setControlHeight(defaults.controlHeight)
        .setControlColor(defaults.controlColor)
        .setMarginLeft(defaults.marginLeft);
    };
    
    
	PMSeparatorLineField.prototype.setControlHeight = function(size){
        this.controls[0].setHeight (size);
        return this;
    };
    PMSeparatorLineField.prototype.setControlColor = function(color){
        this.controls[0].setColor(color);
        return this;
    };
    PMSeparatorLineField.prototype.setMarginLeft = function(marginLeft){
        this.controls[0].setMarginLeft(marginLeft);
        return this;
    }; 
    PMSeparatorLineField.prototype.setControls = function () {
        if(this.controls.length) {
             return this;
        }
        this.controls.push(new PMSeparatorLine());

        return this;
   };
   
   PMSeparatorLineField.prototype.getValue = function () {
       return null;
   };
   
   PMSeparatorLineField.prototype.createHTML = function () {
	   	
	   PMUI.form.Field.prototype.createHTML.call(this);
	   
	   this.hideLabel();
	   this.setLabelWidth('0%');
	   return this.html;
   };
   

var PMLabelField = function (settings) {
    PMUI.form.Field.call(this, settings);

    PMLabelField.prototype.init.call(this, settings);
};

PMLabelField.prototype = new PMUI.form.Field();

PMLabelField.prototype.type = "PMLabelField";

PMLabelField.prototype.family = 'PMLabelField';

PMLabelField.prototype.init = function (settings) {
    var defaults = {
        text: "Mafe Label0",
        textMode: "plain"
    };

    jQuery.extend(true, defaults, settings);
        
    this.setText(defaults.text);
    this.setTextMode(defaults.textMode);
};
    
PMLabelField.prototype.setText = function(text){
    this.controls[0].setText (text);
    return this;
};
PMLabelField.prototype.setTextMode = function(textMode){
    this.controls[0].setTextMode(textMode);
    return this;
};
    
PMLabelField.prototype.setControls = function () {
    if(this.controls.length) {
        return this;
    }
    this.controls.push(new PMLabelControl());

    return this;
};
   
PMLabelField.prototype.getValue = function () {
    return null;
};
   
PMLabelField.prototype.createHTML = function () {
	   	
    PMUI.form.Field.prototype.createHTML.call(this);
    this.hideLabel();
	this.setLabelWidth('0%');
	return this.html;
};
   

var PMLabelControl = function (settings) {
	PMUI.control.Control.call(this, settings);
	this.label = null;
    PMLabelControl.prototype.init.call(this, settings);
};

PMLabelControl.prototype = new PMUI.control.Control();

PMLabelControl.prototype.type = "PMLabelControl";

PMLabelControl.prototype.family = 'PMLabelControl';

PMLabelControl.prototype.init = function (settings) {
	this.label = new PMUI.ui.TextLabel();
};

PMLabelControl.prototype.setText = function(text) {
    if(this.label){
    	this.label.setText(text);
    }
    return this;
};

PMLabelControl.prototype.setTextMode = function(textMode) {
	if(this.label) {
		this.label.setTextMode(textMode);
	}
    return this;
};


PMLabelControl.prototype.createHTML = function() {
	PMUI.control.Control.prototype.createHTML.call(this);
	this.html = this.label.getHTML();
	this.setPositionMode('relative');
    return this.html;
};



/*global jCore*/
var PMArtifactResizeBehavior = function () {
};

PMArtifactResizeBehavior.prototype = new PMUI.behavior.RegularResizeBehavior();
PMArtifactResizeBehavior.prototype.type = "PMArtifactResizeBehavior";


/**
 * Sets a shape's container to a given container
 * @param container
 * @param shape
 */
PMArtifactResizeBehavior.prototype.onResizeStart = function (shape) {
    return PMUI.behavior.RegularResizeBehavior
        .prototype.onResizeStart.call(this, shape);
};
/**
 * Removes shape from its current container
 * @param shape
 */
PMArtifactResizeBehavior.prototype.onResize = function (shape) {
    //RegularResizeBehavior.prototype.onResize.call(this, shape);
    return function (e, ui) {
        PMUI.behavior.RegularResizeBehavior
            .prototype.onResize.call(this, shape)(e, ui);
        if (shape.graphics) {
            shape.paint();
        }

    };

};

var ConnectValidator = function () {

};
ConnectValidator.prototype.type = "ConnectValidator";

ConnectValidator.prototype.initRules = {
     'START': {
            'START' : 'sequencialRules',
            'INTERMEDIATE' : 'sequencialRules',
            'TASK'  : 'sequencialRules',
            'SUB_PROCESS': 'sequencialRules',
            'GATEWAY': 'sequencialRules',
            'END': 'sequencialRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
    'INTERMEDIATE': {
            'START' : 'sequencialRules',
            'INTERMEDIATE' : 'sequencialRules',
            'TASK'  : 'sequencialRules',
            'SUB_PROCESS': 'sequencialRules',
            'GATEWAY': 'sequencialRules',
            'END': 'sequencialRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
    'END': {
            'START' : 'sequencialRules',
            'INTERMEDIATE' : 'sequencialRules',
            'TASK'  : 'sequencialRules',
            'SUB_PROCESS': 'sequencialRules',
            'GATEWAY': 'sequencialRules',
            'END': 'sequencialRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
    'TASK': {
            'START' : 'sequencialRules',
            'INTERMEDIATE' : 'sequencialRules',
            'TASK'  : 'sequencialRules',
            'SUB_PROCESS': 'sequencialRules',
            'GATEWAY': 'sequencialRules',
            'END': 'sequencialRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
    'SUB_PROCESS': {
            'START' : 'sequencialRules',
            'INTERMEDIATE' : 'sequencialRules',
            'TASK'  : 'sequencialRules',
            'SUB_PROCESS': 'sequencialRules',
            'GATEWAY': 'sequencialRules',
            'END': 'sequencialRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
   'GATEWAY': {
            'START' : 'sequencialRules',
            'INTERMEDIATE' : 'sequencialRules',
            'TASK'  : 'sequencialRules',
            'SUB_PROCESS': 'sequencialRules',
            'GATEWAY': 'sequencialRules',
            'END': 'sequencialRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
    'DATA': {
            'START' : 'associationRules',
            'INTERMEDIATE' : 'associationRules',
            'TASK'  : 'associationRules',
            'SUB_PROCESS': 'associationRules',
            'GATEWAY': 'associationRules',
            'END': 'associationRules',
            'DATA': 'associationRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules'
    },
    'PARTICIPANT': {
            'START' : 'messageRules',
            'TASK'  : 'messageRules',
            'SUB_PROCESS': 'messageRules',
            'GATEWAY': 'messageRules',
            'END': 'messageRules',
            'DATA': 'messageRules',
            'PARTICIPANT': 'messageRules',
            'TEXT_ANNOTATION': 'annotationRules',
            'INTERMEDIATE' : 'messageRules'
    },
    'TEXT_ANNOTATION': {
        'START' : 'annotationRules',
        'INTERMEDIATE' : 'annotationRules',
        'TASK'  : 'annotationRules',
        'SUB_PROCESS': 'annotationRules',
        'GATEWAY': 'annotationRules',
        'END': 'annotationRules',
        'DATA': 'annotationRules',
        'PARTICIPANT': 'annotationRules',
        'TEXT_ANNOTATION': 'annotationRules'
    }
};


ConnectValidator.prototype.sequencialRules = {
    'START': {
            'START' : false,
            'INTERMEDIATE' : true,
            'TASK'  : true,
            'SUB_PROCESS': true,
            'GATEWAY': false,
            'END': false
    },
    'INTERMEDIATE': {
            'START' : false,
            'INTERMEDIATE' : true,
            'TASK'  : true,
            'SUB_PROCESS': true,
            'GATEWAY': true,
            'END': true
    },
    'END': {
            'START' : false,
            'TASK'  : false,
            'SUB_PROCESS': false,
            'GATEWAY': false,
            'END': false,
            'INTERMEDIATE' : false
    },
    'TASK': {
            'START' : false,
            'TASK'  : true,
            'SUB_PROCESS': true,
            'GATEWAY': true,
            'END': true,
            'INTERMEDIATE' : true
    },
    'SUB_PROCESS': {
            'START' : false,
            'TASK'  : true,
            'SUB_PROCESS': true,
            'GATEWAY': true,
            'END': true,
            'INTERMEDIATE' : true
    },
   'GATEWAY': {
            'START' : false,
            'TASK'  : true,
            'SUB_PROCESS': true,
            'GATEWAY': true,
            'END': true,
            'INTERMEDIATE' : true
    },
    'DATAOBJECT': {
            'TASK': true,
            'INTERMEDIATE' : true
    }
};

ConnectValidator.prototype.messageRules = {
    'PARTICIPANT': {
        'PARTICIPANT': true,
        'TASK': true,
        'SUBPROCESS': true,
        'START' : true,
        'END': false,
        'INTERMEDIATE': true,
        'GATEWAY': false
    },
    'START': {
            'PARTICIPANT': true
    },
    'INTERMEDIATE': {
            'PARTICIPANT': true
    },
    'TASK': {
        'PARTICIPANT': true
    },
    'SUB_PROCESS': {
        'PARTICIPANT': true
    },
    'END': {
         'PARTICIPANT': false
    },
    'GATEWAY': {
         'PARTICIPANT': false
    },
    'DATA': {
         'PARTICIPANT': false
    }
};

ConnectValidator.prototype.proMessageRules = {
    'TASK': {
        'START' : false,
        'INTERMEDIATE' : false,
        'TASK'  : true,
        'SUB_PROCESS': true,
        'GATEWAY': false,
        'END': false
    }
};


ConnectValidator.prototype.isValid = function (sourceShape, targetShape) {
    
    var result = {
                result : false,
                msg: 'Invalid Connections'.translate()
            },
        connections,
        rules,
        i;
    //type of shapes
    if (this.getTypeToValidate(sourceShape) && this.getTypeToValidate(targetShape)) {
        result.msg= 'Invalid Connection';
        //validate if there is an current connection between same elements
        connections = sourceShape.canvas.getConnections();
        for (i = 0; i < connections.getSize(); i +=1) {
            if (connections.get(i).getSrcPort().parent.getID() === sourceShape.getID() &&  connections.get(i).getDestPort().parent.getID() === targetShape.getID()) {
                result.result = false;
                result.msg= 'There is a connection between these elements'.translate();
                return result;
            }
        }
        //verify if elenents are into the same process
        if (sourceShape.businessObject
            && targetShape.businessObject
            && sourceShape.businessObject.$parent.id !== targetShape.businessObject.$parent.id) {

            switch (sourceShape.type) {
                case 'PMActivity':
                    if (targetShape.type === 'PMActivity') {
                        result.result = true;
                    } else if (targetShape.type === 'PMEvent' && targetShape.evn_marker === 'MESSAGECATCH') {
                        result.result = true;
                    }
                    break;
                case 'PMEvent':
                    if (sourceShape.type === 'PMEvent' && sourceShape.evn_marker === 'MESSAGETHROW') {
                        if (targetShape.type === 'PMActivity') {
                            result.result = true;
                        } else if (targetShape.type === 'PMEvent' && targetShape.evn_marker === 'MESSAGECATCH') {
                            result.result = true;
                        }
                    }
                    break;
            }
            if (result.result) {
                result.result = true;
                targetShape.setConnectionType({
                    type: 'MESSAGE',
                    segmentStyle:'segmented',
                    destDecorator: 'mafe-message',
                    srcDecorator: 'mafe-message'
                });
            }
        } else {
            if (this.initRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)]) {
                //result.result = this.initRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)];
                rules = this.initRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)];
                switch(rules) {
                    case 'sequencialRules':
                        if (this.sequencialRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)]) {
                            result.result = this.sequencialRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)];
                        }
                        targetShape.setConnectionType({
                            type: 'SEQUENCE',
                            segmentStyle:'regular',
                            destDecorator: 'mafe-sequence'
                        });
                        break;
                    case 'messageRules':
                        if (this.messageRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)]) {
                            result.result = this.messageRules[this.getTypeToValidate(sourceShape)][this.getTypeToValidate(targetShape)];
                            if (result.result) {
                                if(sourceShape.extendedType === 'START' && sourceShape.evn_marker === "MESSAGE") {
                                    result.result = false;
                                    result.msg= 'Start Event must not have any outgoing Message Flows'.translate();
                                }
                            }
                        }
                        // result.result = true;
                        targetShape.setConnectionType({
                            type: 'MESSAGE',
                            segmentStyle:'segmented',
                            destDecorator: 'mafe-message',
                            srcDecorator: 'mafe-message'
                        });
                        break;
                    case 'annotationRules':
                        result.result = true;
                        targetShape.setConnectionType({
                            type: 'ASSOCIATION',
                            segmentStyle:'dotted',
                            destDecorator: 'mafe-default'
                        });
                        break;
                    case 'associationRules':
                        result.result = true;
                        targetShape.setConnectionType({
                            type: 'DATAASSOCIATION',
                            segmentStyle:'dotted',
                            destDecorator: 'mafe-association'
                        });
                        break;
                }
            }
        }

        
    }
    return result;
};

ConnectValidator.prototype.oneToOneValidator = function (sourceShape) {
     var result = {
                result :true,
                msg: 'Invalid Connections'.translate()
            };
    connections = sourceShape.canvas.getConnections();
    for (i = 0; i < connections.getSize(); i +=1) {
        if (connections.get(i).getSrcPort().parent.getID() === sourceShape.getID()) {
            result.result = false;
            result.msg= 'The source shape can not have more of one connections'.translate();
        }
    }
    return result;
};

ConnectValidator.prototype.getTypeToValidate = function (shape) {
    var type;
    switch(shape.extendedType) {
    case 'START':
    case 'END':
    case 'INTERMEDIATE':
    case 'TASK':
    case 'SUB_PROCESS':
    case 'PARTICIPANT':
    case 'TEXT_ANNOTATION':
        type = shape.extendedType;
    break;
    case 'EXCLUSIVE':
    case 'PARALLEL':
    case 'INCLUSIVE':
    case 'COMPLEX':
        type = 'GATEWAY';
    break;
    case 'DATAOBJECT':
    case 'DATASTORE':
    case 'DATAINPUT':
    case 'DATAOUTPUT': 
        type = 'DATA';
    break;
    default:
        type = 'TASK';
    break;

    }
    return type;
};
var CommandChangeGatewayType = function (receiver, options) {
    PMUI.command.Command.call(this, receiver);
    this.before = null;
    this.after = null;
    CommandChangeGatewayType.prototype.initObject.call(this, options);
};

//CommandChangeGatewayType.prototype = new PMUI.command.Command();
PMUI.inheritFrom('PMUI.command.Command', CommandChangeGatewayType);
/**
 * Type of the instances of this class
 * @property {String}
 */
CommandChangeGatewayType.prototype.type = "CommandChangeGatewayType";

/**
 * Initializes the command parameters
 * @param {PMUI.draw.Core} receiver The object that will perform the action
 */
CommandChangeGatewayType.prototype.initObject = function (options) {

    var parsedClass = options;
    this.layer = this.receiver.getLayers().get(0);
    //layer.setZoomSprites(newSprite);

    this.before = {
        zoomSprite: this.layer.zoomSprites,
        type: this.receiver.extendedType
    };
//    if (options === 'COMPLEX') {
//        parsedClass = 'EXCLUSIVE';
//    }
    this.after = {
        zoomSprite: [
            'mafe-gateway-' + parsedClass.toLowerCase() + '-20',
            'mafe-gateway-' + parsedClass.toLowerCase() + '-30',
            'mafe-gateway-' + parsedClass.toLowerCase() + '-41',
            'mafe-gateway-' + parsedClass.toLowerCase() + '-51',
            'mafe-gateway-' + parsedClass.toLowerCase() + '-61'
        ],
        type: options
    };
};

/**
 * Executes the command, changes the position of the element, and if necessary
 * updates the position of its children, and refreshes all connections
 */
CommandChangeGatewayType.prototype.execute = function () {
    var menuShape;
    this.layer.setZoomSprites(this.after.zoomSprite);
    this.layer.paint();
    this.receiver.setGatewayType(this.after.type);
    this.receiver.extendedType = this.after.type;
    this.receiver
        .updateBpmGatewayType(this.receiver.mapBpmnType[this.after.type]);
    //PMDesigner.project.setDirty(true);
    PMDesigner.project.updateElement([]);
    //$(this.receiver.canvas.html).trigger('changeelement');
    //this.receiver.canvas.onChangeElementHandler(this.receiver);

    menuShape = PMDesigner.getMenuFactory(this.after.type);
    this.receiver.setContextMenu(menuShape);

};

/**
 * Returns to the state before the command was executed
 */
CommandChangeGatewayType.prototype.undo = function () {
    this.layer.setZoomSprites(this.before.zoomSprite);
    this.layer.paint();
    this.receiver.setGatewayType(this.before.type);
    this.receiver.extendedType = this.before.type;
    this.receiver
        .updateBpmGatewayType(this.receiver.mapBpmnType[this.before.type]);
    PMDesigner.project.setDirty(true);
    $(this.receiver.html).trigger('changeelement');

    menuShape = PMDesigner.getMenuFactory(this.before.type);
    this.receiver.setContextMenu(menuShape);
};

/**
 *  Executes the command again after an undo action has been done
 */
CommandChangeGatewayType.prototype.redo = function () {
    this.execute();
};


    var CommandDefaultFlow = function (receiver, options) {
        PMUI.command.Command.call(this, receiver);
        this.before = null;
        this.after = null;
        CommandDefaultFlow.prototype.initObject.call(this, options);
    };

    //CommandChangeGatewayType.prototype = new PMUI.command.Command();
    PMUI.inheritFrom('PMUI.command.Command', CommandDefaultFlow);
    /**
     * Type of the instances of this class
     * @property {String}
     */
    CommandChangeGatewayType.prototype.type = "CommandDefaultFlow";

    /**
     * Initializes the command parameters
     * @param {PMUI.draw.Core} receiver The object that will perform the action
     */
    CommandDefaultFlow.prototype.initObject = function (options) {

        this.before = {
            id: this.receiver.gat_default_flow
        };
        this.after = {
            id: options
        };
    };

    /**
     * Executes the command, changes the position of the element, and if necessary
     * updates the position of its children, and refreshes all connections
     */
    CommandDefaultFlow.prototype.execute = function () {
        this.receiver.setDefaultFlow(this.after.id);

    };

    /**
     * Returns to the state before the command was executed
     */
    CommandDefaultFlow.prototype.undo = function () {
         this.receiver.setDefaultFlow(this.before.id);
    };

    /**
     *  Executes the command again after an undo action has been done
     */
    CommandDefaultFlow.prototype.redo = function () {
        this.execute();
    };


/**
 * @class PMArtifact
 * Handle BPMN Annotations
 *
 *
 * @constructor
 * Creates a new instance of the class
 * @param {Object} options
 */
var PMLabel = function (options) {
    PMShape.call(this, options);
    /**
     * Defines the type artifact
     * @type {String}
     */
    this.art_type = null;
    /**
     * Defines the unique identifier
     * @type {String}
     */
    this.art_uid = null;

    PMArtifact.prototype.initObject.call(this, options);
};
PMLabel.prototype = new PMShape();

/**
 * Defines the object type
 * @type {String}
 */
PMLabel.prototype.type = "PMArtifact";
PMLabel.prototype.PMArtifactResizeBehavior = null;

/**
 * Initialize the object with the default values
 * @param {Object} options
 */
PMArtifact.prototype.initObject = function (options) {
    var defaults = {
        art_type: 'PMArtifact',
        art_name: ""
    };
    
    jQuery.extend(true, defaults, options);
    this.setArtifactUid(defaults.art_uid);
    this.setArtifactType(defaults.art_type);
    this.setName(defaults.art_name);
    
};

/**
 * Sets the artifact type property
 * @param {String} type
 * @return {*}
 */
PMLabel.prototype.setArtifactType = function (type) {
    this.art_type = type;
    return this;
};
/**
 * Sets the artifact unique identifier
 * @param {String} value
 * @return {*}
 */
PMLabel.prototype.setArtifactUid = function (value) {
    this.art_uid = value;
    return this;
};
/**
 * Returns the clean object to be sent to the backend
 * @return {Object}
 */
PMLabel.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        art_uid: this.id,
        art_name: name,
        art_type: this.art_type,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};

PMLabel.prototype.getArtifactType = function () {
    return this.art_type;
};
PMLabel.prototype.createLayer = function (options) {

    var layer;
    options.parent = this;
    layer = new CustomLayer(options);
    this.addLayer(layer);
    return layer;
};
PMArtifact.prototype.updateHTML = function () {
    var height,width;
    height = this.height;
    width = this.width;
    PMShape.prototype.updateHTML.call(this); 
    this.setDimension(width,height);       
    return  this;
};
/*global jCore, $ */
/**
 * @class AdamMarker
 * Handle Activity Markers
 *
 * @constructor
 * Creates a new instance of the class
 * @param {Object} options
 */
var PMMarker = function (options) {
    //jCore.Shape.call(this, options);
    PMUI.draw.Shape.call(this, options);
    /**
     * Defines the positions of the markers
     * @type {Array}
     * @private
     */
    this.positions = ['left+2 top+2', 'center top+5', 'right top+5',
        'left+5 bottom-1', 'center bottom-2', 'right-5 bottom-1'];
    /**
     * Defines the offset of the markers
     * @type {Array}
     * @private
     */
    this.offset =  ['5 5', '0 5', '0 5', '5 -1', '0 -1', '-5 -1'];
    /**
     * Define the marker type property
     * @type {null}
     */
    this.markerType = null;
    PMMarker.prototype.initObject.call(this, options);
};
PMMarker.prototype = new PMUI.draw.Shape();
/**
 * Defines the object type
 * @type {String}
 */
PMMarker.prototype.type = 'PMMarker';

/**
 * Initialize the object with the default values
 * @param {Object} options
 */
PMMarker.prototype.initObject = function (options) {
    var defaults = {
        canvas: null,
        parent: null,
        position: 0,
        width: 21,
        height: 21,
        markerZoomClasses: [],
        markerType: null
    };
    $.extend(true, defaults, options);
    this.setParent(defaults.parent)
        .setPosition(defaults.position)
        .setHeight(defaults.height)
        .setWidth(defaults.width)
        .setMarkerZoomClasses(defaults.markerZoomClasses)
        .setMarkerType(defaults.markerType);
};

/**
 * Applies zoom to the Marker
 * @return {*}
 */
PMMarker.prototype.applyZoom = function () {
    var newSprite;
    this.removeAllClasses();
    this.setProperties();
    newSprite = this.markerZoomClasses[this.parent.canvas.zoomPropertiesIndex];
    this.html.className = newSprite;
    this.currentZoomClass = newSprite;
    return this;
};

/**
 * Create the HTML for the marker
 * @return {*}
 */
PMMarker.prototype.createHTML = function () {
    PMUI.draw.Shape.prototype.createHTML.call(this);

    this.html.id = this.id;
    this.setProperties();
    this.html.className = this.markerZoomClasses[
        this.parent.canvas.getZoomPropertiesIndex()
    ];
    this.currentZoomClass = this.html.className;
    this.parent.html.appendChild(this.html);
    return this.html;
};

/**
 * Updates the painting of the marker
 * @param update
 */
PMMarker.prototype.paint = function (update) {
    if (this.getHTML() === null || update) {
        this.createHTML();
    }
    $(this.html).position({
        of: $(this.parent.html),
        my: this.positions[this.position],
        at: this.positions[this.position],
        //offset: this.offset[this.position],
        collision: 'none'
    });
};

/**
 * Sets the marker type property
 * @param {String} newType
 * @return {*}
 */
PMMarker.prototype.setMarkerType = function (newType) {
    this.markerType = newType;
    return this;
};

/**
 * Sets the position of the marker
 * @param {Number} newPosition
 * @return {*}
 */
PMMarker.prototype.setPosition = function (newPosition) {
    if (newPosition !== null && typeof newPosition === 'number') {
        this.position = newPosition;
    }
    return this;
};

/**
 * Sets the parent of the marker
 * @param {AdamActivity} newParent
 * @return {*}
 */
PMMarker.prototype.setParent = function (newParent) {
    this.parent = newParent;
    return this;
};

/**
 * Sets the elements class
 * @param eClass
 * @return {*}
 */
PMMarker.prototype.setEClass = function (eClass) {
    this.currentZoomClass = eClass;
    return this;
};

/**
 * Sets the array of zoom classes
 * @param {Object} classes
 * @return {*}
 */
PMMarker.prototype.setMarkerZoomClasses = function (classes) {
    this.markerZoomClasses = classes;
    return this;
};

/**
 * Sets the marker HTML properties
 * @return {*}
 */
PMMarker.prototype.setProperties = function () {
    this.html.style.width = this.width * this.parent.getCanvas().getZoomFactor() + 'px';
    this.html.style.height = this.height * this.parent.getCanvas().getZoomFactor() + 'px';
    return this;
};

/**
 * Remove all classes of HTML
 * @return {*}
 */
PMMarker.prototype.removeAllClasses = function () {
    this.html.className = '';
    return this;
};

/*global jCore*/
var PMActivityResizeBehavior = function () {
};

PMActivityResizeBehavior.prototype = new PMUI.behavior.RegularResizeBehavior();
PMActivityResizeBehavior.prototype.type = "PMActivityResizeBehavior";


/**
 * Sets a shape's container to a given container
 * @param container
 * @param shape
 */
PMActivityResizeBehavior.prototype.onResizeStart = function (shape) {
    return PMUI.behavior.RegularResizeBehavior
        .prototype.onResizeStart.call(this, shape);
};
/**
 * Removes shape from its current container
 * @param shape
 */
PMActivityResizeBehavior.prototype.onResize = function (shape) {
    //RegularResizeBehavior.prototype.onResize.call(this, shape);
    return function (e, ui) {
        PMUI.behavior.RegularResizeBehavior
            .prototype.onResize.call(this, shape)(e, ui);
        //if (shape.graphics) {
            shape.paint();
        //}

    };

};

/**
 * @class PMGateway
 * @param {Object} options
 */
var PMData = function (options) {
    PMShape.call(this, options);

    this.dat_name = '';
    this.dat_type = 'DATAOBJECT';
    this.dat_is_collection = false;
    this.dat_is_global = false;
    this.dat_object_ref = '';
    this.dat_is_unlimited = false;
    this.dat_capacity = 0;


    PMData.prototype.init.call(this, options);
};
    

PMData.prototype = new PMShape();
/**
 * Defines the object type
 * @type {String}
 */
PMData.prototype.type = 'PMData';


PMData.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        dat_uid: this.dat_uid,
        dat_name: name,
        dat_type: this.dat_type,
        
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};

/**
 * Initialize the PMData object
 * @param options
 */
PMData.prototype.init = function (options) {
    var defaults = {
       dat_name: '',
       dat_type: '',
       dat_is_collection: false,
       dat_is_global: false,
       dat_object_ref: '',
       dat_is_unlimited: false,
       dat_capacity: 0
    };
    jQuery.extend(true, defaults, options);
    this.setDataUid(defaults.dat_uid)
        .setDataType(defaults.dat_type);
    if (defaults.dat_name) {
        this.setName(defaults.dat_name);
    }
};

//GETTER
/**
 * Gets BPMNShape type
 * @returns {string}
 */
PMData.prototype.getDataType = function () {
    return this.dat_type;
};

/**
 * Gets Data Name
 * @returns {string}
 */
PMData.prototype.getDataName = function () {
    return this.dat_name;
};

/**
 * Gets Data Capasity
 * @returns {*}
 */
PMData.prototype.getCapacity = function() {
    return this.dat_capacity;
};

/**
 * Gets Data global value
 * @returns {boolean}
 */
PMData.prototype.getIsGlobal = function() {
    return this.dat_is_global;
};

/**
 * Gets Data Unlimited value
 * @returns {boolean}
 */
PMData.prototype.getUnlimited = function(){
    return this.dat_is_unlimited;
};

/**
 * Gets Data collection status
 * @returns {boolean}
 */
PMData.prototype.getDataCollection = function(){
    return this.dat_is_collection;
};
/**
 * Gets Data type
 * @returns {string}
 */

PMData.prototype.getDataType = function () {
    return this.dat_type;
};


//SETTERS
/**
 * Sets the act_uid property
 * @param {String} value
 * @return {*}
 */
PMData.prototype.setDataUid = function (value) {
    this.dat_uid = value;
    return this;
};
/**
 * Sets Data name
 * @param {string} newName
 * @chainable
 */
PMData.prototype.setName = function (name) {
    if (typeof name !== 'undefined') {
        this.act_name = name;
        if (this.label) {
            this.label.setMessage(name);
        }
    }
    return this;
};

/**
 * Sets BPMNData type
 * @param {string} newType
 * @chainable
 */
PMData.prototype.setDataType = function (newType) {
    if (!newType || typeof newType === 'undefined') {
        return;
    }
    this.dat_type = newType;
    return this;
};



/**
 * Sets Data global mode
 * @param {boolean} isGlobal
 * @returns {*}
 */
PMData.prototype.setIsGlobal = function(isGlobal) {
    if(typeof isGlobal !== 'undefined'){
        this.dat_is_global = isGlobal;
    }
    return this;
};
/**
 * Sets Data capasity
 * @param {string} capacity
 * @returns {*}
 */
PMData.prototype.setCapacity = function(capacity){
    if(typeof capacity === 'undefined')
        return;
    this.dat_capacity = capacity;
    return this;
};
/**
 * Setd data unlimited mode
 * @param {boolean} unlimited
 * @returns {*}
 */
PMData.prototype.setIsUnlimited = function(unlimited){
    if(typeof unlimited === 'undefined')
        return;
    this.dat_is_unlimited = unlimited;
    return this;
};

/**
 * Sets Data collection mode
 * @param {boolean} collection
 * @returns {*}
 */
PMData.prototype.setIsCollection= function(collection){
    if(typeof collection === 'undefined')
        return;
    this.dat_is_collection = collection;
    return this;
};

/**
 * Change data type 
 * @param {String} type
 * @returns {*}
 */
PMData.prototype.switchDataType= function(type){
    var marker = this.markersArray.get(0),
        lowerType = type.toLowerCase();
    marker.removeAllClasses();
    marker.setMarkerZoomClasses([
                                "mafe-" + lowerType + "-marker-10",
                                "mafe-" + lowerType + "-marker-15",
                                "mafe-" + lowerType + "-marker-21",
                                "mafe-" + lowerType + "-marker-26",
                                "mafe-" + lowerType + "-marker-31"
                            ]);
    marker.paint(true);
    this.setDataType(type);
    return this;
};

PMData.prototype.createWithBpmn = function(bpmnElementType, businessObject) {
    if (this.extendedType === 'DATASTORE') {
        var ds = PMDesigner.bpmnFactory.create('bpmn:DataStore', {id: this.id, name: this.getName() });
        PMDesigner.businessObject.get('rootElements').push(ds);

        businessObject = PMDesigner.bpmnFactory.create('bpmn:DataStoreReference', {id: this.id + '_ref', name: this.getName(), dataStoreRef: ds});
        businessObject.dsRef = ds;


    } else {
        var dObj = PMDesigner.bpmnFactory.create('bpmn:DataObject', {id: this.id, name: this.getName() });
        businessObject = PMDesigner.bpmnFactory.create('bpmn:DataObjectReference', {id: this.id +'_ref' , name: this.getName(), dataObjectRef: dObj});
        this.updateSemanticParent(dObj, this.parent.businessObject);
        //size = this._getDefaultSize(businessObject);
        businessObject.doRef = dObj;

    }
    if (!businessObject.di) {
        businessObject.di = PMDesigner.bpmnFactory.createDiShape(businessObject, {}, {
            id: businessObject.id + '_di'
        });

    }

    this.businessObject = businessObject;

};
var PMParticipant = function(options) {
    PMShape.call(this, options);
    //PAR_NAME (String)
    /**
     *
     * @type {String}
     */
    this.name ='';
    //PAR_IS_HORIZONTAL (inherited)
    //this.type ='';
    //PRO_UID (String)
    /**
     *
     * @type {String}
     */
    this.proUid = '';

    //LAN_CHILD_LANESET (String)
    /**
     *
     * @type {String}
     */
    this.childLaneset = '';

    //PAR_NUM_PARTICIPANTS (Number)
    /**
     *
     * @type {Number}
     */
    this.numParticipants = 0;

    this.graphic = null;
    this.headLineCoord =40;
    this.orientation = 'HORIZONTAL';

    PMParticipant.prototype.initObject.call(this, options);
} ;

PMParticipant.prototype = new PMShape();
PMParticipant.prototype.type = 'PMParticipant';
PMParticipant.prototype.participantResizeBehavior = null;

PMParticipant.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        par_uid: this.par_uid,
        par_name: name,
        //dat_type: this.dat_type,
        
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};

PMParticipant.prototype.initObject = function (options) {
    var defaultOptions = {
        name : 'Participant',
        numParticipants: 0,
        orientation: 'HORIZONTAL'
    };
    $.extend(true, defaultOptions, options);

    this.setName(defaultOptions.name)
        .setNumparticipants(defaultOptions.numParticipants)
        .setOrientation(defaultOptions.orientation);
};


PMParticipant.prototype.createHTML = function () {
    PMShape.prototype.createHTML.call(this);    
    this.style.addClasses(['mafe_participant']);
    return this.html;
};

PMParticipant.prototype.paint = function(){
    var zoomFactor = this.canvas.zoomFactor;
    if (typeof this.graphic === 'undefined' || this.graphic === null) {
        this.graphic = new JSGraphics(this.id);
    } else {
        this.graphic.clear();
    }


    this.html.style.backgroundColor = (new PMUI.util.Color(255, 255, 255, 0.8)).getCSS();
    this.graphic.setColor('#3b4753'); //change color
    this.graphic.setStroke(2);
    //this.graphic.drawRect(0, 0, this.width, this.height);
    if (this.orientation === 'VERTICAL') {
        this.graphic.drawLine(0, this.headLineCoord * zoomFactor, this.zoomWidth,
             this.headLineCoord * zoomFactor);
        this.getLabels().get(0).setOrientation('horizontal');
        this.getLabels().get(0).setLabelPosition('top');
    } else {
        this.graphic.drawLine(this.headLineCoord * zoomFactor, 0,
            this.headLineCoord * zoomFactor,
            this.zoomHeight-5);
        this.getLabels().get(0).setOrientation('vertical');
        this.getLabels().get(0).setLabelPosition('center-left', 20, 0);

    }

    this.graphic.paint();
    
    if (PMDesigner.project.loaded) {
        this.canvas.hideAllFocusLabels();
        this.label.getFocus();
    }

};

/**
 * Change pool orientation dinamically
 * @param {String} orientation
 * @returns {BPMNPool}
 */
PMParticipant.prototype.changeOrientation = function (orientation){
    var command = new BPMNCommandUpdateOrientation(this, {
        before:  this.getOrientation(),
        after: orientation.toUpperCase()
    });
    command.execute();
    this.getCanvas().commandStack.add(command);
    return this;
};
//SETTERS
/**
 * Set participant name
 * @param {String} name
 * @returns {BPMNLane}
 */
PMParticipant.prototype.setName = function (name) {
    this.name = name;
    return this;
};
/**
 * Set participant name
 * @param {String} name
 * @returns {BPMNLane}
 */
PMParticipant.prototype.setType = function (newType) {
    this.type = newType;
    return this;
};
/**
 * Set process uid asociated to participant
 * @param {String} uid
 * @returns {BPMNLane}
 */
PMParticipant.prototype.setProUid = function (uid) {
    this.proUid = uid;
    return this;
};
/**
 * Set number of participants
 * @param {Number} uid
 * @returns {BPMNLane}
 */
PMParticipant.prototype.setNumparticipants = function (numParticipants) {
    this.numParticipants = numParticipants;
    return this;
};

/**
 * Set pool orientation
 * @param {String} orientation
 * @returns {BPMNLane}
 */
PMParticipant.prototype.setOrientation = function (orientation) {
    this.orientation = orientation;
    return this;
};

//GETTERS
/**
 * Get the participant name
 * @returns {String}
 */
PMParticipant.prototype.getName = function () {
    return this.name;
};
/**
 * Get the participant process uid
 * @returns {String}
 */
PMParticipant.prototype.getProUid = function () {
    return this.proUid;
};
/**
 * Get the number of participants
 * @returns {Number}
 */
PMParticipant.prototype.getNumParticipants = function () {
    return this.numParticipants;
};
/**
 * Get the type
 * @returns {Number}
 */
PMParticipant.prototype.getType = function () {
    return this.type;
};
/**
 * Get orientation
 * @returns {Number}
 */
PMParticipant.prototype.getOrientation = function () {
    return this.orientation;
};

PMParticipant.prototype.setResizeBehavior = function (behavior) {
        var factory = new PMUI.behavior.BehaviorFactory({
                products: {
                    "regularresize": PMUI.behavior.RegularResizeBehavior,
                    "Resize": PMUI.behavior.RegularResizeBehavior,
                    "yes": PMUI.behavior.RegularResizeBehavior,
                    "resize": PMUI.behavior.RegularResizeBehavior,
                    "noresize": PMUI.behavior.NoResizeBehavior,
                    "NoResize": PMUI.behavior.NoResizeBehavior,
                    "no": PMUI.behavior.NoResizeBehavior,
                    "participantResize": PMParticipantResizeBehavior
                },
                defaultProduct: "noresize"
            });
        this.resizeBehavior = factory.make(behavior);
        if (this.html) {
            this.resize.init(this);
        }
        return this;
};

PMParticipant.prototype.onMouseOver = function (shape) {
    //var that = this;
    return function (e, ui) {
        
        if (shape.canvas.isDragging || shape.canvas.currentLabel ||shape.entered  || shape.canvas.isResizing) {
                shape.canvas.hideDragConnectHandlers();
                return;
        }
        if (!shape.canvas.isDraggingConnectHandler && !shape.dragging &&
            !shape.canvas.currentSelection.find('id', shape.id) &&
            !shape.canvas.currentConnection &&
            !shape.canvas.isMouseDown) {
        
            if (shape.extendedType === "TEXT_ANNOTATION") {
                shape.canvas.hideDragConnectHandlers();
                shape.showConnectDragHelpers(3,shape);
                for (i = 0; i < shape.canvas.dragConnectHandlers.getSize(); i += 1) {
                //for (i = 0; i < 4; i += 1) {
                    connectHandler = shape.canvas.dragConnectHandlers.get(i);
                    connectHandler.relativeShape = shape;
                    connectHandler.attachListeners();
                }
            } else {
                if (shape.extendedType !== "H_LABEL" && shape.extendedType !== "V_LABEL") {
                    //for (i = 0; i < shape.canvas.dragConnectHandlers.getSize(); i += 1) {
                    shape.canvas.hideDragConnectHandlers();
                    for (i = 0; i < 10; i += 1) {
                        //shape.showConnectDragHelpers(i,shape);
                        connectHandler = shape.canvas.dragConnectHandlers.get(i);
                        connectHandler.setDimension(15*shape.canvas.getZoomFactor(),15*shape.canvas.getZoomFactor());
                        connectHandler.setPosition(shape.getZoomX()+ i*shape.getZoomWidth()/10 , shape.getZoomY()-connectHandler.height/2 -1);
                        //connectHandler.paint();
                        
                        connectHandler.setVisible(true);
                        connectHandler.relativeShape = shape;
                        connectHandler.attachListeners();
                    }
                    
                      for (i = 0; i < 10; i += 1) {
                        //shape.showConnectDragHelpers(i,shape);
                        connectHandler = shape.canvas.dragConnectHandlers.get(i+10);
                        connectHandler.setDimension(15*shape.canvas.getZoomFactor(),15*shape.canvas.getZoomFactor());
                        connectHandler.setPosition(shape.getZoomX()+ i*shape.getZoomWidth()/10 , shape.getZoomY()+ shape.getZoomHeight()-connectHandler.height/2 -1);
                        //connectHandler.paint();
                        
                        connectHandler.setVisible(true);
                        connectHandler.relativeShape = shape;
                        connectHandler.attachListeners();
                    }
                    
                }
            }
            shape.canvas.emptyCurrentSelection();
            
        }
        e.stopPropagation();
        
    };
};

PMParticipant.prototype.createBpmn = function(type) {
    var bpmnCollaboration;
    if (!(_.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"}))) {
        bpmnCollaboration = PMDesigner.moddle.create('bpmn:Collaboration', {id: 'pmui-' + PMUI.generateUniqueId()});
        //PMDesigner.businessObject.collaboration =  bpmnCollaboration
        PMDesigner.businessObject.get('rootElements').push(bpmnCollaboration);
        this.parent.businessObject.di.bpmnElement = bpmnCollaboration;
        bpmnCollaboration.participants = [];
        bpmnCollaboration.messageFlows = [];
    } else {
        bpmnCollaboration = _.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"});
    }

    this.createWithBpmn(type, 'participantObject');

    this.updateBounds(this.participantObject.di);
    //this.updateShapeParent();
    this.updateSemanticParent(this.participantObject, bpmnCollaboration);

    this.updateDiParent(this.participantObject.di, this.parent.businessObject.di);
    //}
    //PMDesigner.moddle.toXML(PMDesigner.businessObject, function (err, xmlStrUpdated) {
    //
    //    // xmlStrUpdated contains new id and the added process
    //});
};
PMParticipant.prototype.updateSemanticParent = function(businessObject, newParent) {

    if (businessObject.$parent === newParent) {
        return;
    }

    var children;

    if (businessObject.$parent) {
        // remove from old parent
        children = businessObject.$parent.get('participants');
        CollectionRemove(children, businessObject);
    }

    if (!newParent) {
        businessObject.$parent = null;
    } else {
        // add to new parent
        children = newParent.get('participants');
        children.push(businessObject);
        businessObject.$parent = newParent;
    }
};

PMParticipant.prototype.updateDiParent = function(di, parentDi) {
    PMShape.prototype.updateDiParent.call(this, di, parentDi);
};


PMParticipant.prototype.createBusinesObject = function() {

    //id: this.id,
    var participant = _.findWhere(this.participantObject.$parent.get('participants'), {id: this.id});

    var bpmnProcess =  PMDesigner.moddle.create('bpmn:Process', { id:  'pmui-' + PMUI.generateUniqueId() });
    PMDesigner.businessObject.get('rootElements').push(bpmnProcess);
    this.businessObject = bpmnProcess
    this.businessObject.di = this.canvas.businessObject.di;
    participant.processRef = bpmnProcess;
};

//remove bpmn section
PMParticipant.prototype.removeBpmn = function() {
    var coll, children, pros;

    if ((_.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"}))) {
        coll = _.findWhere(PMDesigner.businessObject.get('rootElements'), {$type: "bpmn:Collaboration"});
        if (coll.participants.length === 1){
            children = PMDesigner.businessObject.get('rootElements');
            CollectionRemove(children, coll);
            //PMDesigner.businessObject.get
            this.parent.businessObject.di.bpmnElement = this.parent.businessObject;
        }
    }
    if (this.businessObject && (_.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Process", id: this.businessObject.id})) ) {
        pros = _.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Process", id: this.businessObject.id});
        //if (pros.participants.length === 1){
        children = PMDesigner.businessObject.get('rootElements');
        CollectionRemove(children, pros);
        this.businessObject = null;
        //PMDesigner.businessObject.get
        //this.parent.businessObject.di.bpmnElement = this.parent.businessObject;

        // }
    }
    this.updateSemanticParent(this.participantObject);
    this.updateDiParent(this.participantObject.di);
};

PMParticipant.prototype.updateBpmn = function() {
    this.updateBounds(this.participantObject.di);

};
/*global jCore*/
var PMParticipantResizeBehavior = function () {
};

PMParticipantResizeBehavior.prototype = new PMUI.behavior.RegularResizeBehavior();
PMParticipantResizeBehavior.prototype.type = "PMParticipantResizeBehavior";


/**
 * Sets a shape's container to a given container
 * @param container
 * @param shape
 */
PMParticipantResizeBehavior.prototype.onResizeStart = function (shape) {
    return PMUI.behavior.RegularResizeBehavior
        .prototype.onResizeStart.call(this, shape);
};
/**
 * Removes shape from its current container
 * @param shape
 */
PMParticipantResizeBehavior.prototype.onResize = function (shape) {
    //RegularResizeBehavior.prototype.onResize.call(this, shape);
    return function (e, ui) {
        PMUI.behavior.RegularResizeBehavior
            .prototype.onResize.call(this, shape)(e, ui);
        if (shape.graphic) {
            shape.paint();
        }

    };
};


var PMPoolResizeBehavior = function () {
    
};

PMPoolResizeBehavior.prototype = new PMUI.behavior.RegularResizeBehavior();
PMPoolResizeBehavior.prototype.type = "PMPoolResizeBehavior";


/**
 * Sets a shape's container to a given container
 * @param container
 * @param shape
 */
PMPoolResizeBehavior.prototype.onResizeStart = function (shape) {
    return function (e, ui) {
        PMUI.behavior.RegularResizeBehavior
            .prototype.onResizeStart.call(this, shape)(e, ui);
        shape.hideAllChilds();
    };
};
/**
 * Removes shape from its current container
 * @param shape
 */
PMPoolResizeBehavior.prototype.onResize = function (shape) {
    //RegularResizeBehavior.prototype.onResize.call(this, shape);

    return function (e, ui) {
        var i,
            port,
            canvas = shape.canvas;
        shape.setPosition(ui.position.left / canvas.zoomFactor,
            ui.position.top / canvas.zoomFactor);
        shape.setDimension(ui.size.width / canvas.zoomFactor,
            ui.size.height / canvas.zoomFactor);
        // fix the position of the shape's ports (and the positions and port
        // position of its children)
        // parameters (shape, resizing, root)
        //

        // fix the labels positions on resize (on x = false and y = true)
        shape.updateLabelsPosition(false, true);
        //shape.refactorLanePosition();
        if (shape.graphic) {
            shape.paint();
        }

    };

};
/**
 * Adds a shape to a given container
 * @param container
 * @param shape
 */
PMPoolResizeBehavior.prototype.onResizeEnd = function (shape) {
    return function (e, ui) {
        var i,
            size,
            label,
            command;
        shape.resizing = false;
        shape.canvas.isResizing = false;
        // last resize
        PMUI.behavior.RegularResizeBehavior.prototype.onResize.call(this, shape)(e, ui);

        // show the handlers again
        shape.showOrHideResizeHandlers(true);

        // update the dimensions of the parent if possible (a shape might
        // have been resized out of the dimensions of its parent)
        //shape.parent.updateDimensions(10);
        shape.updateOnResizeEnd();

        if (shape.ports) {
            shape.firePortsChange();
        }

        // TESTING COMMANDS
//        command = new CommandResize(shape);
//        shape.canvas.commandStack.add(command);
//        command.execute();
        for (i = 0, size = shape.labels.getSize(); i < size ; i += 1) {
            label = shape.labels.get(i);
            label.setLabelPosition(label.location, label.diffX, label.diffY);
        }

        var command = new PMCommandPoolResize(shape);
        command.execute();
        shape.getCanvas().commandStack.add(command);
        shape.fixConnectionsOnResize(shape.resizing, true);
        shape.refreshChildrenPositions(true);
        shape.refreshConnections(false, true);
        shape.showAllChilds();

    };

};

 //it is row superclass to add a the table
var RowField = function(options) {
    PMUI.form.Field.call(this,jQuery.extend(true, options, {
        required : false,
        labelWidth : "100%",
        colonVisible : false,
        controlsWidth : "85%",
        elementTag : 'tr'
    }));
    
    this.maxLength = options && options.maxLength ? options.maxLength : 60;

    this.errorToValid = null; 
    
    this.criteria = null;

    this.parent = null;

    RowField.prototype.init.call(this, options);
};

RowField.prototype = new PMUI.form.Field();

RowField.prototype.type = "RowField";
RowField.prototype.family = "Field";

RowField.prototype.init = function(options){
    var defaults = {
        valueType : 'string'
    };
    //this.validTypes = {string: true, integer: true, boolean: true, date: true, object: true, float : true, datetime :true};
    jQuery.extend(true, defaults, options);
   
    /*if(options) {
        this.setValueType(defaults.valueType);
    }*/
    //jQuery.extend(true, defaults , options);
};

RowField.prototype.createHTML = function (){
    var labelCell, controlCell, controlContainer, labelContainer;
    if(this.html){
        return this.html;
    }

    PMUI.core.Element.prototype.createHTML.call(this);
    labelCell = PMUI.createHTMLElement('td');
    labelCell.className = "mafe-field-labelCell";

    controlCell = PMUI.createHTMLElement('td');
    controlCell.className = "mafe-field-labelCell";

    labelContainer = PMUI.createHTMLElement('label');
    labelContainer.className = "mafe-label-container";
    labelContainer.innerHTML = this.label;
    labelCell.appendChild(labelContainer);
    if(this.controls.length){
        controlCell.appendChild(this.controls[0].getHTML());

        if(this.validError){
            controlCell.appendChild(this.validError.getHTML());
            if(!this.isValid()){
                this.validError.setVisible(true);
            }else{
                this.validError.setVisible(false);
            }
        }
        //this.validError.setErrorMessage(this.validators.RegExpValidator.errorMessage);
    }
    this.setValueToControls(this.value);
    this.setControlsWidth(this.controlsWidth);

    this.dom.labelContainer = labelContainer;
    this.dom.labelCell = labelCell;
    this.dom.controlCell = controlCell;
    this.setLabel(this.label);
    this.html.appendChild(labelCell);
    this.html.appendChild(controlCell);
    return this.html;
};

RowField.prototype.setLabel = function (label){
    if(typeof label === 'string') {
        this.label = label;
    } else {
        throw new Error("The setLabel() method only accepts string values!");
    }
    if(this.dom.labelContainer) {
        this.dom.labelContainer.innerHTML = this.label;
        if(this.controls[0]){
            this.dom.labelContainer.setAttribute('for',this.controls[0].id);
        }
    }
    return  this;
};

RowField.prototype.setPropertiesTable = function (table){
    if(table instanceof PropertiesTable) {
        this.parent = table;
    }
    return this;
};

RowField.prototype.onChangeHandler = function() {
    var that = this, i, newValue;

    return function() {
        var previousValue = that.value;

        that.updateValueFromControls();
        newValue = that.getValueFromControls();
        if( newValue === previousValue || newValue.length > that.maxLength) {
            that.setValue(previousValue);
            return this;
        }
        that.value = newValue;
        that.data.setValue(newValue);
        if(that.validError){
            if(that.validAtChange) {
                if(that.isValid()){
                    that.validError.setVisible(false);
                }else{
                    that.validError.setVisible(true);
                }
            }   
        }
        if(typeof that.onChange === 'function') {
            that.onChange(that.getValue(), previousValue);
        }
        if(that.parent) {
            (that.parent.onChangeHandler())(that, that.value, previousValue);
        }   
    };
};


/*
RowField.prototype.testTypeValue = function (type, value){
    var re;
    switch ( type ) {
        case 'float' :
            re=/^\d+(\.\d+)?$/;
        break;
        case 'string':
            re = /^([a-zA-Z1-9]+\s{1})*([a-zA-Z1-9])*$/i;
        break;
        case 'integer':
            re = /^(-)?[0-9]+$/
        break;
        case 'boolean':
            re = Boolean(value);
        break;
        case 'datetime' : 
            return(PMUI.control.DateTimeControl.prototype.isValidDateTime(PMUI.control.DateTimeControl.prototype.setValue(value)));
        break;  
    }
    return re.test(value);
};*/


RowField.prototype.setControlsWidth = function(width) {
    var i, labelWidthPx, auxWidth, autoGerateWidthForControls = false, fieldWidthIsAbsolute = false, fieldWidthIsRelative;

    if(!(width === 'auto' || typeof width === 'number' || jQuery.isArray(width) || /^\d+(\.\d+)?px/.test(width) || /^\d+(\.\d+)?%$/.test(width))){
        throw new Error("setControlsWidth(): The parameter must be a string \"auto\", or a number or an array.");
    }

    this.controlsWidth = width;

    if(width === 'auto') {
        autoGerateWidthForControls = true;
    }

    if(typeof this.width === 'number' || /^\d+(\.\d+)?px/.test(this.width)) {
        fieldWidthIsAbsolute = true;
    }
    if (/^\d+(\.\d+)?%$/.test(width)){
        fieldWidthIsRelative = true;
    }

    if(!autoGerateWidthForControls) {
        for(i = 0; i < this.controls.length; i++) {
            if(jQuery.isArray(width)) {
                this.controls[i].setWidth(width[i] || "auto");
            } else {
                this.controls[i].setWidth(width);
            }
        }            
    } else if(fieldWidthIsAbsolute) {
        auxWidth = parseInt(this.width, 10);
        labelWidthPx = auxWidth * (parseInt(this.labelWidth,10)/100) + 4;
        labelWidthPx = auxWidth - 83 - labelWidthPx;
        for(i = 0; i < this.controls.length; i++) {
            this.controls[i].setWidth(labelWidthPx);
        }
    } else if(fieldWidthIsRelative){
        for(i = 0; i < this.controls.length; i++) {
            this.controls[i].setWidth(width);
        }        
    }else {
        for(i = 0; i < this.controls.length; i++) {
            this.controls[i].setWidth("auto");
        }
    }     
    return this;
};

RowField.prototype.isValid = function() {
    var valid = true, validator;
 
    for(validator in this.validators) {
        if(this.validators.hasOwnProperty(validator)) {
            valid = valid && this.validators[validator].isValid();
            if(!valid) {
                this.message.setText(this.validators[validator].errorMessage);
                this.controls[0].style.addClasses(['error']);
                this.addCSSClasses(['error']);
                return valid;
            }else{
                this.controls[0].style.removeClasses(['error']);
                this.removeCSSClasses(['error']);
            }
        }
    }
    return valid;
};

RowField.prototype.addValidator = function(validator) {
    var newValidator;
    if(this.validatorFactory) {
        if(this.validatorFactory.isValidClass(validator) || this.validatorFactory.isValidName(validator.pmType)) {
            newValidator = this.validatorFactory.make(validator);
            if(validator.type === 'error'){
                this.validError = new PMUI.ui.TooltipMessage({
                    category: 'error',
                    visible : false,
                    message : validator.errorMessage,
                    width : 10,
                    style : {
                        cssProperties : {
                            'float' : 'right'
                        }
                    }
                });
            }
        } else {
            throw new Error('Invalid validator to add.');
        }
    }
    if(newValidator && newValidator instanceof PMUI.form.Validator) {
        newValidator.setParent(this);
        this.validators[newValidator.type] = newValidator;
    }
    return this;
};

RowField.prototype.setValue = function(value) {
    if(typeof value === 'number') {
        value = value.toString();
    }
    if(typeof value === 'string') {
        this.value = value;
    } else {
        this.value = '';
    }
    this.data.setValue(this.value);
    this.setValueToControls(this.value);
    return this;
};
var CheckBoxRowField = function (options){
    RowField.call(this, jQuery.extend(true,options,{
        valueType : 'boolean'
    }));
    CheckBoxRowField.prototype.init.call(this, options);
};
CheckBoxRowField.prototype = new RowField();

CheckBoxRowField.prototype.init = function (options){
    var defaults = {
        value : false
    };
    jQuery.extend(true, defaults, options);

    this.setValue(defaults.value);
};

CheckBoxRowField.prototype.setValue = function (value){
    value = value || false;
    if(typeof value !== "boolean"){
        throw new Error("Mafe.setValue(), parameter no valid");
    }
    this.value = value;
    this.data.setValue(this.value);
    this.setValueToControls(this.value);
    return this;

};
CheckBoxRowField.prototype.setValueToControls= function(value){
    if(this.controls.length){
        if(this.value){
            this.controls[0].select();
        }else{
            this.controls[0].deselect();
        }
    }
    return this;
};
CheckBoxRowField.prototype.setControls = function () {
    if(this.controls.length) {
           return this;
    }
    newOption = new PMUI.control.SelectableControl({
        mode: 'checkbox',
        height:15
    });
    this.controls.push(newOption);
    return this;
};

CheckBoxRowField.prototype.onChangeHandler = function() {
    var that = this, i, dependentFields = this.dependentFields, form = this.form;
    return function() {
        var previousValue = that.value;

        if (that.controls[0].selected){
                that.value = true;            
        }else{
                that.value = false;
        }
        //PMUI.triggerEvent(this, 'change', this);
        if(typeof that.onChange === 'function') {
            that.onChange(that.getValue(), previousValue);
        }

        if(that.parent) {
            (that.parent.onChangeHandler())(that, that.getValue(), previousValue);
        }
    };
};
var DropDownListRowField = function (options){
    RowField.call(this, options);
    DropDownListRowField.prototype.init.call(this, options);
};

DropDownListRowField.prototype = new RowField();

DropDownListRowField.prototype.init = function (options) {
    var defaults = {
        options : [],
        listWidth : 'auto',
        value: null
    };
    jQuery.extend(true, defaults, options);

    this.setOptions(defaults.options);
    //this.setListWidth(defaults.listWidth);
    this.updateValueFromControls();

    if(defaults.value !== null) {
        this.setValue(defaults.value);
    }
};

DropDownListRowField.prototype.setControls = function () {
    if(this.controls.length) {
           return this;
    }
    this.controls.push(new PMUI.control.DropDownListControl({
        height:25
    }));
    return this;
};

DropDownListRowField.prototype.setOptions = function(options){
    var i;
    if(jQuery.isArray(options)){
       this.controls[0].setOptions(options);
    }
    if(!this.value && options) {
        for(i = 0; i < options.length; i++) {
            if(options[i].selected) {
                this.initialValue = options[i].value || options[i].label || "";
                break;
            }
        }
    }
    this.value = this.controls[0].getValue();
    return this;
};
DropDownListRowField.prototype.getOptions = function (includeGroups) {
    return this.controls[0].getOptions(includeGroups);
};

DropDownListRowField.prototype.clearOptions = function() {
    this.controls[0].clearOptions();
    this.value = this.controls[0].value;
    return this;
};
DropDownListRowField.prototype.disableOption = function (option, group) {
    this.controls[0].disableOption(option, group);
    return this;
};

DropDownListRowField.prototype.enableOption = function (option, group) {
    this.controls[0].enableOption(option, group);
    return this;
};
DropDownListRowField.prototype.removeOption = function (option, group) {
    this.controls[0].removeOption(option, group);
    return this;
};

DropDownListRowField.prototype.addOptionGroup = function (optionGroup) {
      this.controls[0].addOptionGroup(optionGroup);
      return this;
 };

DropDownListRowField.prototype.addOption = function (option, group) {
      this.controls[0].addOption(option, group);
      if(this.getOptions().length == 1){
        this.value = this.controls[0].value;
      }
      return this;
 };

DropDownListRowField.prototype.setValue = function(value) {
    var val;
    if(this.controls[0]) {
        val = this.controls[0].setValue(value).getValue();
    }
    RowField.prototype.setValue.call(this, val || value);
    return this;
 };
var ButtonRow = function (options) {
    RowField.call(this, jQuery.extend(true,options,{
        valueType : 'string'
    }));
    this.onClick = null;
    ButtonRow.prototype.init.call(this, options);  
};

ButtonRow.prototype = new RowField();

ButtonRow.prototype.init = function (options) {
    var defaults = {
        onClick : null
    }
    jQuery.extend(true, defaults, options);
    this.setOnClickHandler(defaults.onClick);    
};

ButtonRow.prototype.setOnClickHandler = function (handler){
    if(!(handler === null || typeof handler === 'function')) {
        throw new Error("setOnClickHandler(): The parameter must be a function or null.");
    }
    this.onClick = handler;
    return this;
};

ButtonRow.prototype.onClickHandler = function() {
    var that = this;
    return function(button) {
        if(typeof that.onClick === 'function') {
            that.onClick(that, button);
        }
    };
};

ButtonRow.prototype.setControls = function () {
    var newOption;
    if(this.controls.length) {
           return this;
    }
    newOption = new PMUI.ui.Button({
        height : 20,
        handler: this.onClickHandler() 
    });
    this.controls.push(newOption);
    return this;
};
ButtonRow.prototype.setValueToControls = function(value) {
    var i;
    for(i = 0; i < this.controls.length; i += 1) {
        this.controls[i].setText(value);
    }
    return this;
};

ButtonRow.prototype.defineEvents = function() {
    var i;
    this.controls[0].defineEvents();
    return this;
};

ButtonRow.prototype.enable = function() {
    return this;
};
var TextRowField = function (options){
    RowField.call(this, options);
    this.placeholder = null;
    TextRowField.prototype.init.call(this, options);
};
TextRowField.prototype = new RowField();

TextRowField.prototype.init= function (options){
    var defaults  = {
        placeholder : ""
    }
    jQuery.extend(true, defaults, options);

    this.setPlaceholder(defaults.placeholder);
};

TextRowField.prototype.setPlaceholder = function(placeholder) {
    this.controls[0].setPlaceholder(placeholder);
    this.placeholder = placeholder;
    return this;
};

TextRowField.prototype.setControls = function() {
    if(this.controls.length) {
        return this;
    }
    this.controls.push(new PMUI.control.TextControl({height:25}));
    return this;
};

TextRowField.prototype.setLabelPosition = function (){
    return this;
};
TextRowField.prototype.setForm = function (){
    return this;
};
TextRowField.prototype.setRequiredMessage = function (){
    return this;
};
TextRowField.prototype.showHelper = function (){
    return this;
};
TextRowField.prototype.hideHelper = function (){
    return this;
};
TextRowField.prototype.setHelper = function (){
    return this;
};

TextRowField.prototype.createHTML = function (){
    RowField.prototype.createHTML.call(this);
    this.setPlaceholder(this.placeholder);
    return this.html;
};


	var TokenStream = function (tokens) {
	    this.cursor = 0;
	    this.tokens = tokens;
	};
	TokenStream.prototype.next = function() {
		return this.tokens[this.cursor++];
	};
	TokenStream.prototype.peek = function (direction) {
		if (direction === undefined) {
            direction = 0;
        }
        return this.tokens[this.cursor + direction];
	};


	var Tokenizer = function () {
	    this.tokens = {};
	    this.regex = null;
	    this.fields = [];
	    this.tokenNames = [];
	    this.tokenFields = {};
	};
	Tokenizer.prototype.addToken = function (name, expression) {
		this.tokens[name] = expression;
	};
	Tokenizer.prototype.addField = function (name, expression) {
		var expr;
		if ($.inArray(expression, this.fields) == -1) {
			this.fields.push(expression);
		}

		expr =this.fields.toString().replace(/,/g,"|");
		this.tokens[name] = expr;
	};
	
	Tokenizer.prototype.addTokenValue = function (name, value) {
		this.tokenFields[name] = (!parseFloat(value))? 0 : parseFloat(value);
	};
	Tokenizer.prototype.tokenize = function (data) {
		var tokens;
		this.buildExpression(data);
        tokens = this.findTokens(data);
        return new TokenStream(tokens);
	};
	Tokenizer.prototype.buildExpression = function (data) {
		var tokenRegex = [],
		tokenName;

	    for (tokenName in this.tokens) {
	        this.tokenNames.push(tokenName);
	        tokenRegex.push('('+this.tokens[tokenName]+')');
	    }
	    
	    this.regex = new RegExp(tokenRegex.join('|'), 'g');
	};
	Tokenizer.prototype.findTokens = function(data) {
        var tokens = [],
        match,
        group;

        while ((match = this.regex.exec(data)) !== null) {
            if (match == undefined) {
                continue;
            }

            for (group = 1; group < match.length; group++) {
                if (!match[group]) continue;
                
                tokens.push({
                    name: this.tokenNames[group - 1],
                    data: match[group],
                    value: null
                });
            }
        }

        return tokens;
    };

	/*
		Start Formula class
	*/
	var Formula = function (data) {
	    this.data = data.toString().replace(/\s/g, '');
	    this.tokenizer = new Tokenizer();
	    
	};
	Formula.prototype.initializeTokens = function () {
		this.tokenizer.addToken('whitespace', '\\s+');
	    this.tokenizer.addToken('l_paren', '\\(');
	    this.tokenizer.addToken('r_paren', '\\)');
	    this.tokenizer.addToken('float', '[0-9]+\\.[0-9]+');
	    this.tokenizer.addToken('int', '[0-9]+');
	    this.tokenizer.addToken('div', '\\/');
	    this.tokenizer.addToken('mul', '\\*');
	    this.tokenizer.addToken('add', '\\+');
	    this.tokenizer.addToken('sub', '\\-');
	    this.tokenizer.addToken('constant', 'pi|PI');
	    this.tokenizer.addToken('function', '[a-zA-Z_][a-zA-Z0-9_]*');
		return this;
	};
	/**
	 *
	 * @param type {String}
	 * @param type {Array}
	 *
	 */
	Formula.prototype.addToken = function (name, value) {
		this.tokenizer.addToken(name, value);
		return this;
	};
	Formula.prototype.addField = function (name, value) {
		this.tokenizer.addField(name, value);
		return this;
	};
	Formula.prototype.addTokenValue = function (name, value) {
		this.tokenizer.addTokenValue(name, value);
		return this;
	};
	Formula.prototype.consumeConstant = function(ts, token) {
		return 'Math.' + token.data.toUpperCase();
	};
	Formula.prototype.consumeField = function(ts, token) {
		return (this.tokenizer.tokenFields[token.data] === undefined) ? 0: this.tokenizer.tokenFields[token.data];
	
	};
	Formula.prototype.consumeFunction = function (ts, token) {
        var a = [token.data],
        t;
        while (t = ts.next()) {
            a.push(t.data);
            if (t.name == 'r_paren') {
                break;
            }
        }
        return 'Math.' + a.join('');
    };
    Formula.prototype.evaluate = function () {
        this.initializeTokens();
        var ts = this.tokenizer.tokenize(this.data),
        expr = [],
        e,
        t;
        
        while (t = ts.next()) {
            switch (t.name) {
                case 'int':
                case 'float':
                	expr.push({
                    	type: "number",
                    	label: t.data
                    });
                	break;
                case 'mul':
                case 'div':
                case 'sub':
                case 'add':
                    expr.push({
                    	type: "operation",
                    	label: t.data
                    });
                    break;
                case 'field':
	                expr.push({
	                	type: "field",
	                	label: t.data
	                });
            		//expr.push(this.consumeField(ts, t));
                	break;	
                case 'constant':
                    expr.push(this.consumeConstant(ts, t));
                    break;
                case 'l_paren':
                	expr.push({
	                	type: "bracket",
	                	label: t.data
	                });
                	break;
                case 'r_paren':
                	expr.push({
	                	type: "bracket",
	                	label: t.data
	                });
                	break;
                case 'function':
                    var n = ts.peek();
                    if (n && n.name == 'l_paren') {
                        expr.push(this.consumeFunction(ts, t));
                        continue;
                    }
                default:
                    break;
            }
        }

        e = expr.join('');
        
        return expr;
    };



/**
 * ItemControl class
 */
var ItemControl = function (options) {
	PMUI.core.Element.call(this, options);
    this.className = null;
    this.parent = null;
    this.label = null;
    this.value = null;
    this.type = null;
    this.dom = {};
    this.onClose = null;
	ItemControl.prototype.init.call(this, options);
};
ItemControl.prototype = new PMUI.core.Element();

ItemControl.prototype.init = function (options) {
    var defaults = {
        label: "Field",
        value: "1",
        type: "field",
        className: "pmdesigner-itemcontrol-itemselected",
        onClose: function () {}
    };
    $.extend(true, defaults, options);
    this.setClassName(defaults.className)
        .setLabel(defaults.label)
        .setValue(defaults.value)
        .setType(defaults.type)
        .setOnClose(defaults.onClose);
};
ItemControl.prototype.setClassName = function (className) {
    if (typeof className === "string") {
        this.className = className;
    }
    return this;
};
ItemControl.prototype.setLabel = function (label) {
    this.label = label;
    return this;
};
ItemControl.prototype.setValue = function (value) {
    this.value = value;
    return this;
};
ItemControl.prototype.setType = function (type) {
    this.type = type;
    return this;
};
ItemControl.prototype.setOnClose = function (fn) {
    this.onClose = fn;
    return this;
};
ItemControl.prototype.createHTML = function () {
    var container = document.createElement("div"),
    field = document.createElement("a"),
    fieldLabel = document.createElement("span"),
    fieldClose = document.createElement("span");
    container.id = this.id || 'pmui-' + PMUI.generateUniqueId();

    container.className = this.className;
    fieldLabel.innerHTML = this.label;
    fieldClose.innerHTML = "x";
    fieldClose.className = "pmdesigner-itemcontrol-x";
    fieldClose.title = "remove";
    $(fieldClose).tooltip()
    field.appendChild(fieldLabel);
    field.appendChild(fieldClose);
    container.appendChild(field);
    this.dom.close = fieldClose;
    this.html = container;
    return this.html;
};
ItemControl.prototype.defineEvents = function () {
    var that = this;
    this.addEvent("click").listen(this.dom.close, function (event){
        that.onClose(event, that)

    });
    return this;
};









/**
 * SuggestControl class
 */
var SuggestControl = function (options) {
	PMUI.core.Element.call(this, options);
    this.options = [];
    this.optionsFiltered = [];
    this.parent = null;
    this.dom= {};
    this.label= null;
    this.value = null;
    this.itemSelected = null;
    this.onClickItem = null;
    this.onChangeHandler = null;
	SuggestControl.prototype.init.call(this, options);
};
SuggestControl.prototype = new PMUI.core.Element();
SuggestControl.prototype.init = function (options) {
    var defaults = {    
        options:[],
        label: "Element",
        value: "",
        positionMode: "relative",
        onClickItem: function(){},
        onChangeHandler: function (){}
    };
    $.extend(true, defaults, options);
    this.setOptions(defaults.options)
        .setLabel(defaults.label)
        .setValue(defaults.value)
        .setPositionMode(defaults.positionMode)
        .setOnClickItem(defaults.onClickItem)
        .setOnChangeHandler(defaults.onChangeHandler)
};
SuggestControl.prototype.setOptions = function (options) {
    if (typeof options === "object") {
        this.options = options;
        this.optionsFiltered = options;
    }
    return this;
};
SuggestControl.prototype.setLabel  = function (name) {
    this.label = name;
    return this;
};
SuggestControl.prototype.setValue = function (value) {
    this.value = value;
    return this;
};
SuggestControl.prototype.setOnClickItem = function (fn) {
    this.onClickItem = fn;
    return this;
};
SuggestControl.prototype.setOnChangeHandler = function (fn) {
    this.onChangeHandler = fn;
    return this;
};
SuggestControl.prototype.filterOptions = function () {
    var fieldItems = this.parent.parent.parent.targetInDesigner.parent.parent.parent.getCellItems(),
    it = [],
    i,
    res,
    testItem,
    n;

    this.optionsFiltered = [];
    for (n=0; n<fieldItems.length; n+=1) {
        if (fieldItems[n] instanceof WrappedTextField) {
            it.push({
                label: fieldItems[n].name,
                value: fieldItems[n].name
            });
        }
    }

    try {
        if (!/\*|\\|\/|\(|\)|\?/.test(this.value)) {
            for (i=0; i<it.length; i+=1) {
                res = it[i].label.search(this.value);
                if (res >= 0 && this.value !== "") {
                    this.optionsFiltered.push(it[i]);
                }
            }
            this.optionsFiltered.sort();    
        }
    } catch(error) {}
    
    
    return this;
};
SuggestControl.prototype.createHTMLList = function () {
    var containerListFields = document.createElement("div"),
    listField = document.createElement("ul"),
    itemListField,
    labelItemField,
    itemField,
    res,
    k,
    l;

    containerListFields.className = "pmdesigner-suggestfields";

    for (k=0; k< this.optionsFiltered.length; k+=1) {
        itemField = document.createElement("a");
        for (l=0; l< this.optionsFiltered[k].label.length; l+=1) {
            labelItemField = document.createElement("span");
            res = this.optionsFiltered[k].label.search(this.value);
            for (m=0; m<this.value.length; m+=1) {
                if (this.optionsFiltered[k].label[l] === this.value[m]) {
                    labelItemField.innerHTML = this.optionsFiltered[k].label[l];
                    //labelItemField.className = "pmdesigner-suggestfields-characterselected";
                    labelItemField.setAttribute("type", "filter");
                    labelItemField.style.color = "rgb(114, 179, 238)";
                } else {
                    labelItemField.innerHTML = this.optionsFiltered[k].label[l];    
                }
            }

            itemField.appendChild(labelItemField);
        }
        
        itemListField = document.createElement("li");
        itemListField.appendChild(itemField);
        listField.appendChild(itemListField);

        this.defineEventsSuggest({
            html: itemField,
            label: this.optionsFiltered[k].label
        });
    }
    containerListFields.appendChild(listField);
    this.dom.suggest = containerListFields;

    return this.dom.suggest;
};

SuggestControl.prototype.createHTML = function () {
    var suggestControl = document.createElement("div"),
    fieldLabel = document.createElement("label"),
    fieldSpan = document.createElement("span"),
    fieldControl = document.createElement("input");

    fieldControl.setAttribute("placeholder", "new element");
    fieldControl.name = "suggestcontrol-textcontrol"
    suggestControl.className = "pmdesigner-suggestcontrol";
    fieldSpan.innerHTML = this.label;
    fieldLabel.appendChild(fieldSpan);
    fieldLabel.appendChild(fieldControl);
    suggestControl.appendChild(fieldLabel);
    this.dom.control = fieldControl;
    this.html = suggestControl;
    
    return this.html;
};
SuggestControl.prototype.removeSuggest = function (event) {
    document.getElementsByClassName("this.dom.suggest.className")
    if (this.dom.suggest) {
        if (document.getElementsByClassName("pmdesigner-suggestfields").length > 0) {
            this.html.removeChild(this.dom.suggest);
        }
    }
};
SuggestControl.prototype.clearControl = function () {
    this.dom.control.value = "";
    return this;
};
SuggestControl.prototype.defineEventsSuggest = function (suggestItem) {
    var that = this,
    a,
    buildItem,
    label = suggestItem.label,
    eventItem;
    this.addEvent("click").listen(suggestItem.html, function (event){
        buildItem = that.parent.addItem({
            label: label,
            value: label,
            type: "field",
            onClose: function (event, item) {
                that.parent.dom.areaFormula.removeChild(this.getHTML());
                that.parent.removeItemFormula(this);
                that.parent.onChangeHandler();
            }

        });
        
        that.onClickItem(event, buildItem, label);
        //that.onChangeHandler(e, that);
        that.parent.onChangeHandler();
        that.removeSuggest();
        that.clearControl();
    });
    this.addEvent("mouseover").listen(suggestItem.html, function (eventOriginal){
        eventItem = eventOriginal;
        $(eventOriginal.target).children("span").removeAttr("style");
        $(eventOriginal.target).children("span").mouseover(function(e) {
            $(eventOriginal.target).children("span").removeAttr("style");
        });
    });
    this.addEvent("mouseout").listen(suggestItem.html, function (eventOriginal){
        $(eventOriginal.target).children("span[type='filter']").css("color","rgb(114, 179, 238)");
    });
    
};
SuggestControl.prototype.defineEvents = function () {
    var that = this,
    buildItem,
    a;
    this.addEvent('keyup').listen(this.dom.control, function(e) {
        that.value = e.target.value;
        that.filterOptions();
        that.removeSuggest();
        if (that.value !== "") {
            that.createHTMLList();
            that.html.appendChild(that.dom.suggest);
        }
        if (e.which === 13) {
            if(that.optionsFiltered.length === 0 && 
                Number.isNaN(parseFloat(e.target.value)) === false) {
                buildItem = that.parent.addItem({
                    label: e.target.value, 
                    value: e.target.value,
                    type: "number",
                    onClose: function (event, item) {
                        that.parent.dom.areaFormula.removeChild(this.getHTML());
                        that.parent.removeItemFormula(this);
                        that.parent.onChangeHandler();
                    }
                });

                that.onClickItem(e, buildItem, e.target.value);
                //that.onChangeHandler(e, that);
                that.parent.onChangeHandler();
                that.clearControl();
            }    
        }
        
    });
    this.addEvent('blur').listen(this.dom.control, function(e) {
        //that.onChangeHandler(e, that);
        that.parent.onChangeHandler();
    });
    this.addEvent("click").listen(document, function (e){
        that.removeSuggest();
    });
    return this;
};












/**
 * AreaControl class
 */
var AreaControl = function (options) {
    this.type = null;
    this.attributes = null;
    this.dom = {};
    this.isCtrl = false;
    this.isShift = false;
    this.onKeyUp = null;
    this.suggestControl = null;
    this.operations = null;
    this.value = null;
    this.parent = null;
    this.items = new PMUI.util.ArrayList();
    this.valueArray = [];
    this.onClickOperation = null;
    AreaControl.prototype.init.call(this, options);
};
AreaControl.prototype = new PMUI.control.HTMLControl;
AreaControl.prototype.type = "areaField";
AreaControl.prototype.init = function (options) {
    var defaults = {
        attributes: {
            contenteditable: "true"
        },
        style: {
            cssProperties: {},
            cssClasses: ["pmdesigner-areacontrol"]
        },
        operations: [
            {
                label: "PLUS",
                value: "+"
            },
            {
                label: "MINUS",
                value: "-"
            },
            {
                label: "MULTIPLICATION",
                value: "*"
            },
            {
                label: "DIVISION",
                value: "/"
            },
            {
                label: "(",
                value: "("
            },
            {
                label: ")",
                value: ")"
            }
        ],
        parent: "",
        value: "",
        suggestControl: null,
        onKeyUp: function(){},
        onClickOperation: function(){},
        onChangeHandler: function(){}
    };
    $.extend(true, defaults, options);
    this.setStyle(defaults.style)
        .setValue(defaults.value)
        .setParent(defaults.parent)
        .setOnChangeHandler(defaults.onChangeHandler)
        .setSuggestControl(defaults.suggestControl)
        .setAttributes(defaults.attributes)
        .setOnKeyUp(defaults.onKeyUp)
        .setOperations(defaults.operations)
        .setOnClickOperation(defaults.onClickOperation);

};
AreaControl.prototype.setValue = function (value) { 
    this.value = value;
    return this;
};
AreaControl.prototype.setParent = function (parent) {
    this.parent = parent;
    return this;
};
AreaControl.prototype.getValue = function () {
    var i,
    formula,
    elements=[];
    for (i=0; i<this.valueArray.length; i+=1) {
        elements.push(this.valueArray[i].label);
    }
    formula = elements.join("");
    return formula;
};
AreaControl.prototype.setSuggestControl = function () {
    this.suggestControl = new SuggestControl({
        onChangeHandler: this.onChangeHandler
    });
    return this;
};
AreaControl.prototype.setAttributes = function (attributes) {
    if (typeof attributes === "object") {
        this.attributes = attributes;
    }
    return this;
};
AreaControl.prototype.setOnKeyUp = function () {

    return this;
};
AreaControl.prototype.setOnClickOperation = function () {

    return this;
};
AreaControl.prototype.setOnChangeHandler = function (fn) {
    this.onChangeHandler = fn;
    return this;
};
AreaControl.prototype.setOperations = function (operations) {
    this.operations = operations;
    return this;
};
AreaControl.prototype.setFormulaArray = function (values) {
    this.valueArray = values;
    return this;
};
AreaControl.prototype.addItemFormula = function (item) {

    this.valueArray.push({
        id: item.id,
        label: item.value,
        type: item.type
    });

    return this;
};
AreaControl.prototype.removeItemFormula = function (item) {
    var  j,
    valueNewArray=[];
    
    for (j=0; j<this.valueArray.length; j+=1) {
        if (this.valueArray[j].id !== item.id) {
            valueNewArray.push(this.valueArray[j]);
        }
    }
    this.valueArray = valueNewArray;
    return this;
};
AreaControl.prototype.reviewFormula = function () {
    var vals = this.valueArray,
    j;

    for (j=0; j<vals.length; j+=1) {
        if (j % 2 == 0) {
            //par
            if (vals[j].type === "field") {

            }
        } else {
            //impar

        }
        if (vals[0].type === "operation") {

        }    
    }
    return this;
};
AreaControl.prototype.addItem = function (newItem) {
    var buildItem, className;

    className = (newItem.type==="field" || newItem.type==="number")?
            "pmdesigner-itemcontrol-itemselected": (newItem.type==="operation"? 
            "pmdesigner-itemcontrol-optselected": "pmdesigner-itemcontrol-bracketsselected");
    newItem.className = className;

    buildItem = new ItemControl(newItem);
    this.dom.areaFormula.appendChild(buildItem.getHTML());
    buildItem.defineEvents();
    this.items.insert(buildItem);
    
    return buildItem;
};
AreaControl.prototype.createHTMLFormulaDefault = function () {
    var that = this,
    fields = this.valueArray,
    buildItem,
    a,
    k;

    for (k=0; k<fields.length; k+=1) {
        buildItem = this.addItem({
            id: "opt"+k,
            label: fields[k].label, 
            value: fields[k].label,
            type: fields[k].type,            
            onClose: function (event, item) {
                that.dom.areaFormula.removeChild(this.getHTML());
                that.removeItemFormula(this);
                that.onChangeHandler();
            }
        });
        this.valueArray[k].id = buildItem.id;
        
    }
    
    return this;
};
AreaControl.prototype.createHTML = function () {
    var container = document.createElement("div"),
    areaFormula = document.createElement("div"),
    operations = document.createElement("div"),
    optElement,
    optLabel,
    suggestControl,
    attr,
    optBasic =this.operations,
    j;

    suggestControl = this.suggestControl.getHTML();
    container.className = "pmdesigner-areacontrol";
    operations.className = "pmdesigner-areacontrol-operations";

    for(j=0; j<optBasic.length; j+=1) {
        optLabel =  document.createElement("span");
        optLabel.innerHTML = optBasic[j].value;
        optElement = document.createElement("a");
        optElement.className = "pmdesigner-areacontrol-operationsitem";
        optElement.appendChild(optLabel);
        operations.appendChild(optElement);
        this.defineEventsOpt(optElement);
    }
    areaFormula.className = "pmdesigner-areacontrol-areaformula";
    container.appendChild(suggestControl);
    container.appendChild(operations);
    container.appendChild(areaFormula);
    
    this.dom.areaFormula = areaFormula;
    this.createHTMLFormulaDefault();
    this.html = container;

    return this.html;
};
AreaControl.prototype.defineEventsOpt = function (optItem) {
    var that = this,
    label,
    buildItem,
    typeOpt,
    a;
    this.addEvent("click").listen(optItem, function (event){
        label = (event.target.children.length === 0)? event.target.innerHTML: event.target.children[0].innerHTML;
        typeOpt = /\(|\)/.test(label) ? "bracket" : "operation";
        buildItem =  that.addItem({
            label: label,
            value: label,
            type: typeOpt,
            onClose: function (event, item) {
                that.dom.areaFormula.removeChild(this.getHTML());
                that.removeItemFormula(this);
                that.onChangeHandler();
            }  
        });
        

        that.addItemFormula(buildItem);
        that.onChangeHandler();
    });
    return this;
};
/**
 * Set the events for the object
 * @chainable
 */
AreaControl.prototype.defineEvents = function() {
    var that = this;

    if(this.html) {
        //Events about Suggest
        this.suggestControl.defineEvents();
        this.suggestControl.setOnClickItem(function(event, item, label){
            that.dom.areaFormula.appendChild(item.getHTML());

            that.addItemFormula(item);
        });
    }
    this.suggestControl.parent = this;
    return this;
};






/**
 * ItemControl class
 */
var AreaField = function (options){
    RowField.call(this, options);
    this.value = null
    this.formulaTokenizer = null
    AreaField.prototype.init.call(this, options);
};
AreaField.prototype = new RowField();

AreaField.prototype.init= function (options){
    var defaults  = {
        value : ""
    }
    jQuery.extend(true, defaults, options);
    this.setValue(defaults.value);
};
AreaField.prototype.setValue = function (value) {
    this.value = (typeof value  === "string") ? value: "";
    return this;
};
AreaField.prototype.setControls = function() {
    if(this.controls.length) {
        return this;
    }
    this.controls.push(new AreaControl({
        parent: this,
        onChangeHandler: this.onChangeHandler
    }));
    this.setFormulaValue();

    return this;
};
AreaField.prototype.setFormulaValue = function () {
    var itemField = [],
    fields,
    k;

    this.formulaTokenizer = new Formula(this.value);
    
    if (this.value.length > 0) {
        fields = this.value.split(/\+|\-|\*|\/|\(|\)|\SQRT|\PI/).filter(
            function(el){return el !=="" && Number.isNaN(parseInt(el)) });

        for(k=0; k<fields.length; k+=1) {
            this.formulaTokenizer.addField("field", fields[k]);
        }
        itemField = this.formulaTokenizer.evaluate();
        //undefined
        this.controls[0].setValue(this.value);
        this.controls[0].setFormulaArray(itemField);
    }
    
    return this;
};
AreaField.prototype.setFormula = function () {
    return "My formula";
};
AreaField.prototype.getFormula = function () {
    return "My formula";
};
AreaField.prototype.getValue = function () {
    
    this.value = this.controls[0].getValue();
    return this.value;
};
AreaField.prototype.setLabelPosition = function (){
    return this;
};
AreaField.prototype.setForm = function (){
    return this;
};
AreaField.prototype.setValidatorFactory = function (){
    return this;
};
AreaField.prototype.setRequiredMessage = function (){
    return this;
};
AreaField.prototype.showHelper = function (){
    return this;
};
AreaField.prototype.hideHelper = function (){
    return this;
};
AreaField.prototype.setHelper = function (){
    return this;
};
AreaField.prototype.evalRequired = function (){
    return this;
};
AreaField.prototype.onChangeHandler = function() {
    var that = this, i, newValue;

    return function() {
        var previousValue = that.value,
        newValue;

        newValue = that.getValue();
        that.value = newValue;
        that.data.setValue(newValue);
        if(that.validError){
            if(that.validAtChange) {
                if(that.isValid()){
                    that.validError.setVisible(false);
                }else{
                    that.validError.setVisible(true);
                }
            }   
        }
        if(typeof that.onChange === 'function') {
            that.onChange(that.getValue(), previousValue);
        }
        if(that.parent) {
            (that.parent.onChangeHandler())(that, that.getValue(), previousValue);
        }   
    };
};
var PropertiesTable = function (options){
    PMUI.core.Container.call(this, jQuery.extend(true, options, {
        factory: {
            products: {
                'dropdown': DropDownListRowField,
                'text': TextRowField,
                'checkbox': CheckBoxRowField,
                'button' : ButtonRow,
                'area': AreaField
            },
            defaultProduct: "text"
        }
    }));

    this.dom  = {};
    this.visibleHeader = null;
    this.name = null;
    this.onBeforeChange = null;
    this.onChange = null;
    this.onSubmit = null;
    this.data = null; 
    this.targetInDesigner = null;
    PropertiesTable.prototype.init.call(this, options);
};

PropertiesTable.prototype = new PMUI.core.Container();
 
PropertiesTable.prototype.type = "PropertiesTable";

PropertiesTable.prototype.init = function (options){
    var defaults = {
        name : this.id,
        visibleHeader : true,
        onChange : null,
        onBeforeChange: null,
        items : [],
        width : '100%',
        height : '100%',
        onLoad : null,
        titleCol1 : 'Property',
        titleCol2 : 'Value' 
    };
    this.data = new PMUI.data.DataSet();
    
    jQuery.extend(true, defaults, options);
    this.setName(defaults.name);
    this.setVisibleHeader(defaults.visibleHeader);
    this.setOnChange(defaults.onChange);
    this.setOnBeforeChangeHandler(defaults.onBeforeChange);
    this.setWidth(defaults.width);
    this.setHeight(defaults.height);
    this.setItems(defaults.items);
    this.setTitle1(defaults.titleCol1);
    this.setTitle2(defaults.titleCol2);
    //this.setOnLoad(defaults.onLoad);  
};

PropertiesTable.prototype.setOnBeforeChangeHandler = function(handler) {
    if(!(handler === null || typeof handler === 'function')) {
        throw new Error("setOnBeforeChangeHandler(): The parameter must be function or null.");
    }
    this.onBeforeChange = handler;
    return this;
};

PropertiesTable.prototype.setName = function (name){
    this.name = name;
    return this;
};
PropertiesTable.prototype.setTargetInDesigner = function (field){
    this.targetInDesigner = field;
    return this;
};

PropertiesTable.prototype.setVisibleHeader = function (value){
    if(typeof value == 'boolean'){
        this.visibleHeader = value;
        if (value){
            this.showHeader();
        }else{
            this.hideHeader();
        }
    }
    return  this;
};

PropertiesTable.prototype.hideHeader = function (){
    this.visibleHeader = false;
    if (this.dom.headerContainer){
        this.dom.headerContainer.style.display = "none";
    }
    return  this;
};

PropertiesTable.prototype.showHeader = function (){
    this.visibleHeader = true;
    if (this.dom.header){
        this.dom.header.style.display = "table-header-group";
    }
    return  this;
};

PropertiesTable.prototype.setOnChange = function (onChange){
    if(typeof onChange == "function" || onChange == null) {
        this.onChange = onChange;
    }
    return this;
};

PropertiesTable.prototype.onBeforeChangeHandler = function() {
    var that = this;
    return function(newValue, oldValue) {
        var callbackResponse;
        if(typeof that.onBeforeChange === 'function') {
            callbackResponse = that.onBeforeChange(that, this, newValue, oldValue);
        }
        return callbackResponse;
    };
};

PropertiesTable.prototype.onChangeHandler = function() {
    var that = this;
    return function(rowField, newValue, previousValue) {
        if(typeof that.onChange === 'function') {
            that.onChange(rowField, newValue, previousValue);
        }
    };
};

PropertiesTable.prototype.setTitle1 = function (title){
    if(typeof title == "string" ){
        this.titleCol1 = title;
        if(this.dom.title1Container){
            this.dom.title1Container.innerHTML = this.titleCol1;
        }
    }
    return this;
};
PropertiesTable.prototype.setTitle2 = function (title){
    if(typeof title == "string" ){
        this.titleCol2 = title;
        if(this.dom.title2Container){
            this.dom.title2Container.innerHTML = this.titleCol2;
        }
    }
    return this;
};

PropertiesTable.prototype.addItem = function(item) {
    var addedItem;
    PMUI.core.Container.prototype.addItem.call(this, item);
    addedItem = this.items.get(this.items.getSize() - 1);
    addedItem.setOnBeforeChangeHandler(this.onBeforeChangeHandler());
    return this;
};

PropertiesTable.prototype.createHTML = function (){
    var header, 
        body, 
        table,
        col1,
        col2,
        title1Container,
        title2Container;
    if(this.html){
        return this.html;
    }
    PMUI.core.Container.prototype.createHTML.call(this);

    table = PMUI.createHTMLElement('table');
    table.className = "mafe-table-properties";
    table.style.width = '100%';

    header = PMUI.createHTMLElement('thead');
    header.className = "mafe-header-properties";

    body = PMUI.createHTMLElement('tbody');
    body.className = "mafe-body-properties";

    title1Container = PMUI.createHTMLElement('span');
    title1Container.className = "mafe-title-container";
    title1Container.innerHTML = this.titleCol1;
    title2Container = PMUI.createHTMLElement('span');
    title2Container.className = "mafe-title-container";
    title2Container.innerHTML = this.titleCol2;


    col1 = PMUI.createHTMLElement('th');
    col1.className = "mafe-col";
    col1.appendChild(title1Container);
    col2 = PMUI.createHTMLElement('th');
    col2.className = "mafe-col";
    col2.appendChild(title2Container);
    header.appendChild(col1);
    header.appendChild(col2);

    for (var i=0; i < this.items.getSize(); i+=1){
        body.appendChild(this.getItems()[i].getHTML());
    }

    table.appendChild(header);
    table.appendChild(body);

    this.dom.header = header;
    this.dom.body = body;
    this.containmentArea = this.dom.body;
    this.dom.title1Container = title1Container;
    this.dom.title2Container = title2Container;

    this.html.appendChild(table);
    return this.html;
};

PropertiesTable.prototype.getData = function() {
    var rows, i, response, data = new PMUI.data.DataSet();
    rows = this.getItems();
        response = {};
        for(i = 0; i < rows.length; i+=1) {
            if(!rows[i].disabled) {
                response[rows[i].getName()] = rows[i].getValue();
            }
        }
    return response;
};

/*PropertiesTable.prototype.addItem = function(item) {
    var rowToBeAdded;
    if(this.factory) {
        rowToBeAdded = this.factory.make(item);
    }
    if(rowToBeAdded && !this.isDirectParentOf(rowToBeAdded)) {
        rowToBeAdded.parent = this;
            this.items.insertAt(rowToBeAdded);
            if (this.html && this.dom.body) {
                    this.dom.body.appendChild(rowToBeAdded.getHTML());
                }
                if(this.eventsDefined) {
                    rowToBeAdded.defineEvents();
                }
        }   
    return this;
};*/

/*global PMUI */
var PMFormDesigner = function (settings) {
    PMUI.core.Element.call(this, settings);
    var that = this;
    this.dyn_content = null;
    this.newOptionForm = null;
    this.variables = new PMUI.util.ArrayList();
    this.optionsGrid = null;
    this.layout = null;
    this.toolbox = null;
    this.accordion = null;
    this.variablesList = null;
    this.controlsList = null;
    this.mainPanel = null;
    this.optionsWindow = null;
    this.controlSelectorWindow = null;
    this.dependentFieldsForm = null;
    this.dependentFieldsGrid = null;
    this.listFieldGrid = null;
    this.dependentWindow = null;
    this.selectedField = null;
    this.onChange = null;
    this.errorMessageWindow = null;
    this.warningMessageWindow = null;
    this.copyItemsDependentFiels = null;
    this.copyItemsListFiels = null;
    this.otherControlsList = null;
    this.listOfEligibleFields = null;
    this.warningMessageForClearForm = null;
    this.listOfFieldsOfGrid = [];
    this.listOfDependentFieldsGrid = [];
    this.listOfFieldsForDependecy = [];
    this.flashMessage = new PMUI.ui.FlashMessage({
        duration: 5000
    });
    this.freeCell = PMUI.createHTMLElement("div");
    this.freeCell.id = "freeCell";
    this.onButtonClickEditvariable = null;
    this.subForms = [];
    this.subFormList = null;
    this.scriptWindow,
            this.fieldScript,
            this.valueScript = "",
            this.menu = new PMUI.menu.Menu({
                items: [
                    {
                        text: "Remove",
                        onClick: function (menuOption) {
                            var cell = menuOption.getMenuTargetElement(), field, messageAlert = '';
                            if (cell.getItems().length) {
                                field = cell.getItem(0);
                                if (field.dependentFields.length || field.directDependence.length) {
                                    messageAlert = messageAlert + 'Is not possible remove the field because this have dependent fields associated';
                                    if (field.dependentFields.length) {
                                        messageAlert = messageAlert + 'Dependent fields: '
                                        for (var i = 0; i < field.dependentFields.length; i += 1) {
                                            messageAlert = messageAlert + field.dependentFields[i].name;
                                            if (i < field.dependentFields.length - 1) {
                                                messageAlert = messageAlert + ', ';
                                            } else {
                                                messageAlert = messageAlert + '.';
                                            }
                                        }
                                    }
                                    if (field.directDependence.length) {
                                        messageAlert = messageAlert + 'This is dependent of: ';
                                        for (var i = 0; i < field.directDependence.length; i += 1) {
                                            messageAlert = messageAlert + field.directDependence[i].name;
                                            if (i < field.directDependence.length - 1) {
                                                messageAlert = messageAlert + ', ';
                                            } else {
                                                messageAlert = messageAlert + '.';
                                            }
                                        }
                                    }
                                    messageAlert = messageAlert + 'eliminate any dependence';
                                    that.errorMessageFormDesinger.setMessage(messageAlert);
                                    that.errorMessageFormDesinger.open();

                                } else {
                                    var field = cell.getItems()[0];
                                    field.setOnClickHandler(null);
                                    cell.clearItems();
                                    if (that.propertiesTarget.targetInDesigner === field) {
                                        that.removeActiveClass(cell);
                                        that.loadPropertiesField(that.mainPanel);
                                    }
                                }
                                that.onChangeHandler(that, "removeField", {
                                    target: field
                                });
                            } else {
                                //that.removeActiveClass(cell);
                                that.removeCell(cell);
                            }
                        }
                    }, {
                        text: "Remove row",
                        onClick: function (menuOption) {
                            var cell = menuOption.getMenuTargetElement(),
                                    row = cell.getParent(),
                                    grid = row.getParent();

                            grid.removeItem(row);
                            that.onChangeHandler(that, "removeRow", {
                                target: row
                            });
                        }
                    }, {
                        text: "Insert row...",
                        items: [
                            {
                                text: "above",
                                onClick: function (menuOption) {
                                    var cell = menuOption.getMenuTargetElement(),
                                            row = cell.getParent(),
                                            grid = row.getParent(),
                                            index = grid.getItemIndex(row);

                                    that.addRowToMainPanel(index, row);
                                    that.onChangeHandler(that, "insertRowAbove", {
                                        target: that.mainPanel.getItem(index)
                                    });
                                }
                            },
                            {
                                text: "below",
                                onClick: function (menuOption) {
                                    var cell = menuOption.getMenuTargetElement(),
                                            row = cell.getParent(),
                                            grid = row.getParent(),
                                            index = grid.getItemIndex(row);

                                    that.addRowToMainPanel(index + 1, row);
                                    that.onChangeHandler(that, "insertRowBelow", {
                                        target: that.mainPanel.getItem(index)
                                    });
                                }
                            }
                        ]
                    }, {
                        text: "Insert row (2 placeholders)",
                        onClick: function (menuOption) {
                            that.addRowToMainPanel(null, 2);
                            that.onChangeHandler(that, "insertRow2Placeholders", {
                                target: that.mainPanel.getItem(that.mainPanel.getItems().length - 1)
                            });
                        }
                    }, {
                        text: "Insert row (3 placeholders)",
                        onClick: function (menuOption) {
                            that.addRowToMainPanel(null, 3);
                            that.onChangeHandler(that, "insertRow3Placeholders", {
                                target: that.mainPanel.getItem(that.mainPanel.getItems().length - 1)
                            });
                        }
                    }/*,
                     {
                     text : 'Change control to...'
                     }*/, {
                        text: "Remove Column",
                        onClick: function (menuOption) {
                            console.log(that, menuOption);
                            var field;
                            field = menuOption.getMenuTargetElement().getItem(0);
                        }

                    }
                ]
            });
    this.menuGrid = new PMUI.menu.Menu({
        id: 'gridMenu',
        items: [
            {
                text: 'Remove Column',
                onClick: function (option) {
                    var parent, item, column, cellColumn;
                    column = option.getMenuTargetElement();
                    grid = column.parent;
                    if (grid.items.getSize() > 1) {
                        grid.removeItem(column);
                    }
                    //grid = cellColumn.parent;
                }
            },
            {
                text: 'insert Column',
                onClick: function (option) {
                    var pos, index, parent, newCell, cellColumn;
                    cellColumn = option.getMenuTargetElement();
                    grid = cellColumn.parent;
                    index = grid.items.indexOf(cellColumn);
                    newCell = grid.addNewBlanckCell();
                    newCell.setOnBeforeContextMenu(function (cell) {
                        cell.setContextMenu(that.menuGrid);
                    })
                    grid.addItem(newCell, index + 1);
                }
            }
        ]
    });
    this.propertiesTarget = new PropertiesTable({
        onBeforeChange: function (propertiesGrid, row, newValue, oldValue) {
            if (row.getName() === 'name') {
                if (that.existsFieldName(newValue) && newValue) {
                    that.displayErrorMessage("The name \"" + newValue + "\" is already being used.");
                    return false;
                }
            }
            if (row.getName() === 'id') {
                if (that.existFieldId(newValue) && newValue) {
                    that.displayErrorMessage("The Id \"" + newValue + "\" is already being used.");
                    return false;
                }
            }
        },
        onChange: function (fieldRow, newValue, previousValue) {
            var target = this.targetInDesigner;
            that.updateField(fieldRow, newValue, previousValue, target);
            that.onChangeHandler(that, 'fieldProperty', {
                target: fieldRow,
                oldValue: previousValue,
                newValue: newValue
            });
        }
    });
    this.errorMessageFormDesinger = new PMUI.ui.MessageWindow({
        width: 490,
        bodyHeight: 'auto',
        windowMessageType: 'error',
        footerItems: [
            {
                text: "Accept",
                handler: function () {
                    that.errorMessageFormDesinger.close();
                },
                height: 40
            }
        ],
        visibleFooter: true
    });
    this.warningMessageForClearForm = new PMUI.ui.MessageWindow({
        width: 400,
        title: "Confirm",
        bodyHeight: 'auto',
        windowMessageType: 'warning',
        message: "Do you want to clean the formulary? all changes will be lost.",
        footerItems: [
            {
                text: "Yes",
                handler: function () {
                    that.clearForm();
                    that.loadPropertiesField(that.mainPanel);
                    that.warningMessageForClearForm.close();
                    that.clearOptionsSelector();
                },
                height: 40,
                buttonType: 'success'
            }, {
                pmType: "label",
                text: "or"
            }, {
                buttonType: "link",
                text: "No",
                height: 40,
                handler: function () {
                    that.warningMessageForClearForm.close();
                }
            }
        ],
        visibleFooter: true
    });

    this.controlsForGridWindow = null;
    this.controlsForGridList = null;
    this.createVariableButton = null;
    this.onButtonCreateVariableClick = null;
    this.domElemntsHeight = {};
    this.init(settings);
};

PMFormDesigner.prototype = new PMUI.core.Element();

PMFormDesigner.prototype.variablesVSControls = {};

PMFormDesigner.prototype.properties = {
    name: {
        name: 'name',
        label: 'Field Name',
        typeInput: 'text',
        set: 'setName',
        get: 'getName',
        valueType: 'string',
        validators: [
            {
                pmType: "regexp",
                type: 'error',
                criteria: /^([-_a-zA-Z0-9]+\s{0})$/i,
                errorMessage: "Please enter a valid Name"
            }
        ]
    },
    formName: {
        name: 'formName',
        label: 'Form Name',
        typeInput: 'text',
        set: 'setFormName',
        get: 'getFormName',
        valueType: 'string',
        validators: [
            {
                pmType: "regexp",
                type: 'error',
                criteria: /^([-_a-zA-Z0-9]+\s{0})$/i,
                errorMessage: "Please enter a valid Form Name"
            }
        ]
    },
    formId: {
        name: 'formId',
        label: 'Form ID',
        typeInput: 'text',
        set: 'setFormId',
        get: 'getFormId',
        valueType: 'string',
        validators: [
            {
                pmType: "regexp",
                type: 'error',
                criteria: /[-_a-zA-Z1-9]/i,
                errorMessage: "Please enter a valid Label"
            }
        ]
    },
    formMode: {
        name: 'formMode',
        label: 'View Mode',
        typeInput: 'dropdown',
        options: [
            {
                label: 'Edit',
                value: 'edit'
            }, {
                label: 'View',
                value: 'view'
            }, {
                label: 'Disabled',
                value: 'disabled'
            }
        ],
        set: 'setFormMode',
        get: 'getFormMode',
        valueType: 'string'
    },
    label: {
        name: 'label',
        label: 'Label',
        typeInput: 'text',
        set: 'setLabel',
        get: 'getLabel',
        valueType: 'string'
                /*validators : [
                 {
                 pmType : "regexp",
                 type : 'error',
                 criteria : /^([-_a-zA-Z1-9]+\s{1})*([-_a-zA-Z1-9])*$/i,
                 errorMessage: "Please enter a valid name" 
                 }
                 ]*/
    },
    /*width: {
     name: 'width',
     label: 'Width',
     typeInput: 'text',
     set: 'setWidth',
     get: 'getWidth',
     number: true
     },*/
    required: {
        name: 'required',
        label: 'Required',
        typeInput: 'checkbox',
        set: 'setRequired',
        get: 'getRequired',
        valueType: 'boolean'
    },
    disabled: {
        name: 'disabled',
        label: 'Disabled',
        typeInput: 'checkbox',
        set: 'setDisabled',
        get: 'getDisabled',
        valueType: 'boolean'
    },
    hint: {
        name: 'hint',
        label: 'Hint',
        typeInput: 'text',
        set: 'setHint',
        get: 'getHint',
        valueType: 'string'
    },
    defaultValue: {
        name: 'defaultValue',
        label: 'Default Value',
        typeInput: 'text',
        set: 'setDefaultValue',
        get: 'getDefaultValue',
        valueType: ''
    },
    defaultValueToBoolean: {
        name: 'defaultValue',
        label: 'Default Value',
        typeInput: 'dropdown',
        set: 'setDefaultValue',
        get: 'getDefaultValue',
        valueType: 'boolean',
        options: [
            {
                label: "True",
                value: 1
            }, {
                label: "False",
                value: 0
            }
        ]
    },
    /*
     formula: {
     name: 'formula',
     label: 'Formula',
     typeInput: 'text',
     set: 'setFormula',
     get: 'getFormula'
     },*/
    /*sqlConnection: {
     name: 'sqlConnection',
     label: 'Sql Connection',
     typeInput: 'dropdown',
     options: [
     {
     label : '(none)'
     },{
     label : 'dbarray'
     },{
     label : 'Workflow'
     },{
     label : 'RBAC'
     },{
     label : 'REPORT'
     }
     ],
     set : "setSqlConnection",
     get : "getSqlConnection"
     },*/
    sql: {
        name: 'sql',
        label: 'Sql',
        typeInput: 'text',
        set: 'setSql',
        get: 'getSql',
        valueType: 'string'
    },
    dependentFields: {
        name: 'dependent',
        label: 'Dependent Fields',
        typeInput: 'button',
        handler: function () {
            alert("fdsafasdfas!");
        },
        value: '...'
    },
    textTransform: {
        name: 'textTransform',
        label: 'Text transform to',
        typeInput: 'dropdown',
        options: [
            {label: 'none'
            }, {
                label: 'UPPER',
                value: 'upper'
            }, {
                label: 'LOWER',
                value: 'lower'
            }, {
                label: 'CAPITALIZE PHRASE',
                value: 'capitalizePhrase'
            }, {
                label: 'TITLE CASE',
                value: 'titleCase'
            }
        ],
        get: "getTextTransform",
        set: "setTextTransform",
        valueType: 'string'
    },
    validate: {
        name: 'validate',
        label: 'Validate',
        typeInput: 'dropdown',
        options: [
            {
                label: 'Any',
                value: 'any'
            },
            {
                label: 'Alphabetic',
                value: 'alphabetic'
            },
            {
                label: 'Alphanumeric',
                value: 'alphanumeric'
            },
            {
                label: 'Integer',
                value: 'integer'
            },
            {
                label: 'RealNumber',
                value: 'readnumber'
            },
            {
                label: 'Email',
                value: 'email'
            },
            {
                label: 'Login',
                value: 'login'
            }
        ],
        set: 'setValidate',
        get: 'getValidate',
        valueType: 'string'
    },
    mask: {
        name: 'mask',
        label: 'Mask',
        typeInput: 'text',
        set: 'setMask',
        get: 'getMask',
        valueType: 'string',
        validators: [
            {
                pmType: "regexp",
                type: 'error',
                criteria: /^([-_#.,;$a-zA-Z0-9]+\s{0})*$/i,
                errorMessage: "Please enter a valid mask"
            }
        ]
    },
    maxLength: {
        name: 'maxLength',
        label: 'Max. Length',
        typeInput: 'text',
        set: 'setMaxLength',
        get: 'getMaxLength',
        valueType: 'number',
        validators: [
            {
                pmType: "regexp",
                type: 'error',
                criteria: /^(-)?[0-9]+$/,
                errorMessage: "Please enter a valid number integer "
            }
        ]
    },
    formula: {
        name: "formula",
        label: "Formula",
        typeInput: "editableArea",
        set: "setFormula",
        get: "getFormula",
        valueType: "string"
    },
    includeOptionGroup: {
        name: 'includeOptionGroup',
        label: 'Include Option Group',
        typeInput: 'checkbox',
        set: 'setIncludeOptionGroup',
        get: 'getIncludeOptionGroup',
        valueType: 'boolean'
    },
    typeOfDateRange: {
        name: 'typeRangeDate',
        label: 'Type of date range',
        typeInput: 'dropdown',
        data: ['Relative Dates', 'Static Dates'],
        set: 'setTypeOfDateRange',
        get: 'getTypeOfDateRange',
        valueType: ''
    },
    editable: {
        name: 'editable',
        label: 'Editable',
        typeInput: 'checkbox',
        set: 'setEditable',
        get: 'getEditable',
        valueType: 'boolean'
    },
    javascriptExecute: {
        name: 'javascriptExecute',
        label: 'JavaScript to Execute',
        typeInput: 'text',
        set: 'setJavaScriptExecute',
        get: 'getJavaScriptExecute',
        valueType: 'string'
    },
    button: {
        name: 'button',
        label: 'Options',
        typeInput: 'button',
        handler: function () {
            alert("fdsafasdfas!");
        },
        value: '...'
    },
    colSpan: {
        name: 'colspan',
        label: 'Col-Span',
        typeInput: 'dropdown',
        value: 12,
        options: [{value: 12}, {value: 11}, {value: 10}, {value: 9}, {value: 8}, {value: 7}, {value: 6}, {value: 5}, {value: 4}, {value: 3}, {value: 2}, {value: 1}],
        set: 'setColSpan',
        get: 'getColSpan',
        valueType: 'number',
        validators: [
            {
                pmType: "regexp",
                criteria: /^(-)?[0-9]+$/,
                errorMessage: "Please enter a valid integer"
            }
        ]
    },
    variable: {
        name: 'variable',
        label: 'Variable',
        typeInput: 'dropdown',
        value: '',
        options: [],
        set: 'setVariable',
        get: 'getVariableName',
        valueType: 'string'
    },
    pickType: {
        name: 'pickType',
        label: 'Pick Type',
        typeInput: 'dropdown',
        value: '',
        options: [
            {
                label: 'datetime'
            },
            {
                label: 'date'
            },
            {
                label: 'time'
            }
        ],
        set: 'setPickDate',
        get: 'getPickDate',
        valueType: 'string'
    },
    dataType: {
        name: 'dataType',
        label: 'Data Type',
        typeInput: 'text',
        set: 'setDataType',
        get: 'getDataType',
        valueType: 'string'
    },
    id: {
        name: 'id',
        label: 'id Field',
        typeInput: 'text',
        set: 'setId',
        get: 'getId',
        valueType: 'string',
        validators: [
            {
                pmType: "regexp",
                type: 'error',
                criteria: /[-_a-zA-Z1-9]/i,
                errorMessage: "Please enter a valid Label"
            }
        ]
    },
    mode: {
        name: 'mode',
        label: 'Mode',
        typeInput: 'dropdown',
        options: [
            {
                label: 'Form View',
                value: 'parent'
            },
            {
                label: 'Edit',
                value: 'edit'
            }, {
                label: 'View',
                value: 'view'
            }, {
                label: 'Disabled',
                value: 'disabled'
            }
        ],
        set: 'setMode',
        get: 'getMode',
        valueType: 'string'
    },
    placeholder: {
        name: 'placeholder',
        label: 'Placeholder',
        typeInput: 'text',
        set: 'setPlaceholder',
        get: 'getPlaceholder',
        valueType: 'string'
    },
    title: {
        name: 'title',
        label: 'Column Title',
        typeInput: 'text',
        set: 'setTitle',
        get: 'getTitle',
        valueType: 'string'
    },
    width: {
        name: 'width',
        label: 'Width Column',
        typeInput: 'text',
        set: 'setWidth',
        get: 'getWidth',
        valueType: 'number',
    },
    rows: {
        name: 'rows',
        label: 'Rows',
        typeInput: 'text',
        type: 'text',
        set: 'setRows',
        get: 'getRows',
    },
    pager: {
        name: 'pager',
        label: 'Pager',
        typeInput: 'checkbox',
        valueType: 'string',
        set: 'setPager',
        get: 'getPager'
    },
    multiple: {
        name: 'multiple',
        label: "Multple Files",
        typeInput: 'checkbox',
        valueType: 'boolean',
        set: 'setMultiple',
        get: 'getMultiple'
    },
    preview: {
        name: 'preview',
        label: 'Preview',
        typeInput: 'checkbox',
        valueType: 'boolean',
        set: 'setPreview',
        get: 'getPreview'
    },
    dnd: {
        name: 'dnd',
        label: 'Draggable',
        typeInput: 'checkbox',
        valueType: 'boolean',
        set: 'setDnd',
        get: 'getDnd'
    },
    extensions: {
        name: 'extensions',
        label: 'extensions',
        valueType: 'string',
        set: 'setExtensions',
        get: 'getExtensions',
        typeInput: 'text'
    },
    size: {
        name: 'size',
        label: 'Size (MB)',
        valueType: 'number',
        set: 'setSize',
        get: 'getSize',
        typeInput: 'text',
        validators: [
            {
                pmType: "regexp",
                criteria: /^(-)?[0-9]+$/,
                errorMessage: "Please enter a valid integer",
                type: 'error'
            }
        ]
    },
    alt: {
        name: 'alt',
        label: 'Alternate Text',
        valueType: 'string',
        set: 'setAlt',
        get: 'getAlt',
        typeInput: 'text'
    },
    comment: {
        name: 'comment',
        label: 'Comment',
        valueType: 'string',
        set: 'setComment',
        get: 'getComment',
        typeInput: 'text'
    },
    src: {
        name: 'src',
        label: 'Url (http://)',
        valueType: 'string',
        set: 'setSrc',
        get: 'getSrc',
        typeInput: 'text',
        validators: [
            {
                pmType: "regexp",
                criteria: /^(ht|f)tps?:\/\/\w+([\.\-\w]+)?\.([a-z]{2,4}|travel)(:\d{2,5})?(\/.*)?$/i,
                errorMessage: "Please enter a valid url",
                type: 'error'
            }
        ]
    },
    shape: {
        name: 'shape',
        label: 'Shaphe',
        valueType: 'string',
        set: 'setShape',
        get: 'getShape',
        typeInput: 'dropdown',
        options: [
            {
                label: 'Thumbnail',
                value: 'thumbnail'
            }, {
                label: 'Rounded',
                value: 'rounded'
            }, {
                label: 'Circle',
                value: 'circle'
            }
        ]
    },
    href: {
        name: 'href',
        label: "Href (http://...)",
        valueType: 'string',
        set: "setHref",
        get: "getHref",
        typeInput: 'text',
        validators: [
            {
                pmType: "regexp",
                criteria: /^(ht|f)tps?:\/\/\w+([\.\-\w]+)?\.([a-z]{2,4}|travel)(:\d{2,5})?(\/.*)?$/i,
                errorMessage: "Please enter a valid url",
                type: 'error'
            }
        ]
    },
    dependentColumns: {
        name: 'dependentColumns',
        label: 'Dependent Columns',
        typeInput: 'button',
        handler: function () {
            alert("dependentColumns!");
        },
        value: '...'
    },
    scripts: {
        name: 'scripts',
        label: 'Add scripts',
        typeInput: 'button',
        handler: function () {
            alert("dependentColumns!");
        },
        value: '...'
    },
};

PMFormDesigner.prototype.displayMessage = function (message, severity) {
    this.flashMessage.setMessage(message)
            .setSeverity(severity)
            .show();
    return this;
};

PMFormDesigner.prototype.displayInfoMessage = function (message) {
    return this.displayMessage(message, 'info');
};

PMFormDesigner.prototype.displayErrorMessage = function (message) {
    return this.displayMessage(message, 'error');
};

PMFormDesigner.prototype.init = function (settings) {
    this.onChange = (settings && settings.onChange) || null;
    this.onButtonClickEditvariable = (settings && settings.onButtonClickEditvariable) || null;
    this.onButtonCreateVariableClick = (settings && settings.onButtonCreateVariableClick) || null;
    this.createPropertiesTable();
    this.createMainPanel();
    this.createOtherControlsList();
    this.createVariablesList();
    this.createSubformList();
    this.createAccordion();
    this.createToolbox();
    this.createLayout();
    this.setVariables((settings && settings.variables) || []);
    this.setSubForms((settings && settings.forms) || []);
    this.createButtonToNewVariable(settings);
};

PMFormDesigner.prototype.createButtonToNewVariable = function (settings) {
    this.onButtonCreateVariableClick = (settings && settings.onButtonCreateVariableClick) || null;
    this.createVariableButton = new PMUI.ui.Button({
        text: 'Create',
        style: {
            cssClasses: ['button-create-variable'],
            cssProperties: {
                'fontSise': '14',
                'margin-left': '10px'
            },
            height: 24
        },
        buttonType: 'success',
        handler: this.onButtonCreateVariableHandler()
    });
    return this;
};

PMFormDesigner.prototype.onButtonCreateVariableHandler = function () {
    var that = this;
    return function () {
        if (typeof that.onButtonCreateVariableClick == 'function') {
            that.onButtonCreateVariableClick(that, that.variablesList, this);
        }
    };
};

PMFormDesigner.prototype.customSearchInputPosition = function () {
    var filterInput, that = this;
    filterInput = this.accordion.getItems()[0].getItems()[0].filterControl;
    //this.accordion.getItems()[0].header.html.style.height = "1.8em";
    this.accordion.getItems()[0].header.html.appendChild(filterInput.getHTML());
    this.accordion.getItems()[0].header.html.appendChild(this.createVariableButton.getHTML());
    this.createVariableButton.defineEvents();
    filterInput.setHeight(20);
    filterInput.setWidth(110);
    this.createVariableButton.setHeight(24);

    jQuery(filterInput.html).click(function (e) {
        if (that.accordion.getItems()[0].collapsed) {
            that.accordion.getItems()[0].expand();
        }
        e.stopPropagation();
    });
    $('.pmui-accordion-item-iconbase.pmui-accordion-item-icon').css('display', 'none');
};

PMFormDesigner.prototype.removeCell = function (cell) {
    var row = cell.getParent(),
            grid = row.getParent(),
            colSpan = cell.colSpan,
            itemIndex = row.getItemIndex(cell), cellToReceiveSpan, item,
            changeType = 'removeCell';
    if (row.getItems().length === 1) {
        grid.removeItem(row);
        changeType = "removeRow";
    } else {
        row.removeItem(cell);
        if (itemIndex === 0) {
            cellToReceiveSpan = row.getItem(0);
        } else {
            cellToReceiveSpan = row.getItem(itemIndex - 1);
        }
        colSpan = colSpan + cellToReceiveSpan.colSpan;
        cellToReceiveSpan.getHTML().colSpan = colSpan;
        cellToReceiveSpan.colSpan = colSpan;
        item = cellToReceiveSpan.getItem(0);
        if (item) {
            item.setColSpan(colSpan);
            this.loadPropertiesField(item);
        }
    }
    this.onChangeHandler(this, changeType, {
        target: changeType === 'removeCell' ? cell : row
    });
    return this;
};

PMFormDesigner.prototype.onChangeHandler = function (designer, changeType, data) {
    var that = this;
    if (typeof this.onChange === 'function') {
        this.onChange(designer, changeType, data);
    }
    return this;
};

PMFormDesigner.prototype.createControlsList = function (variable, panel) {
    var obj = [], controls = variable.getSupportedControls(), i;
    if (panel.id === 'controlsForGridList') {
        index = controls.indexOf('label');
        if (index !== -1) {
            controls.splice(index, 1);
        }
    }
    if (variable.fieldType != 'boolean') {
        for (i = 0; i < controls.length; i++) {
            obj.push({
                text: controls[i] == 'checkbox' ? controls[i] + "(Group)" : controls[i],
                visibleIcon: true,
                style: {
                    cssClasses: ['cmp-' + controls[i]]
                },
                data: {
                    pmType: controls[i]
                }
            });
        }
    } else {
        obj.push({
            text: 'dropdown',
            visibleIcon: true,
            style: {
                cssClasses: ['cmp-' + "dropdown"]
            },
            data: {
                pmType: 'yesnodropdown'
            }
        });
        obj.push({
            text: 'radio',
            visibleIcon: true,
            style: {
                cssClasses: ['cmp-' + 'radio']
            },
            data: {
                pmType: 'yesnoradio'
            }
        });
    }
    return obj;
};

PMFormDesigner.prototype.existsFieldName = function (name) {
    var fields = this.mainPanel.getCellItems(), i;
    for (i = 0; i < fields.length; i++) {
        if (fields[i].getName() === name) {
            return true;
        }
    }
    return false;
};

PMFormDesigner.prototype.existFieldId = function (id) {
    var fields = this.mainPanel.getCellItems(), i;
    for (i = 0; i < fields.length; i++) {
        if (fields[i].getId() === id) {
            return true;
        }
    }
    return false;
};

PMFormDesigner.prototype.getAutogeneratedFieldName = function (variable) {
    var fieldName = variable.getName(), finalName = fieldName, index = 0;
    while (this.existsFieldName(finalName)) {
        finalName = fieldName + "_" + (++index);
    }
    return finalName;
};

PMFormDesigner.prototype.onFieldClickHandler = function () {
    var that = this, item;
    return function (field) {
        var rows = that.propertiesTarget.getItems();
        if (that.propertiesTarget.targetInDesigner instanceof GridFieldItem) {
            item = that.propertiesTarget.targetInDesigner;
        }

        that.loadPropertiesField(field);
    }
};

PMFormDesigner.prototype.showControlSelectorWindow = function (cell, variable) {
    var that = this;
    if (!this.controlSelectorWindow) {
        this.controlsList = new PMUI.panel.ListPanel({
            id: 'controlsList',
            title: 'Please select the control you want to use with your variable...',
            filterable: false,
            visibleStatusBar: false,
            style: {
                cssClasses: ['pmdesigner-controlslist']
            }
        });
        this.controlSelectorWindow = new PMUI.ui.Window({
            title: "Select a control...",
            items: [
                this.controlsList
            ],
            style: {
                cssClasses: ['pmdesigner-controlselector']
            },
            footerItems: [{
                    text: 'Cancel',
                    handler: function () {
                        that.controlSelectorWindow.close();
                    }
                }],
            visibleFooter: true
        });
    }
    this.controlsList.clearItems();
    this.controlsList.setOnItemClickHandler(function (listPanel, listItem) {
        var field = PMFieldFactory.make({
            pmType: listItem.getData()['pmType'],
            label: variable.getLabel(),
            name: that.getAutogeneratedFieldName(variable),
            id: that.getAutogeneratedFieldName(variable)
        });
        that.loadOptionsInField(variable, field);

        field.setOnClickHandler(that.onFieldClickHandler());
        cell.addItem(field.setVariable(variable));
        field.activeMode(that.mainPanel.getFormMode());
        if (field.html && field.field.controls.length) {
            field.field.controls[0].setWidth('100%');
        }
        that.controlSelectorWindow.close();
        that.onChangeHandler(that, 'newControl', {
            target: cell.getItems(0)
        });
    });
    this.controlsList.setItems(this.createControlsList(variable, this.controlsList));
    this.controlSelectorWindow.open();
    return this;
};

PMFormDesigner.prototype.showFormSelectionWidow = function (cell) {
    var that = this;
    this.formSelectorWindow = null;
    this.formsList = null;
    this.newForm = null;

    if (!this.formSelectorWindow) {

        if (!this.newForm) {
            this.newForm = new PMUI.panel.ListPanel({
                id: 'newForm',
                title: 'Add new form...',
                filterable: false,
                visibleStatusBar: false,
                style: {
                    cssClasses: ['subFormList-list']
                },
                items: [
                    {
                        text: 'New Form',
                        visibleIcon: true,
                        style: {
                            cssClasses: ['pmdesigner-subform']
                        }
                    }
                ],
                onItemClick: function (panel, item) {
                    var field = PMFieldFactory.make({
                        pmType: 'subform',
                        name: item.text,
                        label: item.text,
                        onEditClick: function () {
                            that.loadSubForm(item.text, true);
                        }
                    });

                    field.setOnClickHandler(that.onFieldClickHandler());
                    cell.addItem(field);
                    that.formSelectorWindow.close();
                    that.onChangeHandler(that, 'newControl', {
                        target: cell.getItems(0)
                    });
                }
            });
        }
        this.subFormList.setOnItemClickHandler(
                function (panel, item) {
                    var field = PMFieldFactory.make({
                        pmType: 'subform',
                        name: item.text,
                        label: item.text
                    });

                    field.setOnClickHandler(that.onFieldClickHandler());
                    cell.addItem(field);
                    that.formSelectorWindow.close();
                    that.onChangeHandler(that, 'newControl', {
                        target: cell.getItems(0)
                    });
                });
        this.formSelectorWindow = new PMUI.ui.Window({
            title: "Please select a new or existing form...",
            items: [
                this.newForm,
                this.subFormList
            ],
            style: {
                cssClasses: ['pmdesigner-controlselector']
            },
            footerItems: [{
                    text: 'Cancel',
                    handler: function () {
                        that.formSelectorWindow.close();
                    }
                }],
            visibleFooter: true
        });
    }
    ;
    this.formSelectorWindow.open();
    return this;
};

PMFormDesigner.prototype.createFormList = function (panel) {
    console.log(panel);
    /*obj.push({
     text: controls[i] == 'checkbox'? controls[i]+"(Group)":controls[i],
     visibleIcon: true, 
     style: {
     cssClasses: ['cmp-' + controls[i]]
     },
     data: {
     pmType: controls[i]
     }
     });
     return this;*/
};

PMFormDesigner.prototype.loadOptionsInField = function (variable, field) {
    var i, configOption, option, configOptions = [];
    if (variable.fieldType == "boolean" && field.type !== "checkbox") {
        if (variable.acceptedValues.length) {
            configOptions = [
                {
                    label: variable.acceptedValues[0].value,
                    value: 1
                },
                {
                    label: variable.acceptedValues[1].value,
                    value: 0
                }
            ];
        } else {
            configOptions = [
                {
                    label: "yes",
                    value: '1',
                    selected: true
                },
                {
                    label: "no",
                    value: '0'
                }
            ];
        }
        field.setOptions(configOptions);
    } else {
        if (field.type == 'dropdown' || field.type === 'checkbox' || field.type === 'radio' || field.type == 'suggest') {
            if (variable.acceptedValues.length) {
                for (i = 0; i < variable.acceptedValues.length; i += 1) {
                    configOption = {}, option = variable.acceptedValues[i];
                    for (key in option) {
                        switch (key) {
                            case 'value':
                                configOption.label = option[key];
                                break;
                            case 'keyValue':
                                configOption.value = option[key];
                                break;
                            case 'defaultValue':
                                if (option[key] == 'Yes') {
                                    configOption.selected = true;
                                }
                                break;
                        }
                    }
                    configOptions.push(configOption);
                }
            }
            field.setOptions(configOptions);
        }
    }
    return this;
};

PMFormDesigner.prototype.createPropertiesTable = function () {
    this.propertiesTable = new PropertiesTable();
    return this;
};

PMFormDesigner.prototype.onCellDropHandler = function () {
    var that = this;
    return function (panel, item, index) {
        var field, variable;
        panel.getParent().removeCSSClasses(['pmdesigner-initialrow']);
        if (item instanceof FieldWrapper) {
            return true;
        } else if (item.text === 'Button') {
            field = PMFieldFactory.make({
                pmType: 'button'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Submit') {
            field = PMFieldFactory.make({
                pmType: 'submit'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Title') {
            field = PMFieldFactory.make({
                pmType: 'title'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Subtitle') {
            field = PMFieldFactory.make({
                pmType: 'subtitle'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'File') {
            field = PMFieldFactory.make({
                pmType: 'file'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Image') {
            field = PMFieldFactory.make({
                pmType: 'image'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Label') {
            field = PMFieldFactory.make({
                pmType: 'annotation'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Link') {
            field = PMFieldFactory.make({
                pmType: 'link'
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === 'Grid') {
            var item;
            field = PMFieldFactory.make({
                pmType: 'grid',
                onClickItemConfigHandler: that.onClickItemConfigHandler(),
                onAddColum: function (column) {
                    column.setOnBeforeContextMenu(function (column) {
                        column.setContextMenu(that.menuGrid);
                    })
                }
            });
            field.setOnClickHandler(that.onFieldClickHandler());
            field.setOnDropHandlerNewCell(that.onCellDropHandlerInGridField());
            //field.field.setWidth(jQuery(panel.html).outerWidth());
            item = field.field.addNewBlanckCell();

            /*item.setOnBeforeContextMenu( function (item) {
             item.setContextMenu(that.menuGrid);
             });*/
            field.field.addItem(item);
            panel.addItem(field);
            that.onChangeHandler(that, 'newControl', {
                target: panel.getItems(0)
            });
            return false;
        } else if (item.text === "SubForm") {
            that.showFormSelectionWidow(panel);
            return false;
        } else {
            variable = item.getVariable();
            that.showControlSelectorWindow(panel, variable);
            return false;
        }
    };
};

PMFormDesigner.prototype.onClickItemConfigHandler = function () {
    var that = this;
    return (function (fieldItem) {
        that.loadPropertiesField(fieldItem);
    });
};

PMFormDesigner.prototype.removeActiveClass = function (fieldOrCell) {
    var cell;
    if (fieldOrCell instanceof FieldWrapper) {
        cell = fieldOrCell.getParent();
    } else if (fieldOrCell instanceof PMFormCell) {
        cell = fieldOrCell;
    } else if (fieldOrCell instanceof GridFieldItem) {
        cell = fieldOrCell.parent;
    }

    if (cell) {
        cell.removeCSSClasses(['pmdesigner-active']);
    }
    return this;
};

PMFormDesigner.prototype.addActiveClass = function (field) {
    var auxField = this.propertiesTarget.targetInDesigner;
    if (auxField && auxField !== field) {
        this.removeActiveClass(auxField);
    }
    if (field.getParent()) {
        field.getParent().addCSSClasses(['pmdesigner-active']);
    }
    return this;
};

PMFormDesigner.prototype.addRowToMainPanel = function (index, rowModel) {
    var i, cells = [], currentCells;
    if (this.mainPanel) {
        if (rowModel) {
            if (typeof rowModel === 'number') {
                for (i = 0; i < rowModel; i++) {
                    cells.push({colSpan: Math.floor(this.mainPanel.cols / rowModel)});
                }
            } else {
                currentCells = rowModel.getItems();
                for (i = 0; i < currentCells.length; i++) {
                    cells.push({colSpan: currentCells[i].colSpan});
                }
            }
            this.mainPanel.addItem({onCellDrop: this.onCellDropHandler(), items: cells}, index);
        } else {
            this.mainPanel.addItem({onCellDrop: this.onCellDropHandler()}, index);
        }
    }
    return this;
};

PMFormDesigner.prototype.createMainPanel = function () {
    var that = this;
    if (this.mainPanel) {
        return this;
    }
    this.mainPanel = new PMFormGrid({
        id: 'pmdesigner-mainpanel',
        width: '100%',
        height: '100%',
        onSort: function (grid, row, i) {
            var k, j;
            that.onChangeHandler(that, 'rowOrder', {
                target: row,
                index: i
            });

            for (k = 0; k < grid.getItems().length; k++) {
                for (j = 0; j < grid.getItems()[k].getItems().length; j++) {
                    grid.getItems()[k].getItems()[j].enableBehavior();
                }
            }
        },
        onSortStart: function (grid, row) {
            var i, index, j;
            index = grid.getItems().indexOf(row);
            for (var i = 0; i < grid.getItems().length; i++) {
                if (index != i) {
                    for (var j = 0; j < grid.getItems()[i].getItems().length; j++) {
                        grid.getItems()[i].getItems()[j].disableBehavior();
                    }
                }
            }
        },
        items: [{
                onCellDrop: this.onCellDropHandler(),
                style: {
                    cssClasses: ['pmdesigner-initialrow']
                }
            }],
        //behavior: 'dropsort',
        //onDrop: this.onDropHandler(),
        onAddCell: function (grid, row, cell, item) {
            cell.setOnBeforeContextMenu(function (cell) {
                var datesType = [], items = [], item = {};
                /*if(cell.getContent()!=null){
                 if(cell.getContent().variable && cell.getContent()){
                 datesType = that.createControlsList(cell.getContent().variable); 
                 }
                 that.menu.getItems()[5].childMenu.clearItems();
                 that.menu.getItems()[5].enable();
                 for (var i = 0; i<datesType.length ; i+=1 ){
                 items.push(new PMUI.menu.MenuOption({
                 text:datesType[i].text,
                 onClick : function (menuItem){
                 var cellSelected, config, variable, typeField, field;
                 cellSelected = menuItem.getMenuTargetElement();
                 typeField = cellSelected.getContent().type;
                 config = cellSelected.getContent().getData();
                 variable = cellSelected.getContent().getVariable();
                 if (this.text !== cellSelected.getContent().type){
                 
                 cellSelected.clearItems();
                 config.variable = variable;
                 config = jQuery.extend(true, 
                 {
                 pmType: this.text,
                 label: variable.getLabel(),
                 name: that.getAutogeneratedFieldName(variable),
                 parent : this
                 },
                 config);
                 
                 field = PMFieldFactory.make(config);
                 
                 that.propertiesTarget.setTargetInDesigner(field);
                 field.setOnClickHandler(that.onFieldClickHandler());
                 cell.addItem(field.setVariable(variable));
                 that.loadPropertiesField(field);
                 }
                 }
                 }));
                 }
                 that.menu.getItems()[5].setItems(items);
                 }else{
                 that.menu.getItems()[5].disable();
                 }*/
                cell.setContextMenu(that.menu);
                /*var field;
                 field = cell.getItem(0);
                 if (field !== undefined){
                 if(!(field instanceof WrappedGridField)) {
                 console.log('no column');
                 } else {
                 console.log('yes column');
                 }
                 }else{
                 console.log('no column');
                 } 
                 */
            });
        },
        onCellAddItem: function (grid, row, cell, item) {
            //console.log("se solto el item")
            var items = grid.getItems();
            item.setColSpan(cell.colSpan);
            that.loadPropertiesField(item);
            if (items[items.length - 1] === row) {
                that.addRowToMainPanel(null, row); //a.addItem({onCellDrop: that.onCellDropHandler()});
            }
        },
        onCellBeforeColSpanChange: function (grid, row, cell, newSpan, oldSpan) {
            var usedCells = 0, i, cells = row.getItems(), maxSpan, usedSpan = 0, neededSpan, substractedSpan, availableSpan;
            if (newSpan > grid.cols || newSpan < 1) {
                return oldSpan;
            }
            for (i = 0; i < cells.length; i++) {
                if (cells[i].getItems().length) {
                    usedCells += 1;
                    if (cells[i] !== cell) {
                        usedSpan += cells[i].colSpan;
                    }
                }
            }
            maxSpan = grid.cols - usedCells + 1;
            newSpan = newSpan > maxSpan ? maxSpan : newSpan;
            neededSpan = newSpan - cell.colSpan;
            if (neededSpan > 0) {
                i = cells.length - 1;
                while (neededSpan > 0) {
                    if (cells[i] !== cell) {
                        availableSpan = cells[i].colSpan - (cells[i].getItems().length ? 1 : 0);
                        if (availableSpan >= neededSpan) {
                            substractedSpan = neededSpan;
                        } else {
                            substractedSpan = availableSpan;
                        }
                        neededSpan -= substractedSpan;
                        cells[i].getHTML().colSpan = cells[i].colSpan = cells[i].colSpan - substractedSpan;
                    }
                    i -= 1;
                }
            }
            return newSpan;
        },
        onCellColSpanChange: function (grid, row, cell, newSpan, oldSpan) {
            var diff = grid.cols, emptyCell, cells = row.getItems(), i, aux;

            if (!cell.getItems().length) {
                return;
            }

            for (i = 0; i < cells.length; i++) {
                if (cells[i].getItems().length) {
                    diff -= cells[i].colSpan;
                } else {
                    emptyCell = cells[i];
                }
            }

            if (diff) {
                if (emptyCell) {
                    emptyCell.getHTML().colSpan = emptyCell.colSpan = diff;
                } else {
                    row.addItem({
                        colSpan: diff
                    });
                }
            } else {
                if (emptyCell) {
                    emptyCell.getParent().removeItem(emptyCell);
                }
            }
        },
        onCellDropOut: function (grid, row, cell, origin, destiny) {
            that.removeActiveClass(origin);
            //console.log("se solto el item")
        }/*,
         onMouseOver : function (a){
         jQuery('#freeCell').addClass("formGrid-freeCell");            
         for (var i =0; i < that.mainPanel.getItems().length;i++){ 
         for (var j = 0 ; j < that.mainPanel.getItems()[i].getItems().length; j++){
         if(that.mainPanel.getItems()[i].getItems()[j].getHTML().children.length < 1){
         that.mainPanel.getItems()[i].getItems()[j].getHTML().appendChild(that.freeCell.cloneNode(false))
         }
         }
         }
         
         },
         onMouseOut :  function(e){
         var cell;
         jQuery('#freeCell').removeClass("formGrid-freeCell"); 
         for (var i =0; i < that.mainPanel.getItems().length;i++){ 
         for (var j = 0 ; j < that.mainPanel.getItems()[i].getItems().length; j++){
         if(that.mainPanel.getItems()[i].getItems()[j].getHTML().children.length > 0){
         if(!that.mainPanel.getItems()[i].getItems()[j].getContent()){
         cell  = that.mainPanel.getItems()[i].getItems()[j].getHTML();
         cell.removeChild(cell.childNodes[0]);    
         }
         }
         if(!that.mainPanel.getItems()[i].getItems()[j].getContent() ){
         that.mainPanel.getItems()[i].getItems()[j].getHTML().appendChild(that.freeCell.cloneNode(false))
         }
         }
         }       
         }*/
    });

    this.mainPanel.buttonClear.setHandler(function () {
        that.warningMessageForClearForm.open();
    });

    this.mainPanel.formPropertiesButton.setHandler(function () {
        that.loadPropertiesField(that.mainPanel);
    });
    return this;
};

PMFormDesigner.prototype.createOtherControlsList = function () {
    var that = this;
    if (this.otherControlsList) {
        return this;
    }
    this.otherControlsList = new PMUI.panel.ListPanel({
        id: 'idOtherControlsList',
        visibleHeader: false,
        filterable: false,
        visibleStatusBar: false,
        behavior: "dragclone",
        listHeight: 150,
        items: [
            {
                visibleIcon: true,
                text: 'Title',
                style: {
                    cssClasses: ['controls-title']
                }
            },
            {
                visibleIcon: true,
                text: 'Subtitle',
                style: {
                    cssClasses: ['controls-title']
                }
            },
            {
                visibleIcon: true,
                text: 'Label',
                style: {
                    cssClasses: ['label-field']
                }
            },
            {
                visibleIcon: true,
                text: 'Link',
                style: {
                    cssClasses: ['link-field']
                }
            },
            {
                visibleIcon: true,
                text: 'Image',
                style: {
                    cssClasses: ['image-field']
                }
            },
            {
                visibleIcon: true,
                text: 'File',
                style: {
                    cssClasses: ['fiel-field']
                }
            },
            {
                id: "otherControlsList-firstItem",
                visibleIcon: true,
                text: 'Submit',
                style: {
                    cssClasses: ['controls-submit']
                }
            },
            {
                id: "otherControlsList-secondItem",
                visibleIcon: true,
                text: 'Button',
                style: {
                    cssClasses: ['controls-button']
                }
            },
            {
                visibleIcon: true,
                text: 'Grid',
                style: {
                    cssClasses: ['grid-field']
                }
            },
            {
                visibleIcon: true,
                text: 'SubForm',
                style: {
                    cssClasses: ['subForm-field']
                }
            }
        ],
        style: {
            cssClasses: ['otherControlsList-list']
        }
    });
    return this;
}

PMFormDesigner.prototype.createSubformList = function () {
    var that = this;
    if (this.subFormList) {
        return this;
    }
    this.subFormList = new PMUI.panel.ListPanel({
        title: 'Add a existing form...',
        visibleHeader: true,
        filterable: false,
        visibleStatusBar: false,
        listHeight: 150,
        style: {
            cssClasses: ['subFormList-list']
        },
        /*onItemClick : function (item, panel) {
         var field = PMFieldFactory.make({
         pmType: 'form',
         name: item.text,
         label : item.text
         });
         
         field.setOnClickHandler(that.onFieldClickHandler());
         cell.addItem(field);
         that.formSelectorWindow.close();
         that.onChangeHandler(that, 'newControl', {
         target: cell.getItems(0)
         });
         }*/
    });
    return this;
};

PMFormDesigner.prototype.createVariablesList = function () {
    var that = this;
    if (this.variablesList) {
        return this;
    }
    this.variablesList = new PMListPanel({
        visibleHeader: false,
        filterable: true,
        visibleStatusBar: false,
        behavior: "dragclone",
        items: [],
        style: {
            cssClasses: ['components-list']
        },
        onDragStart: function () {
            var items = [], tags = jQuery('.ui-droppable');
            for (var i = 0; i < tags.length; i += 1) {
                items.push(PMUI.getPMUIObject(tags[i]));
            }
        },
        onDropOut: function (a, b, c) {
            // console.log('se solto el item de la lista');
        },
        onDraggableMouseOver: function () {
            console.log('hi')
        },
        onButtonEditItemClick: this.onButtonClickEditvariable
    });
    return this;
};

PMFormDesigner.prototype.createAccordion = function () {
    var that = this;
    if (this.accordion) {
        return this;
    }
    this.accordion = new PMUI.panel.AccordionPanel({
        style: {
            cssClasses: ['controls-accordion'],
            cssProperties: {
                'overflow': 'initial'
            }
        },
        width: 268,
        multipleSelection: true,
        hiddenTitle: true,
        items: [
            {
                id: "first-item",
                title: "Variables",
                selected: true,
                body: this.variablesList,
                style: {
                    cssClasses: ['first-item']
                }
            },
            {
                id: 'second-item',
                title: 'Other Controls',
                body: this.otherControlsList,
                selected: true,
                style: {
                    cssClasses: ['second-item']
                }
            },
            {
                id: 'third-item',
                title: 'Properties',
                body: this.propertiesTarget,
                selected: true
            }
        ],
        listeners: {
            select: function (obj, event) {
                var height1, height2, height3, tagBody;
                height1 = that.domElemntsHeight.accordion.variables;
                height2 = that.domElemntsHeight.accordion.otherControls;
                height3 = that.domElemntsHeight.accordion.properties;
                if (obj.id === 'first-item') {
                    if (obj.collapsed) {
                        tagBody = obj.getParent().getItem(2).body.html;
                        jQuery(tagBody).css('height', height3 + height1 - 16 + 'px');
                    } else {
                        tagBody = obj.getParent().getItem(2).body.html;
                        jQuery(tagBody).css('height', height3 - 16 + 'px');
                    }
                }
            }
        }
    });
    return this;
};

PMFormDesigner.prototype.createToolbox = function () {
    var title;
    if (this.toolbox) {
        return this;
    }
    title = new PMUI.ui.TextLabel({
        text: 'Toolbox',
        style: {
            cssClasses: ['toolbox-title']
        }
    });
    this.toolbox = new PMUI.core.Panel({
        items: [
            title,
            this.accordion
        ]
    });
    return this;
};

PMFormDesigner.prototype.showOptionsWindow = function (field) {
    var that = this, options = field.getOptions();
    if (!this.optionsWindow) {
        this.newOptionForm = new PMUI.form.Form({
            visibleHeader: false,
            items: [
                {
                    pmType: 'panel',
                    legend: "New option",
                    fieldset: true,
                    layout: 'hbox',
                    items: [
                        {
                            pmType: "text",
                            name: "label",
                            label: "label",
                            labelWidth: '40%',
                            controlsWidth: 160,
                            labelPosition: 'top',
                            proportion: 3
                        },
                        {
                            pmType: "text",
                            name: "value",
                            label: "value",
                            labelWidth: '40%',
                            controlsWidth: 160,
                            labelPosition: 'top',
                            proportion: 3
                        },
                        {
                            pmType: "checkbox",
                            name: "selected",
                            label: "",
                            showColon: false,
                            labelPosition: "top",
                            options: [
                                {
                                    label: "selected",
                                    value: 1
                                }
                            ],
                            proportion: 2.5
                        },
                        {
                            pmType: "buttonField",
                            value: "Add",
                            labelVisible: false,
                            buttonAlign: "center",
                            controlsWidth: 50,
                            handler: function (field) {
                                var selected, form = field.parent.form, newData = {
                                    label: form.getField("label").getValue(),
                                    value: form.getField("value").getValue()
                                }, i, rows, data;
                                selected = JSON.parse(form.getField("selected").getValue());
                                if (selected) {
                                    rows = that.optionsGrid.getItems();
                                    for (i = 0; i < rows.length; i++) {
                                        data = rows[i].getData();
                                        if (data.selected) {
                                            data.selected = false;
                                            rows[i].setData(data);
                                            break;
                                        }
                                    }
                                }
                                newData.selected = selected[0] === "1" ? true : false;
                                that.optionsGrid.addDataItem(newData);
                                form.reset();
                            },
                            proportion: 1.5
                        }
                    ]
                }
            ]
        });
        this.optionsGrid = new PMUI.grid.GridPanel({
            dataItems: options,
            filterable: false,
            width: 600,
            pageSize: 4,
            columns: [
                {
                    title: 'N.',
                    dataType: 'index',
                    width: 30
                },
                {
                    columnData: 'label',
                    title: 'Label',
                    width: 200,
                    alignmentCell: 'left',
                    alignmentTitle: "center"
                },
                {
                    columnData: 'value',
                    title: 'Value',
                    width: 120
                },
                {
                    title: "selected",
                    columnData: function (data) {
                        if (data.selected) {
                            return "Yes";
                        } else {
                            return "No";
                        }
                    },
                    width: 60
                },
                {
                    title: "Edit",
                    dataType: "button",
                    buttonLabel: "Edit",
                    width: 50
                },
                {
                    title: "Remove",
                    dataType: "button",
                    buttonLabel: "Remove",
                    width: 80,
                    onButtonClick: function (row) {
                        row.getParent().removeItem(row);
                    }
                }
            ]
        });
        this.optionsWindow = new PMUI.ui.Window({
            title: "Options Configuration",
            style: {
                cssClasses: ['pmdesigner-dropdownconfig']
            },
            footerItems: [
                {
                    text: "Save",
                    handler: function () {
                        var data = that.optionsGrid.getData();
                        field.setOptions(data);
                        that.optionsWindow.close();
                    },
                    buttonType: 'success'
                }, {
                    pmType: "label",
                    text: "or"
                }, {
                    buttonType: "link",
                    text: "Cancel",
                    handler: function () {
                        that.optionsWindow.close();
                    }
                }
            ],
            visibleFooter: true
        });
        this.optionsWindow.addItem(this.newOptionForm);
        this.optionsWindow.addItem(this.optionsGrid);
    }
    this.optionsWindow.open();
    return this;
};

PMFormDesigner.prototype.createLayout = function () {
    var that = this;

    this.layout = new PMUI.panel.LayoutPanel({
        id: "designer-body",
        height: $(document).outerHeight(),
        center: {
            items: [that.createOptionsSelector(), this.mainPanel],
            cssClasses: ['pmdesigner-mainlayout']
        },
        west: {
            size: 270,
            resizable: false,
            items: [
                this.toolbox
                        //new PMUI.ui.TextLabel({text:'Properties', style : {cssClasses : ['properties-target']}}),
                        //this.propertiesTarget
            ],
            //style: {
            cssClasses: ['right-layout-panel']
                    //}
        },
        parent: this,
        /*east: {
         size: 288,
         items : [this.otherControlsList],
         cssClasses: ['pmdesigner-layout-eastpanel']
         },*/
        onClose: function (axis) {
            var width;
            for (var i = 0; i < that.mainPanel.getCellItems().length; i++) {
                if (that.mainPanel.getCellItems()[i].type !== "title" && that.mainPanel.getCellItems()[i].type !== "subtitle") {
                    width = parseFloat(that.mainPanel.getCellItems()[i].field.dom.fieldTextLabel.style.width);
                    that.mainPanel.getCellItems()[i].field.dom.fieldTextLabel.style.width = width + width * 0.33 + "px";
                }
            }
        },
        onOpen: function (axis) {
            var width;
            for (var i = 0; i < that.mainPanel.getCellItems().length; i++) {
                if (that.mainPanel.getCellItems()[i].type !== "title" && that.mainPanel.getCellItems()[i].type !== "subtitle") {
                    width = parseFloat(that.mainPanel.getCellItems()[i].field.dom.fieldTextLabel.style.width);
                    that.mainPanel.getCellItems()[i].field.dom.fieldTextLabel.style.width = width - width * 0.2481 + "px";
                }
            }
        }
    });
};

PMFormDesigner.prototype.getLayout = function () {
    if (!this.layout) {
        this.createLayout();
    }
    this.loadPropertiesField(this.mainPanel);
    $(".pmdesigner-layout-eastpanel").css({position: 'fixed'});
    if (this.layout.html) {
        this.customSearchInputPosition();
        for (var i = 0; i < this.otherControlsList.getItems().length; i += 1) {
            //this.otherControlsList.getItems()[i].setDisplay('inline-block');
            this.otherControlsList.getItems()[i].setHeight(25);
        }
        //this.otherControlsList.dom.list.style.height = '100px';
    }
    return this.layout;
};

PMFormDesigner.prototype.defineEvents = function () {
    this.layout.defineEvents();
    this.propertiesTarget.defineEvents();
};

PMFormDesigner.prototype.getCompatibleVariablesAsOptions = function (field) {
    var variables = this.variablesVSControls[field.getType()] || [], options = [], i;
    for (i = 0; i < variables.length; i++) {
        options.push({
            label: variables[i]
        });
    }
    return options;
};

PMFormDesigner.prototype.loadPropertiesField = function (target) {
    var properties = [], property, i, propertyObject, that = this, gridField;
    this.addActiveClass(target);
    if (this.propertiesTarget.targetInDesigner instanceof  WrappedDateTimerField && target !== this.propertiesTarget.targetInDesigner) {
        this.propertiesTarget.targetInDesigner.field.controls[0].hideCalendar();
    }
    this.propertiesTarget.setTargetInDesigner(target);
    this.propertiesTarget.clearItems();

    var maxLength = 60;
    if (target instanceof WrappedTextLabelField) {
        maxLength = 10000;
    }

    for (i = 0; i < target.properties.length; i += 1) {
        propertyObject = this.properties[target.properties[i]];
        if (this.properties[target.properties[i]].typeInput === "text") {
            var a = this.propertiesTarget.addItem({
                id: target.variable ? target.variable.id : target.id,
                pmType: "text",
                label: propertyObject.label,
                name: propertyObject.name,
                value: target[propertyObject.get](),
                valueType: target.dataType,
                //valueType : this.properties[target.properties[i]].valueType || (target.variable? target.variable..getFieldType():target.dataType),
                validators: propertyObject.validators ? propertyObject.validators : (propertyObject.name == 'defaultValue' ? this.generateValidator(target.dataType) : ''),
                disabled: propertyObject.name === 'dataType' ? true : false,
                maxLength: maxLength
            });
        } else if (this.properties[target.properties[i]].typeInput === "checkbox") {
            this.propertiesTarget.addItem({
                id: target.field ? target.field.id : target.gridItem.id,
                pmType: "checkbox",
                label: propertyObject.label,
                name: propertyObject.name,
                value: target[propertyObject.get](),
                options: propertyObject.options,
                valueType: this.properties[target.properties[i]].valueType
            });
        } else if (this.properties[target.properties[i]].typeInput === "dropdown") {
            this.propertiesTarget.addItem({
                id: target.variable ? target.variable.id : target.id,
                pmType: "dropdown",
                label: propertyObject.label,
                name: propertyObject.name,
                value: target[propertyObject.get]() || "",
                options: this.loadOptionsInRowDropDown(target, target.properties[i], propertyObject.options),
                valueType: this.properties[target.properties[i]].valueType});
        } else if (this.properties[target.properties[i]].typeInput === "button") {
            this.propertiesTarget.addItem({
                id: target.id,
                pmType: "button",
                label: propertyObject.label,
                name: propertyObject.name,
                onClick: function (row) {
                    var index, target;
                    var fieldSelected, validFields = [];
                    switch (row.name) {
                        case 'dependent' :
                            that.listOfFieldsForDependecy = [];
                            currentField = row.parent.targetInDesigner;
                            that.listOfFieldsForDependecy = that.mainPanel.getCellItems().slice(0).filter(function (item) {
                                if (item.variable && !(item.type == 'datetime' || item.type == 'textarea' || item.type == 'checkbox' || item.type == 'radio') && item !== currentField) {
                                    return item;
                                }
                            });
                            if (currentField.directDependence.length) {
                                for (var k = 0; k < currentField.directDependence.length; k += 1) {
                                    dd = currentField.directDependence[k];
                                    if (dd.directDependence.length) {
                                        for (var j = 0; j < dd.directDependence.length; j += 1) {
                                            if (currentField.indirectDependence.indexOf(dd.directDependence[j]) === -1)
                                                currentField.indirectDependence.push(dd.directDependence[j]);
                                        }
                                    }
                                }
                            }
                            validFields = that.listOfFieldsForDependecy.slice(0).filter(function (arg) {
                                if (currentField.dependentFields.indexOf(arg) == -1 && currentField.directDependence.indexOf(arg) == -1 && currentField.indirectDependence.indexOf(arg) == -1) {
                                    return arg;
                                }

                            });
                            that.selectedField = currentField;
                            that.listOfEligibleFields = validFields;
                            that.showDependentFieldsWindow();
                            break;
                        case 'button' :
                            var grid = row.getParent(), field = grid.targetInDesigner;
                            that.showOptionsWindow(field);
                            break;
                        case 'dependentColumns' :
                            targetInDesigner = row.parent.targetInDesigner;
                            wrappedGrid = targetInDesigner.getParentWrapped();
                            wrappedGrid.showDependentColumns(targetInDesigner);
                            break;
                        case 'scripts':
                            that.showScriptWindow(row);
                            break;
                    }
                },
                value: propertyObject.value
            });
        } else if (this.properties[target.properties[i]].typeInput === "editableArea") {
            this.propertiesTarget.addItem({
                id: target.field.id,
                pmType: "area",
                label: propertyObject.label,
                name: propertyObject.name,
                value: target[propertyObject.get]() || "",
                valueType: this.properties[target.properties[i]].valueType
            });
        }
    }
};

PMFormDesigner.prototype.showScriptWindow = function (row) {
    var that = this;
    if (!this.scriptWindow) {
        this.scriptWindow = new PMUI.ui.Window({
            title: "Add Script please...",
            width: 880,
            height: 455,
            style: {
                cssClasses: ['pmdesigner-scripWindow']
            },
            buttonPanelPosition: 'top',
            footerAlign: 'right',
            footerItems: [
                {
                    text: "Save",
                    handler: function () {
                        console.log(that);
                        that.mainPanel.setScript(that.fieldScript.getValue());
                        that.scriptWindow.close();
                    },
                    buttonType: 'success',
                    height: 31
                }, {
                    pmType: "label",
                    text: "or"
                }, {
                    buttonType: "link",
                    text: "Cancel",
                    handler: function () {
                        that.fieldScript.setValue(that.valueScript);
                        that.scriptWindow.close();
                    },
                    style: {
                        cssClasses: ['pm-button_dependent_add']
                    }
                }
            ],
            visibleFooter: true
        });
        this.fieldScript = new PMUI.control.TextAreaControl({
            width: '90%',
            height: '90%',
            style: {
                cssProperties: {
                    marginLeft: '5%',
                }
            },
            value: this.mainPanel.getScript()
        });
        this.scriptWindow.addItem(this.fieldScript);
    }
    this.valueScript = this.fieldScript.getValue();
    this.scriptWindow.open();
    value = this.fieldScript.getValue();
    return this;
};

PMFormDesigner.prototype.loadOptionsInRowDropDown = function (fieldWrapper, property, defaultOptions) {
    var options = [], obj;
    if (property === 'variable') {
        options = this.getCompatibleVariablesAsOptions(fieldWrapper);
    } else if (property == 'validate') {
        switch (fieldWrapper.dataType) {
            case 'string' :
                for (var i = 0; i < defaultOptions.length; i += 1) {
                    if (defaultOptions[i].label === 'RealNumber' || defaultOptions[i].label === 'Email' || defaultOptions[i].label === 'Login' || defaultOptions[i].label === 'Integer') {
                        defaultOptions[i].disabled = true;
                    } else {
                        defaultOptions[i].disabled = false;
                    }
                }
                break;
            case 'integer':
                for (var i = 0; i < defaultOptions.length; i += 1) {
                    if (defaultOptions[i].label === 'Alphabetic' || defaultOptions[i].label === 'Alphanumeric' || defaultOptions[i].label === 'Email' || defaultOptions[i].label === 'Login') {
                        defaultOptions[i].disabled = true;
                    } else {
                        defaultOptions[i].disabled = false;
                    }
                }
                break;

                break;
            case 'float':
                for (var i = 0; i < defaultOptions.length; i += 1) {
                    if (defaultOptions[i].label === 'Alphabetic' || defaultOptions[i].label === 'Alphanumeric' || defaultOptions[i].label === 'Email' || defaultOptions[i].label === 'Login') {
                        defaultOptions[i].disabled = true;
                    } else {
                        defaultOptions[i].disabled = false;
                    }
                }

                break;
        }
        options = defaultOptions;
    } else {
        options = defaultOptions;
    }
    return options;
};

PMFormDesigner.prototype.generateValidator = function (type_value) {
    var re,
            validators = [],
            config = {
                pmType: "regexp",
                type: 'error'
            };

    switch (type_value) {
        case 'float' :
            re = /^\d+(\.\d+)?$/;
            break;
        case 'string':
            re = /^([a-zA-Z1-9]+\s{1})*([a-zA-Z1-9])*$/i;
            break;
        case 'integer':
            re = /^(-)?[0-9]+$/
            break;
    }
    config.criteria = re;
    config.errorMessage = 'Please enter a valid ' + type_value;
    validators.push(config);
    return validators;
};

PMFormDesigner.prototype.updateField = function (fieldRow, newValue, previousValue, target) {
    var property, i, variable, fields, parentWidth = jQuery(target.parent.html).outerWidth();
    if (target instanceof PMFormGrid) {
        fields = this.mainPanel.getCellItems();
        for (i = 0; i < fields.length; i += 1) {
            if (fields[i].mode == "parent") {
                fields[i].activeMode(newValue);
            }
        }
    }
    if (fieldRow.name === 'colspan') {
        parentWidth = jQuery(target.parent.html).outerWidth();
        target.parent.setColSpan(parseInt(newValue, 10));
        target.setColSpan(parseInt(newValue));
        if (target.type === 'grid') {
            target.field.setDisplay('none');
            target.field.dom.listContainer.style.width = 'auto';
            target.field.dom.listContainer.style.width = jQuery(target.parent.html).outerWidth() + 4 + 'px';
            target.field.setDisplay('block');
            //target.field.dom.list.style.width = jQuery(target.parent.html).outerWidth()+100+'px';
        }
    } else if (fieldRow.name === 'variable') {
        variable = this.variables.find("name", newValue);
        target.setVariable(variable);
        target.setLabel(variable.getLabel());
        this.loadPropertiesField(field);
    } else {
        if (target.dataType === "boolean" && fieldRow.name === 'defaultValue') {
            target.setDefaultValueForBoolean(newValue);
        } else {
            if (target.properties.indexOf(fieldRow.name) != -1) {
                target[this.properties[target.properties[target.properties.indexOf(fieldRow.name)]].set](newValue);
            }
        }
    }
};

PMFormDesigner.prototype.getData = function (allView) {
    var that = this;
    if (allView === true) {
        var options = that.options.items.asArray();
        options[0].selectItem();
        that.loadSubForm('Main', false, options[0]);
    }
    var i, j, rows = this.mainPanel.getItems(), data, dataRows = [], currentRow, cells, cellItem, data, nullRow, index, variables = [];
    var objectVariable, variable, script = {};

    for (i = 0; i < rows.length; i++) {
        nullRow = true;
        currentRow = [];
        cells = rows[i].getItems();
        for (j = 0; j < cells.length; j++) {
            cellItem = cells[j].getItem(0);
            if (!cellItem) {
                currentRow.push({
                    colSpan: cells[j].colSpan
                });
            } else {
                if (cellItem.variable != null) {
                    objectVariable = cellItem.getVariable();
                    variable = {};
                    for (var key in objectVariable) {
                        if (objectVariable.hasOwnProperty(key)) {
                            variable["var_" + key] = objectVariable[key];
                        }
                    }
                    var sw = false;
                    for (var vi = 0; vi < variables.length; vi++) {
                        if (variables[vi].var_uid === variable.var_uid) {
                            sw = true;
                        }
                    }
                    if (sw === false) {
                        variables.push(variable);
                    }
                }
                nullRow = false;
                data = cellItem.getData();
                data.type = cellItem.type;
                delete data.variable;
                currentRow.push(data);
            }
        }
        if (!nullRow) {
            dataRows.push(currentRow);
        }
    }
    dataRows.push(
            this.mainPanel.dom.pmHiddenFieldsPanel.getItems()
            );
    /*custom data for script in form*/
    script.type = 'script';
    script.code = this.mainPanel.getScript();

    data = {
        name: this.mainPanel.getFormName(),
        items: [{
                id: this.mainPanel.getFormId(),
                mode: this.mainPanel.getFormMode(),
                type: "form",
                items: dataRows,
                variables: variables,
                subForms: this.subForm,
                script: script
            }
        ]
    };
    data = that.convertDataToSubform(data);//todo
    return data;
};

PMFormDesigner.prototype.getVariable = function (variableName) {
    return this.variables.find("name", variableName);
};

PMFormDesigner.prototype.setForm = function (data) {
    var items = [], subitems, i, j, itemsToAdd, configOptions, that = this;
    items = (data && data.items && data.items[0] && data.items[0].items) || [];
    var configDependentFields = {};
    this.mainPanel.clearItems();
    this.mainPanel.setFormName(data.name || '');
    this.mainPanel.setFormId(data.items.length == 0 ? 'Form-' + PMUI.generateUniqueId() : data.items[0].id);
    this.mainPanel.setFormMode(data.items.length == 0 ? 'edit' : data.items[0].mode);
    this.mainPanel.setScript(data.items.length == 0 ? 'edit' : data.items[0].script ? data.items[0].script.code || "" : "");
    if (items.length) {
        for (i = 0; i < items.length; i += 1) {
            itemsToAdd = [];
            subitems = items[i];
            for (j = 0; j < subitems.length; j += 1) {
                if (subitems[j].type) {
                    if (subitems[j].type === 'hidden') {
                        this.mainPanel.dom.pmHiddenFieldsPanel.createItem(subitems[j]);
                    } else {
                        subitems[j].pmType = subitems[j].type;
                        configOptions = jQuery.extend(true, {}, subitems[j]);
                        if (subitems[j].dataType == "boolean") {
                            if (subitems[j].type == "dropdown") {
                                configOptions.pmType = 'yesnodropdown';
                            } else {
                                configOptions.pmType = "yesnoradio";
                            }
                        } else {
                            configOptions.pmType = subitems[j].type;
                        }
                        if (subitems[j].dependentFields) {
                            configDependentFields[subitems[j].name] = subitems[j].dependenceStates;
                        }
                        configOptions.variable = this.getVariable(subitems[j].var_name);
                        if (configOptions.pmType === 'grid') {
                            configOptions.onClickItemConfigHandler = this.onClickItemConfigHandler();
                            configOptions.onAddColum = function (column) {
                                column.setOnBeforeContextMenu(function (column) {
                                    column.setContextMenu(that.menuGrid);
                                })
                            };
                        }
                        if (configOptions.pmType === 'subform') {
                            configOptions.onEditClick = function () {
                                that.loadSubForm(this.name, true);
                            };
                        }
                        configOptions.onClick = this.onFieldClickHandler();
                        itemsToAdd.push({
                            colSpan: subitems[j].colSpan,
                            items: [PMFieldFactory.make(configOptions)]
                        });
                    }
                } else {
                    itemsToAdd.push({colSpan: subitems[j].colSpan});
                }
            }
            this.mainPanel.addItem({items: itemsToAdd, onCellDrop: this.onCellDropHandler()});

            if (this.mainPanel.getItems()[this.mainPanel.getItems().length - 1]) {
                for (var k = 0; k < this.mainPanel.getItems()[this.mainPanel.getItems().length - 1].getCellItems().length; k++) {
                    this.mainPanel.getItems()[this.mainPanel.getItems().length - 1].getCellItems()[k].setColSpan(itemsToAdd[k].colSpan);
                    if (this.mainPanel.getItems()[this.mainPanel.getItems().length - 1].getCellItems()[k].mode === "parent") {
                        this.mainPanel.getItems()[this.mainPanel.getItems().length - 1].getCellItems()[k].activeMode(this.mainPanel.getFormMode());
                    }
                }
            }
        }
        this.setDependentFields(configDependentFields);
        this.addRowToMainPanel();
    } else {
        this.clearForm();
    }
    /*for(var i = 0 ; this.mainPanel.getCellItems().length ; i++){
     this.mainPanel.getCellItems()[i].field.controls[0].setWidth('100%');
     }*/

    this.loadPropertiesField(this.mainPanel);
    return this;
};

PMFormDesigner.prototype.setDependentFields = function (config) {
    var field, directDependence = [], indirectDependence = [], dependents = [], afectedField, dependentsField;
    for (field in config) {

        afectedField = this.mainPanel.getCellItems().filter(function (x) {
            if (x.name == field)
            {
                return x;
            }
        });
        if (afectedField.length) {
            afectedField = afectedField[0];
            indirectDependence = JSON.parse(config[field].indirectDependence);
            directDependence = JSON.parse(config[field].directDependence);
            dependents = JSON.parse(config[field].dependentFields);
            if (indirectDependence.length) {
                indirectDependence = this.mainPanel.getCellItems().filter(function (x) {
                    if (JSON.parse(config[field].indirectDependence).indexOf(x.name) > -1)
                    {
                        return x;
                    }
                });
            }
            ;
            if (directDependence.length) {
                directDependence = this.mainPanel.getCellItems().filter(function (x) {
                    if (JSON.parse(config[field].directDependence).indexOf(x.name) > -1)
                    {
                        return x;
                    }
                });
            }
            ;
            if (dependents.length) {
                dependents = this.mainPanel.getCellItems().filter(function (x) {
                    if (JSON.parse(config[field].dependentFields).indexOf(x.name) > -1)
                    {
                        return x;
                    }
                });
            }
            ;
            afectedField.setDependentFields(dependents);
            afectedField.setIndirectDependence(indirectDependence);
            afectedField.setDirectDependence(directDependence);

        }
    }
};

PMFormDesigner.prototype.reset = function (form, variables) {
    this.setVariables(variables || []);
    this.setForm(form);
    return this;
};

PMFormDesigner.prototype.getVarConfigOptions = function (variable) {
    return {
        acceptedValues: variable["var_accepted_values"],
        dbConnection: variable["var_dbconnection"],
        defaultValue: variable["var_default"],
        fieldSize: variable["var_field_size"],
        fieldType: variable["var_field_type"],
        label: variable["var_label"],
        name: variable["var_name"],
        allowNull: variable["var_null"],
        sql: variable["var_sql"],
        uid: variable["var_uid"]
    };
};

PMFormDesigner.prototype.removeVariableFromSupportingList = function (variable) {
    var i = 0, control, variablesArray, index;
    for (control in this.variablesVSControls) {
        if (this.variablesVSControls.hasOwnProperty(control)) {
            index = null;
            variablesArray = this.variablesVSControls[control];
            index = variablesArray.indexOf(variable.getName());
            if (index >= 0) {
                variablesArray.splice(index, 1);
            }
        }
    }
    return this;
};

PMFormDesigner.prototype.clearSupportingList = function () {
    this.variablesVSControls = {};
    return this;
};

PMFormDesigner.prototype.addVariableToSupportingList = function (variable) {
    var controls = variable.getSupportedControls(), i;
    for (i = 0; i < controls.length; i++) {
        if (!this.variablesVSControls[controls[i]]) {
            this.variablesVSControls[controls[i]] = [];
        }
        this.variablesVSControls[controls[i]].push(variable.getName());
    }

    return this;
};

PMFormDesigner.prototype.addVariable = function (variable) {
    var variableObject = new PMVariable(this.getVarConfigOptions(variable)), itemVariable;
    this.variables.insert(variableObject);
    this.addVariableToSupportingList(variableObject);
    itemVariable = new PMListItem({
        textLabel: variable.var_label,
        textName: variable.var_name,
        textType: variable.var_field_type,
        variable: variableObject
    });
    this.variablesList.addItem(itemVariable);
    return this;
};

PMFormDesigner.prototype.setVariables = function (variables) {
    var i;
    this.clearVariables();
    this.clearSupportingList();
    if (jQuery.isArray(variables)) {
        for (i = 0; i < variables.length; i++) {
            this.addVariable(variables[i]);
        }
    } else {
        throw new Error("setVariables(): The parameter must be an array.");
    }
    return this;
};

PMFormDesigner.prototype.setSubForms = function (forms) {
    var i;
    if (!(jQuery.isArray(forms))) {
        throw new Error("setVariables(): The parameter must be an array.");
    }
    this.clearSubForms();
    for (i = 0; i < forms.length; i += 1) {
        this.addSubForm(forms[i]);
    }
    return this;
};

PMFormDesigner.prototype.clearSubForms = function () {
    this.subForms = [];
    this.subFormList.clearItems();
    return this;
};

PMFormDesigner.prototype.addSubForm = function (form) {
    var obj = {};
    if (typeof form == "object") {
        this.subForms.push(form);
        obj = {
            text: form.name,
            //id : form.id,
            visibleIcon: true,
            style: {
                cssClasses: ['pmdesigner-subform']
            }
        };
        this.subFormList.addItem(obj);
    }
    return this;
};

PMFormDesigner.prototype.getVariables = function () {
    return this.variables.asArray();
};

PMFormDesigner.prototype.clearVariables = function () {
    while (this.variables.getSize() > 0) {
        this.removeVariable(0);
    }
    return this;
};

PMFormDesigner.prototype.removeVariable = function (variable) {
    var i, variableToRemove;
    this.variablesList.removeItem(variable);
    if (this.variables.getSize()) {
        variableToRemove = this.variables.get(variable);
        this.variables.remove(variableToRemove);
    }
    this.removeVariableFromSupportingList(variableToRemove);
    return this;
};
/*PMFormDesigner.prototype.showDependentColumnsGrid = function (column, wrappedGrid, cell){
 var i;
 
 };*/
PMFormDesigner.prototype.showDependentFieldsWindow = function () {
    var that = this, i, panelGrids, panelLeft, panelRight, titleListFields, titleListDependent, item, copyDependents, exist, flag = false, rowDelete;
    this.listOfFieldsOfGrid = [], this.listOfDependentFieldsGrid = [];
    if (!this.dependentWindow) {
        this.errorMessageWindow = new PMUI.ui.MessageWindow({
            width: 490,
            bodyHeight: 'auto',
            message: 'Do you want to delete this Field',
            windowMessageType: 'error',
            footerItems: [
                {
                    text: "Delete",
                    handler: function () {
                        rowDelete.getParent().removeItem(rowDelete);
                        that.listFieldGrid.addDataItem(rowDelete.getData());
                        that.errorMessageWindow.close();
                    },
                    height: 40
                },
                {
                    pmType: 'label',
                    text: 'or'
                }, {
                    text: "Cancel",
                    buttonType: "link",
                    handler: function () {
                        that.errorMessageWindow.close();
                    }
                }
            ],
            visibleFooter: true
        });
        this.warningMessageWindow = new PMUI.ui.MessageWindow({
            width: 490,
            bodyHeight: 'auto',
            message: 'you want to cancel changes?',
            windowMessageType: 'warning',
            footerItems: [
                {
                    text: "Yes",
                    handler: function () {
                        that.warningMessageWindow.close();
                        that.dependentWindow.close();
                    },
                    buttonType: "warning",
                    height: 40
                },
                {
                    pmType: 'label',
                    text: 'or'
                }, {
                    text: "No",
                    buttonType: "link",
                    handler: function () {
                        that.warningMessageWindow.close();
                    }
                }
            ],
            visibleFooter: true
        });

        flag = true;

        titleListFields = new PMUI.ui.TextLabel({
            textMode: 'plain',
            text: 'Fields List',
            style: {
                cssClasses: ['pm-titleListFields']
            }
        });

        titleListDependent = new PMUI.ui.TextLabel({
            textMode: 'plain',
            text: 'List Dependet Fields',
            style: {
                cssClasses: ['pm-titleListDependent']
            }
        });

        panelGrids = new PMUI.core.Panel({
            layout: 'hbox',
            width: 850,
            style: {
                cssClasses: ['pm-dependent-fields'],
                cssProperties: {
                    'marginLeft': '5px'
                }
            }
        });

        panelLeft = new PMUI.core.Panel({
            style: {
                cssClasses: ['pm-dependent-panelLeft']
            }
        });

        panelRight = new PMUI.core.Panel({
            style: {
                cssClasses: ['pm-dependent-panelRight']
            }
        });

        this.dependentWindow = new PMUI.ui.Window({
            title: "Add dependents",
            width: 880,
            height: 455,
            style: {
                cssClasses: ['pmdesigner-dependencyFieldWindow']
            },
            buttonPanelPosition: 'top',
            footerAlign: 'right',
            footerItems: [
                {
                    text: "Save",
                    handler: function () {
                        var i, removeItemsOfDependetList, fieldDeleting, k, afectedField, index, j, l, listOfOtherDenendent, flag;
                        removeItemsOfDependetList = that.listOfDependentFieldsGrid.filter(function (x) {
                            flag = true;
                            for (k = 0; k < that.dependentFieldsGrid.getData().length; k++) {
                                if (that.dependentFieldsGrid.getData()[k].var_name === x.var_name) {
                                    flag = false;
                                }
                            }
                            if (flag) {
                                return x
                            }
                        });

                        for (i = 0; i < that.dependentFieldsGrid.getItems().length; i += 1) {
                            afectedField;
                            afectedField = that.listOfEligibleFields.filter(function (x) {
                                if (x.name === that.dependentFieldsGrid.getItems()[i].getCells()[0].getContent()) {
                                    return x;
                                }
                            });
                            if (afectedField.length) {
                                afectedField = afectedField[0];
                                afectedField.directDependence.push(that.selectedField);
                                that.selectedField.dependentFields.push(afectedField);

                                if (that.selectedField.directDependence.length) {
                                    for (k = 0; k < that.selectedField.directDependence.length; k++) {
                                        if (afectedField.indirectDependence.indexOf(that.selectedField.directDependence[k]) === -1) {
                                            afectedField.indirectDependence.push(that.selectedField.directDependence[k])
                                        }
                                    }
                                }

                                if (that.selectedField.indirectDependence.length) {
                                    for (k = 0; k < that.selectedField.indirectDependence.length; k++) {
                                        if (afectedField.indirectDependence.indexOf(that.selectedField.indirectDependence[k]) === -1) {
                                            afectedField.indirectDependence.push(that.selectedField.indirectDependence[k]);
                                        }
                                    }
                                }
                            }
                        }

                        if (removeItemsOfDependetList.length) {
                            for (index = 0; index < removeItemsOfDependetList.length; index++) {
                                removeField = removeItemsOfDependetList[index];

                                fieldDeleting = that.listOfFieldsForDependecy.filter(function (x) {
                                    if (x.name == removeField.var_name) {
                                        return x
                                    }
                                })
                                if (fieldDeleting.length) {
                                    fieldDeleting = fieldDeleting[0];
                                    pos = that.selectedField.dependentFields.indexOf(fieldDeleting);
                                    if (pos > -1) {
                                        that.selectedField.dependentFields.splice(pos, 1);
                                    }
                                    pos = fieldDeleting.directDependence.indexOf(that.selectedField);
                                    if (pos > -1) {
                                        fieldDeleting.directDependence.splice(pos, 1);
                                    }
                                    fieldDeleting.indirectDependence = [];

                                    for (i = 0; i < fieldDeleting.directDependence.length; i++) {
                                        for (j = 0; j < fieldDeleting.directDependence[i].directDependence.length; j++) {
                                            if (fieldDeleting.indirectDependence.indexOf(fieldDeleting.directDependence[i].directDependence[j]) == -1) {
                                                fieldDeleting.indirectDependence.push(fieldDeleting.directDependence[i].directDependence[j]);
                                            }
                                        }
                                        for (j = 0; j < fieldDeleting.directDependence[i].indirectDependence.length; j++) {
                                            if (fieldDeleting.indirectDependence.indexOf(fieldDeleting.directDependence[i].indirectDependence[j]) == -1) {
                                                fieldDeleting.indirectDependence.push(fieldDeleting.directDependence[i].indirectDependence[j]);
                                            }
                                        }
                                    }

                                    for (i = 0; i < fieldDeleting.dependentFields.length; i++) {
                                        fieldDeleting.dependentFields[i].indirectDependence = [];
                                        for (j = 0; j < fieldDeleting.dependentFields[i].directDependence.length; j++) {
                                            for (k = 0; k < fieldDeleting.dependentFields[i].directDependence[j].indirectDependence.length; k++) {
                                                if (fieldDeleting.dependentFields[i].indirectDependence.indexOf(fieldDeleting.dependentFields[i].directDependence[j].indirectDependence[k]) == -1) {
                                                    fieldDeleting.dependentFields[i].indirectDependence.push(fieldDeleting.dependentFields[i].directDependence[j].indirectDependence[k]);
                                                }
                                            }
                                            for (k = 0; k < fieldDeleting.dependentFields[i].directDependence[j].directDependence.length; k++) {
                                                if (fieldDeleting.dependentFields[i].indirectDependence.indexOf(fieldDeleting.dependentFields[i].directDependence[j].directDependence[k]) == -1) {
                                                    fieldDeleting.dependentFields[i].indirectDependence.push(fieldDeleting.dependentFields[i].directDependence[j].directDependence[k]);
                                                }
                                            }
                                        }
                                    }

                                    listOfOtherDenendent = that.listOfFieldsForDependecy.filter(function (x) {
                                        if (x.indirectDependence.indexOf(fieldDeleting) > -1) {
                                            return x;
                                        }
                                    })
                                    for (i = 0; i < listOfOtherDenendent.length; i++) {
                                        listOfOtherDenendent[i].indirectDependence = [];
                                        listOfOtherDenendent[i].indirectDependence.push(fieldDeleting);
                                        for (j = 0; j < listOfOtherDenendent[i].directDependence.length; j++) {
                                            for (k = 0; k < listOfOtherDenendent[i].directDependence[j].indirectDependence.length; k++) {
                                                if (listOfOtherDenendent[i].indirectDependence.indexOf(listOfOtherDenendent[i].directDependence[j].indirectDependence[k]) == -1) {
                                                    listOfOtherDenendent[i].indirectDependence.push(listOfOtherDenendent[i].directDependence[j].indirectDependence[k]);
                                                }
                                            }
                                            for (k = 0; k < listOfOtherDenendent[i].directDependence[j].directDependence.length; k++) {
                                                if (listOfOtherDenendent[i].indirectDependence.indexOf(listOfOtherDenendent[i].directDependence[j].directDependence[k]) == -1) {
                                                    listOfOtherDenendent[i].indirectDependence.push(listOfOtherDenendent[i].directDependence[j].directDependence[k]);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        that.flashMessage.setMessage('save succesfuly');
                        that.flashMessage.show();
                        that.dependentWindow.close();
                    },
                    buttonType: 'success',
                    height: 31
                }, {
                    pmType: "label",
                    text: "or"
                }, {
                    buttonType: "link",
                    text: "Cancel",
                    handler: function () {
                        var i, isDirt = false;

                        for (i = 0; i < that.dependentFieldsGrid.getItems().length; i += 1) {
                            if (that.copyItemsDependentFiels.indexOf(that.dependentFieldsGrid.getItems()[i]) == -1) {
                                isDirt = true;
                            }
                        }
                        for (i = 0; i < that.listFieldGrid.getItems().length; i += 1) {
                            if (that.copyItemsListFiels.indexOf(that.listFieldGrid.getItems()[i]) == -1) {
                                isDirt = true;
                            }
                        }
                        if (isDirt) {
                            that.warningMessageWindow.open();
                        } else {
                            that.dependentWindow.close();
                        }
                    },
                    style: {
                        cssClasses: ['pm-button_dependent_add']
                    }
                }
            ],
            visibleFooter: true
        });

        this.listFieldGrid = new PMUI.grid.GridPanel({
            filterable: true,
            width: 400,
            pageSize: 6,
            columns: [
                {
                    columnData: 'var_name',
                    title: 'Field Name',
                    width: 130,
                    alignmentTitle: 'center',
                    alignmentCell: 'left',
                    dataType: 'string'
                }, {
                    columnData: 'var_label',
                    title: 'Field Label',
                    width: 100,
                    alignmentTitle: 'center',
                    alignmentCell: 'left',
                    dataType: 'string'
                }, {
                    columnData: 'var_type',
                    title: 'Type',
                    width: 60,
                    alignmentCell: 'left',
                    alignmentTitle: 'center',
                    dataType: 'string'
                }, {
                    title: 'Add',
                    dataType: 'button',
                    buttonLabel: 'Add',
                    width: 50,
                    onButtonClick: function (row) {
                        that.dependentFieldsGrid.addDataItem(row.getData());
                        row.parent.removeItem(row);
                    }
                }
            ],
            display: 'inline-block',
            style: {
                cssClasses: ['pm-listFieldGrid']
            }
        });

        this.dependentFieldsGrid = new PMUI.grid.GridPanel({
            behavior: 'dragdrop',
            filterable: true,
            width: 400,
            display: 'inline-block',
            pageSize: 6,
            columns: [
                {
                    columnData: 'var_name',
                    title: 'Name Field',
                    width: 130,
                    alignmentTitle: 'center',
                    alignmentCell: 'left',
                    dataType: 'string'
                }, {
                    columnData: 'var_label',
                    title: 'Field Label',
                    width: 100,
                    alignmentTitle: 'center',
                    alignmentCell: 'left',
                    dataType: 'string'
                }, {
                    columnData: 'var_type',
                    title: 'Type',
                    width: 60,
                    alignmentCell: 'left',
                    alignmentTitle: 'center',
                    dataType: 'string'
                }, {
                    title: 'Remove',
                    dataType: 'button',
                    buttonLabel: 'Remove',
                    width: 70,
                    style: {
                        cssClasses: ['pm-button_dependent_remove']
                    },
                    onButtonClick: function (row) {
                        that.errorMessageWindow.open();
                        rowDelete = row;
                    }
                }
            ],
            style: {
                cssClasses: ['pm-dependentFieldsGrid']
            }
        });

        //panelLeft.addItem(titleListFields);
        panelLeft.addItem(this.listFieldGrid);
        //panelRight.addItem(titleListDependent);
        panelRight.addItem(this.dependentFieldsGrid);
        panelGrids.addItem(panelLeft);
        panelGrids.addItem(panelRight);

        this.dependentWindow.addItem(panelGrids);
    }
    this.listFieldGrid.clearItems();
    this.dependentFieldsGrid.clearItems();

    if (this.listOfEligibleFields.length) {
        for (var i = 0; i < this.listOfEligibleFields.length; i++) {
            this.listFieldGrid.addDataItem({
                var_type: this.listOfEligibleFields[i].variable.fieldType,
                var_name: this.listOfEligibleFields[i].name,
                var_label: this.listOfEligibleFields[i].label
            })
        }
    }

    if (this.selectedField.dependentFields.length) {
        for (var i = 0; i < this.selectedField.dependentFields.length; i++) {
            this.dependentFieldsGrid.addDataItem({
                var_type: this.selectedField.dependentFields[i].variable.fieldType,
                var_name: this.selectedField.dependentFields[i].name,
                var_label: this.selectedField.dependentFields[i].label
            })
        }
    }

    this.listOfFieldsOfGrid = this.listFieldGrid.getData(), this.listOfDependentFieldsGrid = this.dependentFieldsGrid.getData();
    this.dependentWindow.open();

    this.copyItemsDependentFiels = this.dependentFieldsGrid.items.asArray();
    this.copyItemsListFiels = this.listFieldGrid.items.asArray();
    this.dependentWindow.defineEvents();
    return this;
};

PMFormDesigner.prototype.clearForm = function () {
    this.mainPanel.clearItems();
    this.addRowToMainPanel();
    this.mainPanel.setMessageHelp();
//    this.mainPanel.dom.pmHiddenFieldsPanel.clearItems();
};

PMFormDesigner.prototype.onCellDropHandlerInGridField = function () {
    var that = this, itemsNotValid;
    itemsNotValid = ["Submit", "Title", "Subtitle", "File", "Grid"];
    return function (panel, item, index) {
        var text = item.text, position, field, variable;
        position = itemsNotValid.indexOf(text);
        if (position == -1) {
            if (item.variable !== undefined) {
                variable = item.getVariable();
                that.showControlsForGridField(panel, variable);
            } else {
                if (text === "Button") {
                    column = PMGridFieldFactory.make({
                        pmType: "button"
                    });
                    that.addNewItemInGridField(panel, column);
                } else if (text === "Link") {
                    column = PMGridFieldFactory.make({
                        pmType: "link"
                    });
                    that.addNewItemInGridField(panel, column);
                } else if (text === "Image") {
                    column = PMGridFieldFactory.make({
                        pmType: "image"
                    });
                    that.addNewItemInGridField(panel, column);
                }
            }
            return false;
        } else {
            alert('is no posible add item in grid');
            return false;
        }
    };
};

PMFormDesigner.prototype.addNewItemInGridField = function (cell, item) {
    var that = this, parentCellGrid, newCell, widthParent, blackCellItem, widthNewCell;
    parentCellGrid = cell.getParent();
    parentCellGrid.removeItem(cell);
    newCell = new GridFieldCell({
        items: [item]
    });
    parentCellGrid.addItem(newCell);
    blackCellItem = parentCellGrid.addNewBlanckCell();
    parentCellGrid.addItem(blackCellItem);
    parentCellGrid.addItem(blackCellItem);
    //item.gridItem.dom.labelTextContainer.style.width = ($(item.html).outerWidth()-30)+"px";
    return this;
}

PMFormDesigner.prototype.showControlsForGridField = function (cell, variable) {
    var that = this;
    //instanciar globalmente
    //controlsForGridWindow , controlsForGridList
    if (!this.controlsForGridWindow) {
        this.controlsForGridList = new PMUI.panel.ListPanel({
            id: 'controlsForGridList',
            title: 'Please select the control that will be associated to the variable...',
            filterable: false,
            visibleStatusBar: false,
            style: {
                cssClasses: ['pmdesigner-controlslist']
            }
        });
        this.controlsForGridWindow = new PMUI.ui.Window({
            title: "Selected a Control for this Column",
            items: [
                this.controlsForGridList
            ],
            style: {
                cssClasses: ['pmdesigner-controlselector']
            },
            footerItems: [{
                    text: 'Cancel',
                    handler: function () {
                        that.controlsForGridWindow.close();
                    }
                }],
            visibleFooter: true
        });
    }
    this.controlsForGridList.clearItems();
    this.controlsForGridList.setOnItemClickHandler(function (listPanel, listItem) {
        var column, newCell, parentCellGrid, blackCellItem, widthNewCell, widthParent;
        column = PMGridFieldFactory.make({
            pmType: listItem.getData()['pmType'],
            title: variable.getLabel(),
            name: that.getAutogeneratedFieldName(variable),
            id: that.getAutogeneratedFieldName(variable),
            hiddenControl: true
        });

        //that.loadOptionsInField(variable, column);
        that.loadOptionsInField(variable, column);
        column.setVariable(variable);
        that.addNewItemInGridField(cell, column);
        that.controlsForGridWindow.close();
    });
    this.controlsForGridWindow.open();
    this.controlsForGridList.setItems(this.createControlsList(variable, this.controlsForGridList));
    return this;
};

PMFormDesigner.prototype.renderLayout = function (value) {
    var value = value || true;
    this.getLayout().render(value);
    this.setSizeInElements();
    ;
    return this;
};

PMFormDesigner.prototype.setSizeInElements = function () {
    var i, listVariables, otherControls, propertiesTable, item, itemBodyHtml;
    this.domElemntsHeight.accordion = {};

    itemBodyHtml = this.accordion.getItem(1).body.html;
    //this.layout.setHeight(jQuery(document).outerHeight()-17);
    //this.layout.setWidth('auto');
    this.domElemntsHeight.accordion.otherControls = $(itemBodyHtml).outerHeight();
    this.domElemntsHeight.body = jQuery(document.body).outerHeight() - this.domElemntsHeight.accordion.otherControls;

    itemBodyHtml = this.accordion.getItem(0).body.html;
    jQuery(itemBodyHtml).css('height', this.domElemntsHeight.body * 0.3 + 'px');
    this.domElemntsHeight.accordion.variables = $(itemBodyHtml).outerHeight();

    itemBodyHtml = this.accordion.getItem(2).body.html;
    itemHeight = this.domElemntsHeight.accordion.variables + this.domElemntsHeight.accordion.otherControls;
    jQuery(itemBodyHtml).css('height', itemHeight - 35 + 'px');
    this.domElemntsHeight.accordion.properties = $(itemBodyHtml).outerHeight();

    return this;
};

PMFormDesigner.prototype.subForm = [];

PMFormDesigner.prototype.oldOption = null;

PMFormDesigner.prototype.createOptionsSelector = function () {
    var that = this;

    this.options = new PMUI.control.OptionsSelectorControl({
        items: [{
                text: 'Main',
                value: 'Main',
                selected: true
            }
        ],
        listeners: {
            select: function (item, event) {
                that.loadSubForm(item.text, false, item);
            }
        }
    });
    that.oldOption = that.options.items.asArray()[0];

    this.options.defineEvents();
    return this.options;
};

PMFormDesigner.prototype.createOptionSelector = function (name, id) {
    var that = this;
    var sw = true;
    var options = that.options.items.asArray();
    for (var i = 0; i < options.length; i++) {
        if (options[i].value === name) {
            sw = false;
            options[i].selectItem();
            break;
        }
    }
    if (sw) {
        that.options.addItem({
            id: id,
            text: name,
            value: name
        });
        options = that.options.items.asArray();
        options[options.length - 1].selectItem();
    }
};

PMFormDesigner.prototype.loadSubForm = function (name, create, item) {
    var that = this;
    //save state
    if (that.oldOption.value === 'Main') {
        that.dyn_content = that.getData();
    } else {
        var index = that.getSubform(that.oldOption.value);
        var data = that.getData();
        data.name = that.oldOption.value;
        delete data.items[0].subForms;
        if (index !== null) {
            that.subForm[index] = data;
        } else {
            that.subForm.push(data);
        }
    }

    //clear form
    that.clearForm();

    //create option - selection option
    if (create) {
        that.createOptionSelector(name);
    }

    //load form subform
    if (name === 'Main') {
        that.setForm(that.dyn_content);
    } else {
        var index = that.getSubform(name);
        if (index !== null) {
            that.setForm(that.subForm[index]);
        }
    }

    //old
    if (item !== undefined) {
        that.oldOption = item;
    } else {
        var op = that.options.items.asArray();
        that.oldOption = op[op.length - 1];
    }
};

PMFormDesigner.prototype.clearOptionsSelector = function () {
    var that = this;
    var options = that.options.items.asArray();
    for (var i = 1; i < options.length; i++) {
        that.options.removeOption(1);
    }
    that.oldOption = options[0];
};

PMFormDesigner.prototype.getSubform = function (name) {
    var that = this;
    for (var i = 0; i < that.subForm.length; i++) {
        if (that.subForm[i].name === name) {
            return i;
        }
    }
    return null;
};

PMFormDesigner.prototype.convertDataToSubform = function (data) {
    var i, j, k, rows, cells, cell, subforms;
    rows = data.items[0].items;
    for (i = 0; i < rows.length; i++) {
        cells = rows[i];
        for (j = 0; j < cells.length; j++) {
            cell = cells[j];
            if (cell.type === 'subform') {
                subforms = data.items[0].subForms;
                var items = [];
                for (k = 0; k < subforms.length; k++) {
                    if (subforms[k].name === cell.name) {
                        items = subforms[k].items[0].items;
                    }
                }
                data.items[0].items[i][j].items = items;
            }
        }
    }
    return data;
};
var PMFormCell = function(settings) {
	PMUI.core.Container.call(this, jQuery.extend(settings, {
		elementTag: 'td'
	}));
	this.colSpan = null;
	//this.onAdd = null;
	this.onBeforeColSpanChange = null;
	this.onColSpanChange = null;
	PMFormCell.prototype.init.call(this, settings);
};

PMFormCell.prototype = new PMUI.core.Container();

PMFormCell.prototype.init = function(settings) {
	var defaults = {
		colSpan: 1,
		items: [],
		//onAdd: null,
		onBeforeColSpanChange: null,
		onColSpanChange: null,
		factory :{
			products : {
				"textField" : WrappedTextField,
				"dropDownField" : WrappedDropDownField,
				"checkBoxGroup" : WrappedCheckBoxField,
				"radioButtonGroup": WrappedRadioGroupField,
				"button" : WrappedButton,
				"dateTimeField" : WrappedDateTimerField,
				"textAreaField" : WrappedTextAreaField,
				"label" : WrappedLabelField,
				"submit" : WrappedButton,
				"button" : WrappedButtonSubmit,
				"title" : WrappedTitleField,
				"subtitle" : WrappedSubtitleField,
				"suggest" : WrappedSuggestField,
				"yesnodropdown" : WrappedYesNoDropDownField,
				"yesnoradio" :WrappedYesNoRadioGroupField,
				"grid" : WrappedGridField,
				"file" : WrappedFileField,
				"image" : WrappedImageField,
				"link" : WrappedLinkField,
				"annotation" : WrappedTextLabelField,
				"subform" : WrappedFormField
			}
		}
	};
	
	jQuery.extend(true, defaults, settings);

	this.addCSSClasses(['pmdesigner-formgrid-bodycell']);
	this.setFactory(defaults.factory);
	this.setColSpan(defaults.colSpan)
		.setItems(defaults.items)
		//.setOnAddHandler(defaults.onAdd)
		.setOnBeforeColSpanChange(defaults.onBeforeColSpanChange)
		.setOnColSpanChangeHandler(defaults.onColSpanChange);
};

PMFormCell.prototype.setOnColSpanChangeHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnColSpanChangeHandler(): The parameter must be a function or null.");
	}
	this.onColSpanChange = handler;
	return this;
};

PMFormCell.prototype.setOnBeforeColSpanChange = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnBeforeColSpanChange(): The parameter must be a function or null.");
	}
	this.onBeforeColSpanChange = handler;
	return this;
};

/*PMFormCell.prototype.setOnAddHandler = function(handler) {
	if(!(typeof handler === 'function' || handler === null)) {
		throw new Error("setOnAddHandler(): The parameter must be a function or null.")
	}
	this.onAdd = handler;
	return this;
};*/

PMFormCell.prototype.isAvailable = function() {
	return this.content === null;
};

PMFormCell.prototype.setColSpan = function(colSpan, silent) {
	var customColSpan, prevColSpan = this.colSpan, changed = false;
	silent = silent || false;
	if(typeof colSpan !== 'number' || colSpan < 1) {
		throw new Error("setColSpan(): The parameter must be a number greater than 0.");
	}
	if(this.colSpan !== null && this.colSpan !== colSpan) {
		changed = true;
	}
	if(changed && typeof this.onBeforeColSpanChange === 'function' && !silent) {
		customColSpan = this.onBeforeColSpanChange(this, colSpan, this.colSpan);
		customColSpan = typeof customColSpan !== 'number' & customColSpan > 12 || customColSpan < 1 ? null :  customColSpan;
	}
	this.colSpan = customColSpan || parseInt(colSpan, 10);
	if(this.html) {
		this.html.colSpan = this.colSpan;
	}
	if(changed && typeof this.onColSpanChange === 'function' && !silent) {
		this.onColSpanChange(this, this.colSpan, prevColSpan);
	}
	return this;
};

PMFormCell.prototype.addItem = function(item) {
	if(this.items.getSize()) {
		throw new Error("addItem(): The row has already a content.");
	}
	item.parent = this;
	if (item.field instanceof PMUI.form.Field){
		if(item.field.controls.length && !(item.type == 'submit' || item.type == 'button') ){
			item.field.controls[0].setWidth('100%');
		}	
	}
	if(this.html){
		if(this.html.textContent){
			this.removeCSSClasses(['unique-cell']);
			this.setHeight('auto');
			this.html.textContent = "";
		}
	}
	PMUI.core.Container.prototype.addItem.call(this, item);
	this.setBehavior('drag');
	return this;
};

PMFormCell.prototype.clearItems = function() {
	PMUI.core.Container.prototype.clearItems.call(this);
	this.setBehavior('drop');
	return this;
};

PMFormCell.prototype.removeItem = function(item) {
	PMUI.core.Container.prototype.removeItem.call(this, item);
	if(!this.items.getSize()) {
		this.setBehavior('drop');
	}
	return this;
};

PMFormCell.prototype.getContent = function() {
	return this.items.get(0) || null;
};

PMFormCell.prototype.createHTML = function() {
	if(this.html) {
		return this.html;
	}
	PMUI.core.Container.prototype.createHTML.call(this);
	this.setColSpan(this.colSpan);
	if(this.getContent()){
		if (this.getContent().field.controls !== undefined){
			if (this.getContent().field.controls.length){
				if (!(this.getContent().type == 'submit' || this.getContent().type == 'button')){
					this.getContent().field.controls[0].setWidth('100%');
				}	
			}
		}
	}	
	return this.html;
};
/*
PMFormCell.prototype.setFactory = function (){
    if (factory instanceof PMUI.util.Factory){
        this.factory = factory;
    } else {
        this.factory = new PMUI.util.Factory(factory);
    }
    return this;
};*/
var PMFormRow = function(settings) {
	PMUI.core.Container.call(this, jQuery.extend(true, settings, {
		elementTag: "tr",
		factory: {
            products: {
                "cell": PMFormCell
            },
            defaultProduct: "cell"
        }
	}));
	this.onMouseOver = null;
	this.onMouseOut = null;
	this.onCellDropOut = null;
	this.onCellDrop = null;
	this.onCellAddItem = null;
	this.onCellBeforeColSpanChange = null;
	this.onCellColSpanChange = null;
	PMFormRow.prototype.init.call(this, settings);
};

PMFormRow.prototype = new PMUI.core.Container();

PMFormRow.prototype.init = function(settings) {
	var defaults = {
		onMouseOver: null,
		onMouseOut: null,
		onCellDropOut: null,
		onCellDrop: null,
		onCellAddItem: null,
		onCellColSpanChange: null,
		onCellBeforeColSpanChange: null
	};

	jQuery.extend(true, defaults, settings);

	this.setOnMouseOverHandler(defaults.onMouseOver)
		.setOnMouseOutHandler(defaults.onMouseOut)
		.setOnCellDropHandler(defaults.onCellDrop)
		.setOnCellDropOutHandler(defaults.onCellDropOut)
		.setOnCellAddItemHandler(defaults.onCellAddItem)
		.setOnCellColSpanChangeHandler(defaults.onCellColSpanChange)
		.setOnCellBeforeColSpanChangeHandler(defaults.onCellBeforeColSpanChange);
};

PMFormRow.prototype.onMouserOutHandler = function() {
	var that = this;
	return function() {
		if(typeof that.onMouseOut === 'function') {
			that.onMouseOut(that);
		}
	};
};

PMFormRow.prototype.onMouseOverHandler = function () {
	var that = this;
	return function() {
		if(typeof that.onMouseOver === 'function') {
			that.onMouseOver(that);
		}
	};
};

PMFormRow.prototype.setOnMouseOutHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("The parameter must be a function or null.");
	}
	this.onMouseOut = handler;
	return this;
};

PMFormRow.prototype.setOnMouseOverHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("The parameter must be a function or null.");
	}
	this.onMouseOver = handler;
	return this;
};

PMFormRow.prototype.onCellDropHandler = function() {
	var that = this;
	return function(cell, item, index) {
		var res;
		if(typeof that.onCellDrop === 'function') {
			res = that.onCellDrop(cell, item, index);
		}
		return res;
	};
};

PMFormRow.prototype.setOnCellDropOutHandler = function (handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnCellDropOutHandler(): The parameter must be a function or null.");
	}
	this.onCellDropOut = handler;
	return this;
};

PMFormRow.prototype.onCellDropOutHandler = function() {
	var that = this;
	return function(item, origin, destiny) {
		if(typeof that.onCellDropOut === 'function') {
			that.onCellDropOut(that, item, origin, destiny);
		}
	};
};

PMFormRow.prototype.onCellBeforeColSpanChangeHandler = function(handler) {
	var that = this;
	return function(cell, newColSpan, oldColSpan) {
		if(typeof that.onCellBeforeColSpanChange === 'function') {
			return that.onCellBeforeColSpanChange(that, cell, newColSpan, oldColSpan);
		}
	};
};

PMFormRow.prototype.setOnCellBeforeColSpanChangeHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnCellBeforeColSpanChangeHandler(): The parameter must be a function or null.");
	}
	this.onCellBeforeColSpanChange = handler;
	return this;
};

PMFormRow.prototype.setOnCellColSpanChangeHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnCellColSpanChangeHandler(): The parameter must be a function or null.");
	}
	this.onCellColSpanChange = handler;
	return this;
};

PMFormRow.prototype.onCellColSpanChangeHandler = function() {
	var that = this;
	return function(cell, newSpan, oldSpan) {
		if(typeof that.onCellColSpanChange === 'function') {
			that.onCellColSpanChange(that, cell, newSpan, oldSpan);
		}
	};
};

PMFormRow.prototype.onCellAddItemHandler = function() {
	var that = this;
	return function(cell, item) {
		if(typeof that.onCellAddItem === 'function') {
			that.onCellAddItem(that, cell, item);
		}
	};
};

PMFormRow.prototype.setOnCellAddItemHandler = function(handler) {
	var i, cells = this.items.asArray();
	if(!(typeof handler === 'function' || handler === null)) {
		throw new Error("onCellAddItem(): The parameter must be a function or null.");
	}
	this.onCellAddItem = handler;
	for(i = 0; i < cells.length; i++) {
		cells[i].setOnAddHandler(this.onCellAddItemHandler());
	}
	return this;
};

PMFormRow.prototype.setOnCellDropHandler = function(handler) {
	var i, cells = this.items.asArray();
	if(!(typeof handler === 'function' || handler === null)) {
		throw new Error("The parameter must be a function or null.");
	}
	this.onCellDrop = handler;
	return this;
};

PMFormRow.prototype.addItem = function(item) {
	if(item instanceof PMFormCell) {
		item.setOnDropHandler(this.onCellDropHandler());
		item.setOnColSpanChange(this.onCellColSpanChangeHandler());
		item.setOnBeforeColSpanChange(this.onCellBeforeColSpanChangeHandler());
		item.setOnAddHandler(this.onCellAddItemHandler());
		item.setOnDropOutHandler(this.onCellDropOut());
	} else if(typeof item === 'object') {
		item.onDrop = this.onCellDropHandler();
		item.onColSpanChange = this.onCellColSpanChangeHandler();
		item.onBeforeColSpanChange = this.onCellBeforeColSpanChangeHandler();
		item.onAdd = this.onCellAddItemHandler();
		item.onDropOut = this.onCellDropOutHandler();
	}
	return PMUI.core.Container.prototype.addItem.call(this, item);
};

PMFormRow.prototype.getCellItems = function() {
	var cells = this.getItems(), items = [], i;
	for(i = 0; i < cells.length; i++) {
		items = items.concat(cells[i].getItems());
	}
	return items;
};

PMFormRow.prototype.defineEvents = function() {
	var that;
	if(!this.eventsDefined) {
		that = this;
		PMUI.core.Container.prototype.defineEvents.call(this);
		this.addEvent('mouseover').listen(this.html, that.onMouseOverHandler());
		this.addEvent('mouseout').listen(this.html, that.onMouserOutHandler());
	}
	return this;
};
var PMFormGrid = function(settings) {
	PMUI.core.Container.call(this, jQuery.extend(settings, {
		dragHandler: '.pmdesigner-rowhandler',
		behavior: "sort",
		sortableItems: 'tbody',
		elementTag: 'div',
		factory: {
			products: {
				'row': PMFormRow
			},
			defaultProduct: 'row'
		}
	}));
	this.cols = 0;
	this.rows = null;
	this.dom = {};
	this.onAddCell = null;
	this.onCellAddItem = null;
	this.onCellColSpanChange = null;
	this.onCellBeforeColSpanChange = null;
	this.onCellDropOut = null;
	this.handlerBlocked = false;
	this.selectedRow = null;
	this.onStartSortRow = null;
	//this.onClickHeader = null;
	this.formName = null;
	this.idForm = null;
	this.mode = null;
	this.buttonClear = null;
	this.formPropertiesButton = null;
	this.properties = [
		"formName",
		"formId",
		"formMode",
		"scripts"
		//"method"
	];
	this.onMouseOver = null;
	this.onMouseOut = null;
	this.script = null;
	PMFormGrid.prototype.init.call(this, settings);
};

PMFormGrid.prototype =  new PMUI.core.Container();

PMFormGrid.prototype.type = "PMFormGrid";

PMFormGrid.prototype.init = function(settings) {
	var defaults = {
		cols: 12,
		items: [],
		onCellDropOut: null,
		onCellAddItem: null,
		onCellColSpanChange: null,
		onCellBeforeColSpanChange: null,
		onAddCell: null,
		onStartSortRow : null,
		//onClickHeader : null,
		formName : "PMDynaform",
		formId : "PMForm"+PMUI.generateUniqueId(),
		formMode : 'edit',
		textButtonClear : '[clear Form]',
		textButtonFormProperties : '[Properties Form]',
		onMouseOver : null,
		onMouseOut : null,
		script : ""
		//method : 'post'
	};

	jQuery.extend(true, defaults, settings);
	this.rows = new PMUI.util.ArrayList();

	this.buttonClear = new PMUI.ui.Button({
		buttonType : 'link',
		style : {
			cssProperties : {
				float : 'right'
			},
			cssClasses : ['pmformGrid-buttonclear']
		}
	});

	this.formPropertiesButton = new PMUI.ui.Button({
		buttonType : 'link',
		style : {
			cssClasses : ['pmformGrid-formPropertiesButton']
		}
	});

	this.setCols(defaults.cols)
		.setItems(defaults.items)
		.setOnCellDropOutHander(defaults.onCellDropOut)
		.setOnStartSortRow(defaults.onStartSortRow)
		.setOnCellAddItem(defaults.onCellAddItem)
		.setOnCellColSpanChangeHandler(defaults.onCellColSpanChange)
		.setOnCellBeforeColSpanChange(defaults.onCellBeforeColSpanChange)
		.setOnAddCellHandler(defaults.onAddCell)
		.setItems(defaults.items);
		this.setFormName(defaults.formName);
		this.setFormMode(defaults.formMode);
		this.setFormId(defaults.formId);
		this.setOnMouseOverHandler(defaults.onMouseOver);
		this.setOnMouseOutHandler(defaults.onMouseOut);
		this.setScript(defaults.script);
	//this.setOnClickHeaderHandler(defaults.onClickHeader);
	this.setTextButtonClear(defaults.textButtonClear);
	this.setTextButtonFormProperties(defaults.textButtonFormProperties);
};

PMFormGrid.prototype.setScript = function (script) {
	if (typeof script === "string") {
		this.script = script;
		return this;
	}
	throw new Error("setScript(): the value is not valid");
};

PMFormGrid.prototype.getScript = function (script) {
	return this.script;
};

PMFormGrid.prototype.onMouserOutHandler = function() {
	var that = this;
	return function() {
		if(typeof that.onMouseOut === 'function') {
			that.onMouseOut(that);
		}
	};
};

PMFormGrid.prototype.setOnMouseOutHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("The parameter must be a function or null.");
	}
	this.onMouseOut = handler;
	return this;
};

PMFormGrid.prototype.onMouseOverHandler = function () {
	var that = this;
	return function() {
		if(typeof that.onMouseOver === 'function') {
			that.onMouseOver(that);
		}
	};
};

PMFormGrid.prototype.setOnMouseOverHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("The parameter must be a function or null.");
	}
	this.onMouseOver = handler;
	return this;
};


PMFormGrid.prototype.setTextButtonFormProperties = function (text){
	this.formPropertiesButton.setText(text);
	return this;
};

PMFormGrid.prototype.setTextButtonClear = function(text){
	this.buttonClear.setText(text);
	return this;
};

PMFormGrid.prototype.hasItems = function() {
	if (this.getCellItems.length){
		return true;
	}else{
		return false;
	}
};
PMFormGrid.prototype.setMessageHelp = function(help){
    if (!(this.getItems()[0].getItems()[0].getContent()) && this.getItems()[0].getItems()[0].html){ 
        this.getItems()[0].getItems()[0].html.textContent="drag a variable and choose a control!";    
        this.getItems()[0].getItems()[0].addCSSClasses(['unique-cell']);
        this.getItems()[0].getItems()[0].setHeight('5em');
    }
    return this;
};

PMFormGrid.prototype.removeMessageHelp = function(help){
    if (!(this.getItems()[0].getItems()[0].getContent()) && this.getItems()[0].getItems()[0].html){ 
        this.getItems()[0].getItems()[0].html.textContent="";
        this.getItems()[0].getItems()[0].removeCSSClasses(['unique-cell']);
        this.getItems()[0].getItems()[0].setHeight('auto');     
    }
    return this;
};

PMFormGrid.prototype.setFormName = function (name) {
	this.formName = name;
	return this;
};

PMFormGrid.prototype.getFormName = function (){
	return this.formName;
};

PMFormGrid.prototype.setFormMode = function (mode){
	this.formMode = mode;
	return this;
};

PMFormGrid.prototype.getFormMode = function (){
	return this.formMode;
};

PMFormGrid.prototype.setFormId = function (formId) {
	this.formId = formId;
	return this;
};

PMFormGrid.prototype.getFormId = function (){
	return this.formId;
};

/*PMFormGrid.prototype.setOnClickHeaderHandler = function (handler){
	if (!(typeof handler === 'function' || handler === null)){
		throw new Error("setOnClickHeaderHandler(): The parameter must be a function or null.");
	}
	this.onClickHeader = handler;
	return this;	
};*/

/*PMFormGrid.prototype.onClickHeaderHandler = function(){
	var that = this; 
	return this;
}*/
PMFormGrid.prototype.setOnStartSortRow = function(handler) {
	if (!(typeof handler === 'function' || handler === null)){
		throw new Error("setOnStarSortRow(): The parameter must be a function or null.");
	}
	this.onStartSortRow = handler;
	return this;
};

PMFormGrid.prototype.onStartSortRowHandler = function (){
	var that = this;
	return function(row, item, origin, destiny) {
		if(typeof that.onSortStart === 'function') {
			that.onSortStart(that, row, item, origin, destiny);
		}
	};
};

PMFormGrid.prototype.onRowMouseOverHandler = function() {
	var that = this;
	return function(row) {
		var firstCell;
		if(that.selectedRow){
			that.selectedRow.removeCSSClasses(['my_row']);
			/*for(var i=0; i<that.selectedRow.items.getSize();i+=1){
				that.selectedRow.getItem(i).html.style.paddingLeft = 'initial';	
			}*/
		}
		if(!that.handlerBlocked) {
			firstCell = row.getItem(0);
			that.dom.rowHandler.style.height = jQuery(firstCell.getHTML()).height() + "px";
			firstCell.getHTML().appendChild(that.dom.rowHandler);
			/*for(var i=0; i < row.items.getSize();i+=1){
				row.getItem(i).html.style.paddingLeft = '3px';	
			}*/
			that.handlerBlocked = true;
		}
		row.addCSSClasses(['my_row']);
		that.selectedRow = row;	
	};
};

PMFormGrid.prototype.onRowMouseOutHandler = function() {
	var that = this;
	return function(row) {
		that.handlerBlocked = false;
	};
};

PMFormGrid.prototype.setItems = function(items) {
	if(this.cols !== undefined) {
		PMUI.core.Container.prototype.setItems.call(items);
	}
	return this;
};

PMFormGrid.prototype.setOnCellDropOutHander = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnCellDropOutHander(): The parameter must be a function or null.");
	}
	this.onCellDropOut = handler;
	return this;
};

PMFormGrid.prototype.onCellDropOutHander = function() {
	var that = this;
	return function(row, item, origin, destiny) {
		if(typeof that.onCellDropOut === 'function') {
			that.onCellDropOut(that, row, item, origin, destiny);
		}
	};
};

PMFormGrid.prototype.setOnAddCellHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnAddCellHandler(): The parameter must be a function or null.");
	}
	this.onAddCell = handler;

	return this;
};

PMFormGrid.prototype.onAddCellHandler = function() {
	var that = this;
	return function(row, cell, index) {
		if(typeof that.onAddCell === 'function') {
			that.onAddCell(that, row, cell, index);
		}
	};
};

PMFormGrid.prototype.setOnCellBeforeColSpanChange = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnCellBeforeColSpanChange(): The parameter must be a function or null.");
	}
	this.onCellBeforeColSpanChange = handler;
	return this;
};

PMFormGrid.prototype.onCellBeforeColSpanChangeHandler = function() {
	var that = this;
	return function(row, cell, newSpan, oldSpan) {
		if(typeof that.onCellBeforeColSpanChange === 'function') {
			return that.onCellBeforeColSpanChange(that, row, cell, newSpan, oldSpan);
		}
	};
};

PMFormGrid.prototype.onCellColSpanChangeHandler = function() {
	var that = this;
	return function(row, cell, newSpan, oldSpan) {
		if(typeof that.onCellColSpanChange === 'function') {
			that.onCellColSpanChange(that, row, cell, newSpan, oldSpan);
		}
	};
};

PMFormGrid.prototype.setOnCellColSpanChangeHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnCellColSpanChangeHandler(): the parameter must be a function or null.");
	}
	this.onCellColSpanChange = handler;
	return this;
};

PMFormGrid.prototype.setOnCellAddItem = function(handler) {
	this.onCellAddItem = handler;
	return this;
};

PMFormGrid.prototype.setItems = function(items) {
	if(typeof this.cols === 'number' && this.cols > 0) {
		PMUI.core.Container.prototype.setItems.call(this, items);
	}
	return this;
};

PMFormGrid.prototype.removeCol = function(index) {
	var i, rows = this.items.asArray();
	for(i = 0; i < rows.length; i++) {
		rows[i].removeItem(index);
	}
	this.cols -= 1;
	return this;
};

PMFormGrid.prototype.clearCols = function() {
	while(this.cols) {
		this.removeCol(0);
	}
	return this;
};

PMFormGrid.prototype.addCol = function() {
	var i, rows = this.items.asArray(), remainingCols;

	for(i = 0; i < rows.length; i++) {
		remainingCols = this.cols + 1 - rows[i].getItems().length;
		rows[i].addItem({
			colSpan: remainingCols
		});
	}

	this.cols += 1;

	return this;
};

PMFormGrid.prototype.onAddItemInCellHandler = function() {
	var that = this;
	return function(row, cell, item) {
		if(typeof that.onCellAddItem === 'function') {
			that.onCellAddItem(that, row, cell, item);
		}
	};
};

PMFormGrid.prototype.addItem = function(item, index) {
	if(item === undefined || (!(item instanceof PMFormRow) && typeof item === 'object')) {
		item = jQuery.extend(true, {
			items: [{
				colSpan: this.cols
			}],
			style: {
				cssClasses: ['pmdesigner-formgrid-bodyrow']
			},
			height: '2em',
			//onCellDropOut: this.onCellDropOutHander(),
			onMouseOver: this.onRowMouseOverHandler(),
			onMouseOut: this.onRowMouseOutHandler(),
			onCellAddItem: this.onAddItemInCellHandler(),
			onCellDropOut: this.onCellDropOutHander(),
			onCellColSpanChange: this.onCellColSpanChangeHandler(),
			onCellBeforeColSpanChange: this.onCellBeforeColSpanChangeHandler(),
			onAdd: this.onAddCellHandler(),
			onStartSort : this.onStartSortRowHandler()
		}, item || {});
	}
	return PMUI.core.Container.prototype.addItem.call(this, item, index);
};

PMFormGrid.prototype.setCols = function(cols) {
	var i;
	if(!(typeof cols === 'number' && cols > 0)) {
		throw new Error("setCols(): Both parameters must be a number greater than 0.");
	}
	jQuery(this.dom.tbody).empty();
	this.clearCols();
	for(i = 0; i < cols; i++) {
		this.addCol();
	}
	return this;
};

PMFormGrid.prototype.getCellItems = function() {
	var items = [], rows = this.getItems(), i;
	for(i = 0; i < rows.length; i++) {
		items = items.concat(rows[i].getCellItems());
	}
	return items;
};

PMFormGrid.prototype.createHTML = function() {
	var textMessageContent, tbody, thead, tr, th, i, handler, table, tableContainer;
	if(this.html) {
		return this.html;
	}
	PMUI.core.Element.prototype.createHTML.call(this);
	textMessageContent = PMUI.createHTMLElement('span');
	textMessageContent.className = "pmdesigner-textMessageContent";

	table = PMUI.createHTMLElement("table");
	table.className = "pmdesigner-formgrid";

	handler = PMUI.createHTMLElement("div");
	handler.className = 'pmdesigner-rowhandler';
	thead = PMUI.createHTMLElement("thead");
	thead.className = 'pmdesigner-formgrid-head';
	tr = PMUI.createHTMLElement("tr");
	tr.className = 'pmdesigner-formgrid-headrow';
	th = PMUI.createHTMLElement("th");
	th.className = 'pmdesigner-formgrid-headcell';
	tableContainer = PMUI.createHTMLElement('div');
	tableContainer.className = "pmdesigner-formgrid-tableContainer";
	thead.appendChild(tr);
	for(i = 0; i < 12; i++) {
		tr.appendChild(th.cloneNode(false));
	}
	thead.appendChild(tr);
	this.dom.textMessageContent = textMessageContent;
	this.dom.table = table;
	this.dom.thead = thead;
	this.dom.tableContainer = tableContainer;

	this.dom.tbody = tbody = PMUI.createHTMLElement("tbody");
	this.dom.rowHandler = handler;
	this.dom.table.appendChild(thead);
	this.dom.table.appendChild(tbody);
	this.dom.tableContainer.appendChild(table);
        this.dom.pmHiddenFieldsPanel = new PMHiddenFieldsPanel();

	//this.html.appendChild(thead);
	//this.html.appendChild(tbody);
	this.containmentArea = tbody;
	//this.addCSSClasses(['pmdesigner-formgrid']);

	this.paintItems();
	if(this.hasItems()){
		this.removeMessageHelp();
	}else{
		this.setMessageHelp();
	} 
	//this.setMessageHelp();
	this.html.appendChild(this.dom.textMessageContent);
	this.html.appendChild(this.buttonClear.createHTML());
	this.html.appendChild(this.formPropertiesButton.getHTML());
	this.html.appendChild(this.dom.tableContainer);
        this.html.appendChild(this.dom.pmHiddenFieldsPanel.getHTML());
        this.dom.pmHiddenFieldsPanel.sizeAjust();
	return this.html;
};

PMFormGrid.prototype.defineEvents = function(){
	var that = this;
	PMUI.core.Container.prototype.defineEvents.call(this);
	this.buttonClear.defineEvents();
	this.formPropertiesButton.defineEvents();
	this.addEvent('mouseover').listen(this.html, that.onMouseOverHandler());
	this.addEvent('mouseout').listen(this.html, that.onMouserOutHandler());
	return this; 
};

PMHiddenFieldsPanel = function () {
    this.html = PMUI.createHTMLElement('div');
    PMHiddenFieldsPanel.prototype.init.call(this);
    this.itemDropped = null;
    this.selectedElement = null;
    this.onSelected = new Function();
};

PMHiddenFieldsPanel.prototype.init = function () {
    var that = this;
    this.html.className = 'pmui-containeritembehavior-sort mafe-hidden-fields-panel';
    $(this.html).sortable({
        placeholder: 'pmui-containeritembehavior-placeholder',
        activate: function (event, ui) {
            var sw = PMUI.getPMUIObject(ui.item[0]) && PMUI.getPMUIObject(ui.item[0]).variable;
            that.itemDropped = sw ? PMUI.getPMUIObject(ui.item[0]).variable : null;
        },
        update: function (event, ui) {
            if (ui.item[0].nodeName === 'LI') {
                that.html.removeChild(ui.item[0]);
                if (that.itemDropped !== null) {
                    that.createItem(that.itemDropped);
                }
            }
        }
    });
    this.menu = new PMUI.menu.Menu({
        items: [{
                text: 'Remove',
                onClick: function (menuOption) {
                    that.html.removeChild(that.selectedElement);
                }
            }
        ]
    });
};

PMHiddenFieldsPanel.prototype.getHTML = function () {
    return this.html;
};

PMHiddenFieldsPanel.prototype.sizeAjust = function () {
    this.html.previousSibling.style.height = '85%';
};

PMHiddenFieldsPanel.prototype.getItems = function () {
    var a = this.html.childNodes;
    var items = [];
    var variable = null;
    for (var i = 0; i < a.length; i++) {
        variable = a[i].itemDropped;
        items.push({
            "variable": variable.name,
            "variable_uid": variable.uid,
            "dataType": variable.fieldType,
            "name": variable.name,
            "id": variable.name,
            "defaultValue": "",
            "type": "hidden"
        });
    }
    return items;
};

PMHiddenFieldsPanel.prototype.removeItem = function (item) {

};

PMHiddenFieldsPanel.prototype.createItem = function (variable) {
    var that = this;
    var el = $("<div><div class='mafe-hidden-fields-panel-name'>" + variable.name + "</div><div class='mafe-hidden-fields-panel-label'>hidden " + that.html.childNodes.length + "</div></div>");
    $(that.html).append(el);
    el[0].itemDropped = variable;
    $(el[0]).on('mousedown', function (event) {
        $('.mafe-hidden-fields-panel-label-isSelected').removeClass('mafe-hidden-fields-panel-label-isSelected');
        $(this).addClass('mafe-hidden-fields-panel-label-isSelected');
        that.onSelected(event, el[0], variable);
        that.selectedElement = el[0];
    });
    el[0].addEventListener('contextmenu', function (e) {
        e.preventDefault();
        that.menu.show(e.pageX, e.pageY);
        that.menu.setZOrder(200);
    }, false);
};

PMHiddenFieldsPanel.prototype.clearItems = function () {
    this.html.innerHTML = '';
};
var PMVariable = function (options) {
    this.acceptedValues = null;
    this.dbConnection = null;
    this.defaultValue = null;
    this.fieldSize = null;
    this.fieldType = null;
    this.label = null;
    this.name = null;
    this.allowNull = null;
    this.sql = null;
    this.uid = null;
    PMVariable.prototype.init.call(this, options);
};

PMVariable.prototype.TYPES = {
    "string": ["text", "textarea", "dropdown", "checkbox", "radio", "datetime", "label", "suggest"],
    "integer": ["text", "dropdown", "checkbox", "radio", "label" ],
    "float": ["text", "dropdown", "checkbox", "radio", "label"],
    "boolean": ["yesnodropdown", "yesnoradio"],
    "date": ["datetime", "label"],
    "datetime": ["datetime", "label"]
};

PMVariable.prototype.init = function (options) {
    var defaults = {
        acceptedValues: [],
        dbConnection: "",
        defaultValue: "",
        fieldSize: 0,
        fieldType: "string",
        label: "",
        name: "",
        allowNull: 1,
        sql: "",
        uid: ""
    };
    jQuery.extend(true, defaults, options);
    this.setAcceptedValues(defaults.acceptedValues);
    this.setDBConnection(defaults.dbConnection);
    this.setDefaultValue(defaults.defaultValue);
    this.setFieldSize(defaults.fieldSize);
    this.setFieldType(defaults.fieldType);
    this.setLabel(defaults.label);
    this.setName(defaults.name);
    this.setAllowNull(defaults.allowNull);
    this.setSql(defaults.sql);
    this.setUID(defaults.uid);
};

PMVariable.prototype.setAcceptedValues = function (acceptedValues) {
    if (!jQuery.isArray(acceptedValues)) {
        try {
            acceptedValues = JSON.parse(acceptedValues);
            this.acceptedValues = acceptedValues;
            } catch(e) {
                throw new Error("setAcceptedValues(): The parameter must be a array.");
            }
    } else {
        this.acceptedValues = acceptedValues;        
    }
    return this;
};

PMVariable.prototype.getAcceptedValues = function () {
    return this.acceptedValues;
};

PMVariable.prototype.setDBConnection = function (dbConnection) {
    if (!(typeof dbConnection === "string")) {
        throw new Error("setDBConnection(): The parameter must be a string.");
    }
    this.dbConnection = dbConnection;
    return this;
};

PMVariable.prototype.getDBConnection = function () {
    return this.dbConnection;
};

PMVariable.prototype.setDefaultValue = function (defaultValue) {
    if (!(typeof defaultValue === "string")) {
        throw new Error("setDefaultValue(): The parameter must be a string.");
    }
    this.defaultValue = defaultValue;
    return this;
};

PMVariable.prototype.getDefaultValue = function () {
    return this.defaultValue;
};

PMVariable.prototype.setFieldSize = function (fieldSize) {
    if (!(typeof fieldSize === "number")) {
        throw new Error("setFieldSize(): The parameter must be a number.");
    }
    this.fieldSize = fieldSize;
    return this;
};

PMVariable.prototype.getFieldSize = function () {
    return this.fieldSize;
};

PMVariable.prototype.setFieldType = function (fieldType) {
    if (!(typeof fieldType === "string")) {
        throw new Error("setFieldType(): The parameter must be a string.");
    }
    this.fieldType = fieldType;
    return this;
};

PMVariable.prototype.getFieldType = function () {
    return this.fieldType;
};

PMVariable.prototype.setLabel = function (label) {
    if (!(typeof label === "string")) {
        throw new Error("setLabel(): The parameter must be a string.");
    }
    this.label = label;
    return this;
};

PMVariable.prototype.getLabel = function () {
    return this.label;
};

PMVariable.prototype.setName = function (name) {
    if (!(typeof name === "string")) {
        throw new Error("setName(): The parameter must be a string.");
    }
    this.name = name;
    return this;
};

PMVariable.prototype.getName = function () {
    return this.name;
};

PMVariable.prototype.setAllowNull = function (allowNull) {
    if (!(typeof allowNull === "number")) {
        throw new Error("setAllowNull(): The parameter must be a number.");
    }
    this.allowNull = allowNull;
    return this;
};

PMVariable.prototype.getAllowNull = function () {
    return this.allowNull;
};

PMVariable.prototype.setSql = function (sql) {
    if (!(typeof sql === "string")) {
        throw new Error("setSql(): The parameter must be a string.");
    }
    this.sql = sql;
    return this;
};

PMVariable.prototype.getSql = function () {
    return this.sql;
};

PMVariable.prototype.setUID = function (uid) {
    if (!(typeof uid === "string")) {
        throw new Error("setUID(): The parameter must be a string.");
    }
    this.uid = uid;
    return this;
};

PMVariable.prototype.getUID = function () {
    return this.uid;
};

PMVariable.prototype.getSupportedControls = function(type) {
    type = type || this.fieldType;
    if(this.acceptedValues.length && type !== "boolean"){
        return this.TYPES[type].filter(function(x){
            if(x=="checkbox" || x == "radio" || x == "dropdown" || x==="suggest"){
                return x;
            }
        });        
    }
    return this.TYPES[type];
};
var GridFieldItem = function (settings){
    PMUI.core.Element.call(this, settings);
    this.mode = null;
    this.name = null;
    this.defaultValue = null;
    this.mask = null;
    this.dataType = null;
    this.variable = null;
    this.title = null;
    this.required = null;
    this.width = null;
    this.gridItem = null;
    this.html = null;
    this.parent = null;
    this.hiddenControl = null;
    this.onClickConfigField = null;
    this.dom = {};
    this.width = null;
    this.dependentColumns = null;
    this.directDependence = null;
    GridFieldItem.prototype.init.call(this, settings);
};

GridFieldItem.prototype = new PMUI.core.Element();

GridFieldItem.prototype.init = function(settings){
    var defaults = {
        mode : "edit",
        name : "",
        defaultValue : "",
        mask : "",
        dataType : "string",
        variable : null,
        title : "[untitle]",
        required : false,
        width : 100,
        controlType : 'text',
        onClickConfigField : null,
        hiddenControl : false,
        required : false,
        directDependence : [],
        dependentColumns : []
    }
    this.dependentColumns = [];
    this.directDependence = [];
    jQuery.extend(true, defaults, settings);
    this.setControlType(defaults.controlType);
    this.setMode(defaults.mode);
    this.setName(defaults.name);
    this.setDefaultValue(defaults.defaultValue);
    this.setMask(defaults.mask);
    this.setDataType(defaults.dataType);
    this.setVariable(defaults.variable);
    this.setTitle(defaults.title);
    this.setRequired(defaults.required);
    this.setWidth(defaults.width);
    this.setOnClickConfigFieldHandler(defaults.onClickConfigField);
    this.setHiddedField(defaults.hiddenControl);
    this.setDependentColumns(defaults.dependentColumns);
    this.setDirectDependence(defaults.directDependence);
};

GridFieldItem.prototype.setControlType = function (controlType){
    if ( typeof controlType === "string" )            
    switch (controlType){
        case 'text' :
            this.gridItem = new PMUI.field.TextField(); 
            break;
        case 'textarea' :
            this.gridItem = new PMUI.field.TextAreaField();
            break;
        case 'dropdown' :
            this.gridItem = new PMUI.field.DropDownListField();
            break;
        case 'radio' :
            this.gridItem = new PMUI.field.RadioButtonGroupField({
                controlPositioning: 'horizontal',
                maxDirectionOptions: 1
            });
            break;
        case 'checkbox' : 
            this.gridItem = new PMUI.field.CheckBoxGroupField({
                controlPositioning: 'horizontal',
                maxDirectionOptions: 1
            });
            break;
        case 'suggest' :
            this.gridItem = new PMSuggestField();
            break;
        case 'datetime' :
            this.gridItem = new PMUI.field.DateTimeField();
            break;
        case 'button' : 
            this.gridItem = new PMUI.field.ButtonField();
            break;
        case 'link' : 
            this.gridItem = new PMLinkField();
            break;
        case 'image' : 
            this.gridItem = new PMImageField();
            break;
    }
    if(this.gridItem){
        this.gridItem.addCSSClasses(['GridFieldItem']);
        this.gridItem.addCSSClasses(['GridFieldItem-'+this.type]); 
        this.gridItem.setLabelPosition('top');
        this.gridItem.setHeight(this.height);
    }
    return this;
};

GridFieldItem.prototype.setMode  = function ( mode ){
    if ( typeof mode === "string" ) {
        this.mode = mode;
    }
    return this;
};

GridFieldItem.prototype.getMode  = function (){
    return this.mode;
};

GridFieldItem.prototype.setName = function ( name ){
    if ( typeof name === "string" ) {
        if ( this.gridItem) {
            this.gridItem.setName(name);
        }
        this.name = name;
    }
    return this;
};

GridFieldItem.prototype.getName = function (){
    return this.name;
};

GridFieldItem.prototype.setDataType = function (dataType){
    this.dataType = dataType;
    return this;
};

GridFieldItem.prototype.getDataType = function (){
    return this.dataType;
};

GridFieldItem.prototype.setDefaultValue = function (defaultValue){
    if(this.gridItem){
        this.gridItem.setValue(defaultValue);
    }
    this.defaultValue = defaultValue;
    return this;
};

GridFieldItem.prototype.getDefaultValue = function (){
    return this.defaultValue; 
};

GridFieldItem.prototype.setMask = function (mask){
    if( typeof mask === "string") {
        this.mask = mask;
    }
    return this;
};

GridFieldItem.prototype.getMask = function (){
    return this.mask;
};

GridFieldItem.prototype.setVariable = function (variable){
    if ( typeof variable === "string") {
        this.variable = variable;
    }
    return this;
};

GridFieldItem.prototype.getVariable = function (){
    return this.variable;
};

GridFieldItem.prototype.setTitle = function (title){
    if ( typeof title === "string" ) {
        if ( this.gridItem) {
            this.gridItem.setLabel(title);
        }
        this.title = title;
    }
    return this;
};

GridFieldItem.prototype.getTitle = function (){
    return  this.title;
};

GridFieldItem.prototype.setRequired = function (value){
    if ( typeof value === "boolean" ) {
        if (this.gridItem) {
            this.gridItem.setRequired(value);
        }
        this.required = value;
    }
    return this;
};

GridFieldItem.prototype.getRequired = function (){
    return this.required;
};

GridFieldItem.prototype.setWidth = function (width){
    width = !(isNaN(parseInt(width)))? parseInt(width) : 100; 
    if (typeof width === "number") {
        if (this.parent){
            if (this.parent.parent){
                if(this.parent.parent.html){
                    auxWidth = jQuery(this.parent.parent.dom.list).outerWidth() - parseInt(this.width) + width + 'px';
                    this.parent.parent.dom.list.style.width = auxWidth; 
                }
            }
        }
        if ( this.gridItem ) {
            this.gridItem.setWidth(width);
            if (this.gridItem.controls.length){
                this.gridItem.controls[0].setWidth(width);
                jQuery(this.dom.labelTextContainer).css('width' , '80%');
                jQuery(this.dom.controlContainer).css('width' , '100%');
                jQuery(this.gridItem.dom.controlContainer).css('width' , '100%');
                if( !(this.gridItem.type === "CheckBoxGroupField" || this.gridItem.type === "RadioButtonGroupField" )){
                    this.gridItem.controls[0].setWidth('100%');                
                }   
            }
        }
        this.width = width;
    }
    return this;
};

GridFieldItem.prototype.getWidth = function (){
    return this.width;
};

GridFieldItem.prototype.createHTML  = function(){
    var icon, html, configFieldIcon, fieldIcon, iconControl, iconControl2, header, cloneControl;
    if(!this.html) {
        this.html = this.gridItem.getHTML();
        this.dom = this.gridItem.dom;

        PMUI.linkToPMUIObject(this.html, this);
        /*create container header*/
        header = PMUI.createHTMLElement('div');
        header.className = "gridfielditem-header";
        /*create content icon*/
        configFieldIcon = PMUI.createHTMLElement('i');
        configFieldIcon.className = "GridFieldItem-configFieldIcon";
        
        /*append icon and label in header*/
        header.appendChild(this.dom.labelTextContainer);
        header.appendChild(configFieldIcon);
        /*icon field*/
        fieldIcon = PMUI.createHTMLElement('i');
        fieldIcon.className = "icon-field";
        jQuery(this.html).prepend(header);

        this.dom.labelTextContainer.appendChild(fieldIcon);
        jQuery(this.dom.fieldColon).remove();
        jQuery(this.dom.messageContainer).remove();
        jQuery(this.gridItem.helper.html).remove();
        jQuery(this.dom.labelTextContainer).css('width' , '80%');
        jQuery(this.dom.controlContainer).css('width' , '100%');
        jQuery(this.dom.labelTextContainer).css('display','inline-block');

        if( !(this.gridItem.type === "CheckBoxGroupField" || this.gridItem.type === "RadioButtonGroupField" )){
            if (this.gridItem.controls.length){
                this.gridItem.controls[0].setWidth('100%');
                this.gridItem.controls[0].setHeight(20);
                cloneControl = this.gridItem.controls[0].getHTML().cloneNode(false);
                cloneControl.style.marginTop = '2px';
                this.dom.controlContainer.appendChild(cloneControl);
            }
        }
        this.gridItem.setHeight('100%');
        this.dom.configFieldIcon = configFieldIcon;
        this.applyStyle();
    }
    return this.html;
};

GridFieldItem.prototype.setParent = function (parent) {
    if(parent) {
        this.parent = parent;
    }
    return this;
};

GridFieldItem.prototype.setParent = function (parent) {
    return this.parent;
};

GridFieldItem.prototype.defineEvents = function () {
    var that = this;
    PMUI.core.Element.prototype.defineEvents.call(this);
    if (this.html){
        this.gridItem.defineEvents();
        this.addEvent('click').listen(this.dom.configFieldIcon, function(e){
            if (typeof that.onClickConfigField === 'function' ) {
                if (that.parent){
                    that.onClickConfigField(that, that.parent);
                } else {
                    that.onClickConfigField(that);
                }
            }
            e.stopPropagation();
            e.preventDefault();
        });        
    }
    return this;
};


GridFieldItem.prototype.setOnClickConfigFieldHandler = function (handler) {
    if ( ! (handler === null || typeof handler === 'function')) {
        throw new Error("GridFieldItem.setOnClickConfigField(): handler should be a function type");
    }
    this.onClickConfigField = handler;
    return this;
};

/*GridFieldItem.prototype.onClickConfigFieldHandler = function (){
    var that = this;
    return function (){

    };
};*/

GridFieldItem.prototype.hideControl = function (){
    if(this.html){
        this.gridItem.dom.controlContainer.style.display = 'none';
        this.hiddenControl = true;
    }   
    return this;
};

GridFieldItem.prototype.showControl = function (){
    if ( this.html ) {
        this.gridItem.dom.controlContainer.style.display = 'block';
        this.hiddenControl = false;
    }
    return this;
};

GridFieldItem.prototype.hideControlImage = function () {
    if (this.html){
        this.dom.iconControl.style.display = 'none';
        this.dom.iconControl2.style.display = 'none';
    }
    return this;   
};

GridFieldItem.prototype.showControlImage = function () {
    if (this.html){
        this.dom.iconControl.style.display = 'inline-block';
        this.dom.iconControl2.style.display = 'inline-block';     
    }
    return this;   
};

GridFieldItem.prototype.setHiddedField = function (value) {
    if ( !(typeof value === "boolean") ) {
        throw new Error ("GridFieldItem.setHiddedField(): value is no valid, should be a boolean type")
    }
    this.hiddenControl = value;
    return this;
};


GridFieldItem.prototype.getData = function (){
    var i, data = {}, parentWrapped, index;
    for ( i = 0 ; i < this.properties.length ; i+=1 ) {
        data[this.properties[i]] = this[this.properties[i]];
    }
    if (this.getParentWrapped() !== null ) { 
        parentWrapped = this.getParentWrapped();
        index  = parentWrapped.listOfEligibleForDependecy.indexOf(this.type);
        if (index !== -1){
            data['directDependence'] = this.directDependence;
        }
    }
    if(this.type == "dropdown" || this.type == "checkbox" || this.type == "radio" || this.type === 'suggest'){
        data['options'] = this.getOptions();
    }
    data.type = this.type;
    return data;
};

GridFieldItem.prototype.getContainer = function () {
    if ( this.parent ) {
        if (this.parent != undefined ) {
            return this.parent.getParent();
        }else{
            return null;
        }
    }
    return null;
};

GridFieldItem.prototype.getParentWrapped = function () {
    if (this.getContainer() !== null) {
        if (this.getContainer().parent !== undefined ){
            return this.getContainer().parent;
        } else {
            return null;
        }
    }
    return null;
};

GridFieldItem.prototype.setDependentColumns = function (columns) {
    var i;
    if (!(jQuery.isArray(columns))){
        throw new Error ("GridFieldItem.setDependentColumns(): the value should be a array");
    }
    this.dependentColumns = [];
    for ( i = 0 ; i < columns.length ; i+=1 ) {
        this.addDependentColumn(columns[i]);
    }
    return this;
};

GridFieldItem.prototype.addDependentColumn = function (column) {
    if (typeof column === "string" ) {
        this.dependentColumns.push(column);
    }
    return this;
};

GridFieldItem.prototype.getDependentColumns = function () {
    return this.dependentColumns;
};

GridFieldItem.prototype.addDirectDependence = function (column) {
    var index;
    index = this.directDependence.indexOf(column);
    if (index === -1) {
        this.directDependence.push(column);        
    }
    return  this;
};

GridFieldItem.prototype.removeDirectDependence = function (columnName) {
    var index;
    index = this.directDependence.indexOf(columnName);
    if (index !== -1) {
        this.directDependence.splice(index,1);     
    }
    return  this;
};

GridFieldItem.prototype.setDirectDependence = function (columns) {
    var i;
    this.directDependence = [];
    for ( i = 0 ;  i < columns.length ; i++ ) {
        this.addDirectDependence(columns[i]);
    }
    return this;
};


GridFieldItem.prototype.getDirectDependence = function (columns) {
    return this.directDependence;
};
var TextGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'text'
    }));
    this.properties =  [
        "name",
        "placeholder",
        "defaultValue",
        "title",
        "required",
        "mask",
        "width",
        "dependentColumns"
    ];
    this.placeholder = null;

    TextGridFieldItem.prototype.init.call(this, settings);
};

TextGridFieldItem.prototype = new GridFieldItem();

TextGridFieldItem.prototype.type = "text";

TextGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        placeholder : '[placeholder]'
    }
    jQuery.extend(true, defaults, settings);

    this.setPlaceholder(defaults.placeholder);
};

TextGridFieldItem.prototype.setPlaceholder = function (placeholder) {
    if ( typeof placeholder === "string" ) {
        if ( this.gridItem ) {
            this.gridItem.setPlaceholder(placeholder);
        }
        this.placeholder = placeholder;
    } 
    return  this;
};

TextGridFieldItem.prototype.getPlaceholder = function () {
    return this.placeholder;  
};


var TextAreaGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'textarea'
    }));
    this.properties =  [
        "name",
        "placeholder",
        "defaultValue",
        "title",
        "required",
        "width",
        "rows"
    ];
    this.placeholder = null;
    this.rows = null;

    TextAreaGridFieldItem.prototype.init.call(this, settings);
};

TextAreaGridFieldItem.prototype = new GridFieldItem();

TextAreaGridFieldItem.prototype.type = "textarea";

TextAreaGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        placeholder : '[placeholder]',
        rows : 30
    }
    jQuery.extend(true, defaults, settings);

    this.setPlaceholder(defaults.placeholder);
    this.setRows(defaults.rows);
};

TextAreaGridFieldItem.prototype.setPlaceholder = function (placeholder) {
    if ( typeof placeholder === "string" ) {
        if ( this.gridItem ) {
            this.gridItem.setPlaceholder(placeholder);
        }
        this.placeholder = placeholder;
    } 
    return  this;
};

TextAreaGridFieldItem.prototype.getPlaceholder = function () {
    return this.placeholder;  
};


TextAreaGridFieldItem.prototype.setRows = function (rows) {
    if ( typeof rows === "number" ) {
        if ( this.gridItem ) {
            this.gridItem.setRows(rows);
        }
        this.rows = rows;
    }
    return this;
};

TextAreaGridFieldItem.prototype.getRows = function () {
    return this.rows;
};
var DropDownGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'dropdown'
    }));
    this.options = null;
    
    this.properties =  [
        "name",
        "defaultValue",
        "title",
        "required",
        "width",
        "dependentColumns"
    ];

    DropDownGridFieldItem.prototype.init.call(this, settings);
};

DropDownGridFieldItem.prototype = new GridFieldItem();

DropDownGridFieldItem.prototype.type = "dropdown";

DropDownGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        options : [] 
    }
    jQuery.extend(true, defaults, settings);

    this.setOptions(defaults.options);
};

DropDownGridFieldItem.prototype.setOptions = function (options){
    if(this.gridItem){
        this.gridItem.setOptions(options);     
        this.options = options;
    }
    return this;
};

DropDownGridFieldItem.prototype.addOption = function (option){
    if(this.gridItem) {
        this.gridItem.addOption(option);
    }
    return this;
};

DropDownGridFieldItem.prototype.getOptions = function (){
    if(this.gridItem){
        return this.gridItem.getOptions();
    }
    return this;
};
var CheckBoxGroupGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'checkbox'
    }));
    this.options = null;

    this.properties =  [
        "name",
        "defaultValue",
        "title",
        "required",
        "width"
    ];

    CheckBoxGroupGridFieldItem.prototype.init.call(this, settings);
};

CheckBoxGroupGridFieldItem.prototype = new GridFieldItem();

CheckBoxGroupGridFieldItem.prototype.type = "checkbox";

CheckBoxGroupGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        options : [] 
    }
    jQuery.extend(true, defaults, settings);
    this.setOptions(defaults.options);
};

CheckBoxGroupGridFieldItem.prototype.setOptions = function (options){
    if(this.gridItem){
        this.gridItem.setOptions(options);     
        this.options = options;
    }
    return this;
};

CheckBoxGroupGridFieldItem.prototype.addOption = function (option){
    if(this.gridItem) {
        this.gridItem.addOption(option);
    }
    return this;
};

CheckBoxGroupGridFieldItem.prototype.getOptions = function (){
    if(this.gridItem){
        return this.gridItem.getOptions();
    }
    return this;
};
/*
CheckBoxGroupGridFieldItem.prototype.setWidth = function (width){
    var width = !(isNaN(parseInt(width)))? parseInt(width) : 100;  
    if (typeof width === "number") {
        if ( this.gridItem ) {
            this.gridItem.setWidth(width);
            jQuery(this.gridItem.dom.labelTextContainer).css('width' , '100%');
            jQuery(this.gridItem.dom.controlContainer).css('width' , '100%');
        }
        this.width = width;
    }
    return this;
};*/
var RadioGroupGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'radio'
    }));
    
    this.properties =  [
        "name",
        "defaultValue",
        "title",
        "required",
        "width"
    ];

    this.options = null;

    RadioGroupGridFieldItem.prototype.init.call(this, settings);
};

RadioGroupGridFieldItem.prototype = new GridFieldItem();

RadioGroupGridFieldItem.prototype.type = "radio";

RadioGroupGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        options : [] 
    }
    jQuery.extend(true, defaults, settings);

    this.setOptions(defaults.options);
};

RadioGroupGridFieldItem.prototype.setOptions = function (options){
    if(this.gridItem){
        this.gridItem.setOptions(options);     
        this.options = options;
    }
    return this;
};

RadioGroupGridFieldItem.prototype.addOption = function (option){
    if(this.gridItem) {
        this.gridItem.addOption(option);
    }
    return this;
};

RadioGroupGridFieldItem.prototype.getOptions = function (){
    if(this.gridItem){
        return this.gridItem.getOptions();
    }
    return this;
};
var SuggestGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'suggest'
    }));
    this.properties =  [
        "name",
        "defaultValue",
        "title",
        "placeholder",
        "required",
        "dataType",
        "width",
        "dependentColumns"
    ];
    this.options = null;
    this.placeholder = null;
    SuggestGridFieldItem.prototype.init.call(this, settings);
};

SuggestGridFieldItem.prototype = new GridFieldItem();

SuggestGridFieldItem.prototype.type = "suggest";

SuggestGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        options : []
    }
    this.options = new PMUI.util.ArrayList();
    jQuery.extend(true, defaults,settings);
    this.setPlaceholder(defaults.placeholder);
    this.setOptions(defaults.options);
};

SuggestGridFieldItem.prototype.clearOptions = function () {
    while (this.options.getSize() > 0) {
        this.removeItem(0);
    }
    return this;
};

SuggestGridFieldItem.prototype.removeItem = function (item) {

    var itemToRemove = this.items.find(item);

    if (itemToRemove) {
        this.options.remove(itemToRemove);
    }
    return this;
};

SuggestGridFieldItem.prototype.setOptions = function (options){
    var i;
    this.clearOptions();

    if(jQuery.isArray(options)) {
        for ( i = 0 ; i < options.length ; i += 1 ) {
            this.addOption(options[i])
        }    
    }
    return this;
};

SuggestGridFieldItem.prototype.addOption = function (option){
    this.options.insert(option);
    return this;
};

SuggestGridFieldItem.prototype.getOptions = function (){
    return this.options.asArray();
};

SuggestGridFieldItem.prototype.setPlaceholder = function (placeholder) {
    if ( typeof placeholder === "string" ) {
        if ( this.gridItem ) {
            this.gridItem.setPlaceholder(placeholder);
        }
        this.placeholder = placeholder;
    } 
    return  this;
};

SuggestGridFieldItem.prototype.getPlaceholder = function () {
    return this.placeholder;  
};

var GridFieldCell = function(settings) {
	/*if ( settings !== undefined ) {
		this.onClickConfigFields = typeof settings.onClickConfigFields == 'function' ? settings.onClickConfigFields : null; 
	}*/
	PMUI.core.Container.call(this, jQuery.extend(settings, {
		elementTag: 'li',
		factory : {
			products : {
				"text" : TextGridFieldItem, 
				"textarea" : TextAreaGridFieldItem,
				"dropdown" : DropDownGridFieldItem,
				"checkbox" : CheckBoxGroupGridFieldItem,
				"radio" : RadioGroupGridFieldItem,
				"suggest" : SuggestGridFieldItem,
				"datetime" : DateTimeGridFieldItem,
				"button" : ButtonGridFieldItem,
				"link" : LinkGridFieldItem,
				"image" : ImageGridFieldItem
				/*"button" : ,
				"link" : ,
				"yesno" : ,
				"yesno" : ,
				"button" : ,
				"datetime" : ,
				"label" : ,*/
			},
			defaultProduct: "text"
		},
		style : {
			cssProperties : {
				'display' : 'inline-block',
				'left': '0px',
				'top': '0px',
				'height': 'auto',
				'display': 'inline-block',
				'position': 'relative'
			}
		}
	}));
	this.onClickConfigFields = null;
	GridFieldCell.prototype.init.call(this, settings);
};

GridFieldCell.prototype = new PMUI.core.Container();

GridFieldCell.prototype.type = 'GridFieldCell'

GridFieldCell.prototype.init = function(settings) {
	var defaults = {
		items: [],
		onClickConfigFields : null
	};
	
	jQuery.extend(true, defaults, settings);

	this.setOnClickConfigFields(defaults.onClickConfigFields);

	this.addCSSClasses(['gridfieldcell-bodycell']);
};

GridFieldCell.prototype.setOnClickConfigFields = function ( handler ) {
    if ( ! (handler === null || typeof handler === 'function')) {
        throw new Error("GridFieldItem.setOnClickConfigField(): handler should be a function type");
    }
    this.onClickConfigFields = handler;
    if ( this.items.asArray().length ){
    	for ( var i = 0 ; i < this.items.getSize() ; i+=1 ) {
    		this.getItem(i).setOnClickConfigFieldHandler(handler);
    	}
    } 
    return this;
};

GridFieldCell.prototype.addItem = function(item) {
	if(this.items.getSize()) {
		throw new Error("addItem(): The cell has already a content.");
	}
	if ( item instanceof GridFieldItem) {
			item.setParent(this);
	} else {
		item.parent = this;
	}
	item.onClickConfigField = this.onClickConfigFields;
	PMUI.core.Container.prototype.addItem.call(this, item);
	//this.setBehavior('drag');
	return this;
};

GridFieldCell.prototype.clearItems = function() {
	PMUI.core.Container.prototype.clearItems.call(this);
	//this.setBehavior('drop');
	return this;
};

GridFieldCell.prototype.removeItem = function(item) {
	PMUI.core.Container.prototype.removeItem.call(this, item);
	if(!this.items.getSize()) {
		//this.setBehavior('drop');
	}
	return this;
};

GridFieldCell.prototype.getContent = function() {
	return this.items.get(0) || null;
};

GridFieldCell.prototype.createHTML = function() {
	if(this.html) {
		return this.html;
	}
	PMUI.core.Container.prototype.createHTML.call(this);
	if ( this.items.getSize() ) {
		//this.setBehavior('drag');
	} else {
		//this.setBehavior('drop');
	}
	this.setDisplay('inline-block');
	return this.html;
};

GridFieldCell.prototype.getData = function () {
	return this.items.asArray()[0].getData();
};

GridFieldCell.prototype.getControlType = function () {
	if (this.items.asArray().length){
		return this.getItem(0).type;
	}
	return null;
};

GridFieldCell.prototype.getControl = function (){
	if (this.items.asArray().length){
		return this.getItem(0);
	}
	return null;
};

GridFieldCell.prototype.getControlName = function () {
	if (this.items.asArray().length){
		return this.getItem(0).getName();
	}
	return null;	
};

GridFieldCell.prototype.getControlTitle = function () {
	if (this.items.asArray().length){
		return this.getItem(0).getTitle();
	}
	return null;	
};

GridFieldCell.prototype.getDependentColumns = function () {
	if ( this.items.asArray().length) {
		return this.getItem(0).getDependentColumns();
	}
	return null;
};
var GridField = function(settings){
	this.dom = {};
	PMUI.core.Container.call(this, jQuery.extend(true, settings , {
		behavior : 'sort',
		factory : {
			products: {
				'griditem': GridFieldCell
			},
			defaultProduct: 'griditem'
		}
	}));
	this.visibleStatusBar = null;
	this.onItemClick = null;
	this.statusBarMessage = null;
	this.blackCell = null;
	this.onDropHandlerNewCell = null;
	this.parent = null;	
	this.onClickItemConfigHandler = null;
	this.onAddColumn = null;

	GridField.prototype.init.call(this, settings);
};

GridField.prototype = new PMUI.core.Container();

GridField.prototype.type = "GridField";

GridField.prototype.init = function(settings) {
	var defaults = {
		statusBarMessage: null,
		visibleStatusBar: true,
		onItemClick: null,
		behavior:'sort',
		onDropHandlerNewCell : null,
		onClickItemConfigHandler : null,
		onAddColumn : null
	};
	
	jQuery.extend(true, defaults, settings);
	this.setOnClickItemConfigHandler(defaults.onClickItemConfigHandler);
	this.setStatusBarMessage(defaults.statusBarMessage);
	this.setOnItemClickHandler(defaults.onItemClick);
	this.setVisibleStatusBar(defaults.visibleStatusBar);
	this.setBehavior(defaults.behavior);
	this.setOnDropHandlerNewCell(defaults.onDropHandlerNewCell);
	this.setParent(defaults.parent);
	this.setOnAddColumn(defaults.onAddColumn);
};

GridField.prototype.setOnAddColumn = function (handler) {
	var i;
	if ( !(typeof handler === 'function' || handler === null) ) {
		throw new error ("GridField.setMenuItems(): the parameter is not valid, should be a function type")
	}
	this.onAddColumn = handler;
	for ( i = 0 ; i < this.getItems().length; i+=1 ) {
		this.getItem(i).setOnBeforeContextMenu(this.onAddColumn);
	} 
	return this;	
};

GridField.prototype.setOnClickItemConfigHandler = function (handler) {
    if ( ! (handler === null || typeof handler === 'function')) {
        throw new Error("GridField.setOnClickConfigField(): handler should be a function type");
    }
    this.onClickItemConfigHandler = handler;
    if ( this.items.asArray().length ){
    	for ( var i = 0 ; i < this.items.getSize() ; i+=1 ) {
    		this.getItem(i).setOnClickConfigFields(handler);
    	}
    } 
    return this;	
};

GridField.prototype.setVisibleStatusBar = function (value) {
	if ( typeof value !== "boolean" ) {
		throw new Error ("GridField.setVisibleStatusBar(): the parameter is not valid, must be a boolean");
	}
	this.visibleStatusBar = value;
	return this;
};

GridField.prototype.onItemClickHandler = function(listItem) {
	if(typeof this.onItemClick === 'function') {
		this.onItemClick(this, listItem);
	}
	return this;
};

GridField.prototype.setOnItemClickHandler = function(handler) {
	if(!(handler === null || typeof handler === 'function')) {
		throw new Error("setOnItemClickHandler(): The parameter must be a function or a handler.");
	}
	this.onItemClick = handler;
	return this;
};


GridField.prototype.hideStatusBar = function() {
	this.visibleStatusBar = false;
	if(this.dom.statusBar) {
		this.dom.statusBar.style.display = 'none';
	}
	return this;
};

GridField.prototype.showStatusBar = function() {
	this.visibleStatusBar = true;
	if(this.dom.statusBar) {
		this.dom.statusBar.style.display = '';
	}
	return this;
};

GridField.prototype.setStatusBarMessage = function(statusBarMessage) {
	if(!(statusBarMessage === null || typeof statusBarMessage === 'function')) {
		throw new Error("setStatusBarMessage(): The parameter must be a function or null.")
	}
	this.statusBarMessage = statusBarMessage;
	return this;
};

GridField.prototype.addItem = function(item, index) {
	var newItem = {};
	if ( !(item instanceof GridFieldCell) ) {
		item.pmType = item.type;
		newItem.items = [];
		newItem.onClickConfigFields = this.onClickItemConfigHandler;
		newItem.items.push(item);
		newItem.height = 75;
		newItem.onBeforeContextMenu = this.onAddColumn;
		PMUI.core.Container.prototype.addItem.call(this, newItem, index);
	} else {
		item.setOnClickConfigFields(this.onClickItemConfigHandler);
		item.setHeight(75);
		item.setOnBeforeContextMenu(this.onAddColumn);
		PMUI.core.Container.prototype.addItem.call(this, item, index);
	}
	if (this.html) {
		this.updateContainerItemsWidth();
	}
	return this;
};

GridField.prototype.updateContainerItemsWidth = function () {
	var width = 0;
	if (this.dom.list){
		for (var i = 0 ; i < this.items.asArray().length ; i+=1 ) {
			width = width + jQuery(this.getItem(i).html).outerWidth();
		}
		this.dom.list.style.width = width + 4 + 'px';
	}
	return this;
};

GridField.prototype.setItems = function(items) {
	if(this.actions !== null) {
		PMUI.core.Container.prototype.setItems.call(this, items);
		this.updateStatusBar();
	}
	return this;
};

GridField.prototype.updateStatusBar = function() {
	var msg, size;
	if(this.dom.statusBar) {
		size = this.filterCriteria ? jQuery(this.containmentArea).find('>li').length : this.items.getSize();
		if(typeof this.statusBarMessage === 'function') {
			msg = this.statusBarMessage(this, size, !!this.filterCriteria, this.filterCriteria);
		} else {
			msg = size + (this.filterCriteria ? " result(s) matching \"" + this.filterCriteria + "\"" : " item(s).");
		}
		this.dom.statusBar.textContent = msg;
	}
	return this;
};

GridField.prototype.getData = function() {
	var i, items = this.items.asArray(), data = [];

    for(i = 0; i < items.length; i += 1) {
    	if ( items[i].getItems().length ) {
        	data.push(items[i].getData());
    	}
    }
    return data;
};

/*GridField.prototype.defineEvents = function() {
	this.removeEvents().eventsDefined = true;
	return this;
};*/

GridField.prototype.createHTML = function() {
	var list, statusBar, listContainer;
	if(this.html) {
		return this.html;
	}
    PMUI.core.Element.prototype.createHTML.call(this);
    listContainer = PMUI.createHTMLElement('div');
    listContainer.className = "GridField-listContainer";
	list = PMUI.createHTMLElement('ul');
	list.className = 'GridField-list';
    this.containmentArea = list;
    statusBar = PMUI.createHTMLElement('div');
	statusBar.className = 'GridField-statusbar';

	this.containmentArea = list;
	//this.dom.list.style.width = this.sumWidthFields() + 120 +'px';
	listContainer.appendChild(list);

	this.html.appendChild(listContainer);
	this.html.appendChild(statusBar);

	this.dom.list = list;
	this.dom.listContainer = listContainer; 
	this.dom.list.style.width = this.getWidth();
	this.dom.statusBar = statusBar;

	if(this.visibleStatusBar) {
		this.showStatusBar();
	} else {
		this.hideStatusBar();
	}
	//this.addItem(this.addNewBlanckCell());
	this.paintItems();
	//this.dom.list.appendChild(this.addNewBlanckCell());
    this.style.applyStyle();
    this.setBehavior(this.behavior);
    this.setHeight(this.height);
    this.defineEvents();
	return this.html;
};

GridField.prototype.setHeight = function (height) {
	var heightList;
	PMUI.core.Container.prototype.setHeight.call(this, height);
	if(this.dom.list){
        if(typeof height === 'number') {
            heightList = height + "px";   
        } else if(/^\d+(\.\d+)?px$/.test(height)) {
            heightList = height;
        } else if(/^\d+(\.\d+)?%$/.test(height)) {
            heightList = height;
        } else if(/^\d+(\.\d+)?em$/.test(height)) {
            heightList = height;
        } else if(height === 'auto' || height === 'inherit') {
            heightList = height;
        } else {
            throw new Error('setHeight: height param is not a number');
        }
		this.dom.list.style.height  = 75 + 'px';		
	}	
	for(var i = 0 ; i < this.items.getSize(); i+=1 ) {
		this.items.asArray()[i].setHeight(75);
	}
	return this;
};

GridField.prototype.setBehavior = function(behavior) {
	PMUI.core.Container.prototype.setBehavior.call(this, behavior);
	if ( this.behaviorObject ) {
		this.behaviorObject.setAlignment('horizontal');
	}
	return this;
};

GridField.prototype.addNewBlanckCell = function () {
	var blackCellHTML, blackCell,  containt, iconAddContain, messageBlack;
	blackCell = new GridFieldCell({
		height : 75,
		behavior : 'drop',
		width : '7em',
		onDrop : this.onDropHandlerNewCell || null
	});
	//blackCell.addCSSClasses(['GridField-black-cell']);

	blackCellHTML = blackCell.getHTML();
	containt = PMUI.createHTMLElement('div');
	containt.className = "GridField-black-cell-contain";
	messageBlack = PMUI.createHTMLElement('span');
	messageBlack.className = "GridField-black-cell-message";
	messageBlack.textContent = "drag a variable to add a column.";
	iconAddContain = PMUI.createHTMLElement('i');
	//iconAddContain.className =  "GridField-black-cell-icon";
	this.blackCell = blackCell;
	containt.appendChild(iconAddContain);
	containt.appendChild(messageBlack);
	blackCellHTML.appendChild(containt);	
	return this.blackCell;
};

GridField.prototype.sumWidthFields = function(){
	var res = 0;
	for (var i = 0 ; i<this.getItems().length;i++){
 		if(this.getItem(i).getContent()){res = res+this.getItem(i).getContent().getWidth();}
	}
	return res;
};


GridField.prototype.setOnDropHandlerNewCell = function (handler) {
	if ( !(typeof handler === 'function' || handler === null) ){
		throw new Error ('GridField.setOnDropHandlerNewCell(): the value is invalid.');
	}
	this.onDropHandlerNewCell = handler;
	return this;
};


GridField.prototype.onCellDropHandler = function() {
	var that = this;
	return function(cell, item, index) {
		var res;
		if(typeof that.onCellDrop === 'function') {
			res = that.onCellDrop(cell, item, index);
		}
		return res;
	};
};

GridField.prototype.setParent = function (parent) {
	this.parent = parent;
	return this;
};

/*GridField.prototype.setMenuItems = function (handler) {

};*/
/*
GridField.prototype.hideItems = function () {
	var i, fieldItem, cell, maxHeight = 0 ;
	for ( i = 0 ; i < this.items.asArray().length ; i+=1 ) {
		cell = this.items.asArray()[i];
		if (cell.items.asArray().length){
			fieldItem = cell.getItems()[0];
			fieldItem.hideControl();
			fieldItem.showControlImage();	
		}
		if (maxHeight < $(fieldItem.html).outerHeight()){
			maxHeight = $(fieldItem.html).outerHeight();
		}
	}
	this.setHeight(maxHeight);
	return this;
};*/
var DateTimeGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'datetime'
    }));
    this.properties =  [
        "name",
        "defaultValue",
        "title",
        "required",
        "mask",
        "width",
        "pickType"
    ];

    this.pickType = null;

    DateTimeGridFieldItem.prototype.init.call(this, settings);
};

DateTimeGridFieldItem.prototype = new GridFieldItem();

DateTimeGridFieldItem.prototype.type = "datetime";

DateTimeGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        pickType : 'datetime'
    }
    jQuery.extend(true, defaults, settings);

    this.setPickDate(defaults.pickType);
};

DateTimeGridFieldItem.prototype.setPickDate = function (pickType) {
    if ( typeof pickType === "string" ) {
        this.pickType = pickType;
    }
    return  this;
};

DateTimeGridFieldItem.prototype.getPickDate = function () {
    return this.pickType;  
};


var ButtonGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'button'
    }));
    this.properties =  [
        "name",
        "title",
        "width",
        "label"
    ];
    ButtonGridFieldItem.prototype.init.call(this, settings);
};

ButtonGridFieldItem.prototype = new GridFieldItem();

ButtonGridFieldItem.prototype.type = "button";

ButtonGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        label : "-Button-"
    }
    jQuery.extend(true, defaults, settings);

    this.setLabel(defaults.label);
};

ButtonGridFieldItem.prototype.setLabel = function (label) {
    if ( !(typeof label === "string") ) {
        throw new error('ButtonGridFieldItem.setLabel():the value is invalid, a value expected type string');
    }
    if (this.gridItem){
        this.gridItem.setValue(label);
    }
    this.label = label;
    return this;
};

ButtonGridFieldItem.prototype.getLabel = function () {
    return this.label;
};

var LinkGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'link'
    }));
    this.properties =  [
        "name",
        "title",
        "width",
        "href"
    ];
    this.href = null;
    LinkGridFieldItem.prototype.init.call(this, settings);
};

LinkGridFieldItem.prototype = new GridFieldItem();

LinkGridFieldItem.prototype.type = "link";

LinkGridFieldItem.prototype.init = function (settings) {
    var defaults = {
        href : ""
    }
    jQuery.extend(true, defaults, settings);

    this.setHref(defaults.href);
};

LinkGridFieldItem.prototype.setHref = function (href) {
    if ( !(typeof href === "string") ) {
        throw new error('LinkGridFieldItem.sethref():the value is invalid, a value expected type string');
    }
    if (this.gridItem){
        this.gridItem.setUrl(href);
    }
    this.href = href;
    return this;
};

LinkGridFieldItem.prototype.getHref = function () {
    return this.href;
};

LinkGridFieldItem.prototype.setWidth = function (width){
    width = parseInt(width);

    if (typeof width === "number") {
        if (this.parent){
            if (this.parent.parent){
                if(this.parent.parent.html){
                    auxWidth = jQuery(this.parent.parent.dom.list).outerWidth() - parseInt(this.width) + width + 'px';
                    this.parent.parent.dom.list.style.width = auxWidth; 
                }
            }
        }
        if ( this.gridItem ) {
            this.gridItem.setWidth(width);
            jQuery(this.gridItem.dom.labelTextContainer).css('width',"70%");
            jQuery(this.gridItem.dom.controlContainer).css('width' , '100%');
        }
        this.width = width;
    }
    return this;
};
var ImageGridFieldItem = function (settings) {
    GridFieldItem.call(this,  jQuery.extend(true, settings , {
        controlType : 'image'
    }));
    this.properties =  [
        "name",
        "title",
        "width",
        "shape",
        "alt",
        "comment",
        "src"
    ];
    this.href = null;
    ImageGridFieldItem.prototype.init.call(this, settings);
};

ImageGridFieldItem.prototype = new GridFieldItem();

ImageGridFieldItem.prototype.type = "image";

ImageGridFieldItem.prototype.init = function(options){
    var defaults = {
            shape : "thumbnail",
            alt : "",
            comment : "",
            src : ""
        };
    jQuery.extend(true, defaults, options);

    this.setShape(defaults.shape);
    this.setAlt(defaults.alt);
    this.setComment(defaults.comment);
    this.setSrc(defaults.src);
};

ImageGridFieldItem.prototype.setShape = function(shape){
    if ( !(typeof shape === "string") ) {
        throw new Error ("ImageGridFieldItem.setShape(): the value is invalid, a value expected type string");
    }
    this.shape = shape;
    return this;
};

ImageGridFieldItem.prototype.getShape = function(){
    return this.shape;
};

ImageGridFieldItem.prototype.setAlt = function(alt){
    if ( !(typeof alt === "string") ) {
        throw new Error ("ImageGridFieldItem.setAlt(): the value is invalid, a value expected type string");
    }
    this.alt = alt;
    return this;
};

ImageGridFieldItem.prototype.getAlt = function(){
    return this.alt;
};

ImageGridFieldItem.prototype.setComment = function(comment){
    if ( !(typeof comment === "string") ) {
        throw new Error ("ImageGridFieldItem.setComment(): the value is invalid, a value expected type string");
    }
    if (this.gridItem) {
        this.gridItem.setComment(comment);
    }
    this.comment = comment;
    return this;
};

ImageGridFieldItem.prototype.getComment = function(){
    return this.comment;
};

ImageGridFieldItem.prototype.setSrc = function(src){
    if ( !(typeof src === "string") ) {
        throw new Error ("ImageGridFieldItem.setSrc(): the value is invalid, a value expected type string");
    }
    this.src = src;
    return this;
};

ImageGridFieldItem.prototype.getSrc = function(){
    return this.src;
};

ImageGridFieldItem.prototype.createHTML  = function(){
    GridFieldItem.prototype.createHTML.call(this);
    this.gridItem.dom.commentContainer.style.display = "none";
    return this.html; 
}
var PMGridFieldFactory = new PMUI.util.Factory({
	products: {
		"text" : TextGridFieldItem, 
		"textarea" : TextAreaGridFieldItem,
		"dropdown" : DropDownGridFieldItem,
		"checkbox" : CheckBoxGroupGridFieldItem,
		"radio" : RadioGroupGridFieldItem,
		"suggest" : SuggestGridFieldItem,
		"datetime" : DateTimeGridFieldItem,
		"button" : ButtonGridFieldItem,
		"link" : LinkGridFieldItem,
		"image" : ImageGridFieldItem
	},
	defaultProduct: "text"
});
var FieldWrapper = function (options){
	this.name  = null;
	this.label = null;
	this.required = null;
	this.hint = null;
	this.mode = null;
	this.defaultValue = null;
	this.sqlConnection = null;
	this.sql = null;
	this.field = null;
	this.onClick  = null;
	this.value  = null;
	this.html = null;
	this.variable = null;
	this.dependentFields = null;
	this.dataType = null;
	this.directDependence = null;
	this.indirectDependence = null;
	this.dependets = null;
	this.dependent = null;
	this.dependenceStates = null;
	this.id = null;
	this.previousColspan = null;
	FieldWrapper.prototype.init.call(this, options);
};

FieldWrapper.prototype = new PMUI.core.Element();

FieldWrapper.prototype.init = function (options){
	var defaults = {
		label : "[field]",
		required : false,
		hint : "",
		mode : "parent",
		defaultValue : "",
		sqlConnection :"",
		sql : "",
		colSpan : 12,
		field : null,
		onClick : null,
		variable: null,
		dependentFields : [],
		dataType : '',
		id : PMUI.generateUniqueId(),
		name : ""
	};
	this.directDependence = [];
	this.indirectDependence = [];
	this.dependent = [];
	this.dependets = [];
	this.dependenceStates = {};
	
	//this.dependentFields = new PMUI.util.ArrayList();

	jQuery.extend(true, defaults, options);
	this.setField(defaults.field);
	this.setName(defaults.name);
	this.setLabel(defaults.label);
	this.setRequired(defaults.required);
	this.setHint(defaults.hint);
	this.setMode(defaults.mode);
	this.setDefaultValue(defaults.defaultValue);
	this.setSqlConnection(defaults.sqlConnection);
	this.setSql(defaults.sql);
	this.setColSpan(defaults.colSpan);
	this.setOnClickHandler(defaults.onClick);
	this.setVariable(defaults.variable);
	this.setDependentFields(defaults.dependentFields);
	this.setDataType(defaults.dataType);
	this.setId(defaults.id);
};

FieldWrapper.prototype.setVariable = function(variable) {
	if(!(variable ===  null || variable instanceof PMVariable)) {
		throw new Error("setVariable(): The parameter must be an instance of PMVariable or null.");
	}
	this.variable = variable;
	if(this.variable){
		this.setDataType(this.variable.fieldType);
	}
	return this;
};

FieldWrapper.prototype.getVariable = function() {
	return this.variable;
};

FieldWrapper.prototype.getVariableName = function() {
	return (this.variable && this.variable.getName()) || null;
};

FieldWrapper.prototype.setOnClickHandler = function(handler){
    if(!(handler === null || typeof handler === 'function')) {
        throw new Error("setOnClickHandler(): The parameter must be a function or null.");
    }
    this.onClick = handler;
    return this;
};

FieldWrapper.prototype.setField = function(field){
	switch (field) {
		case 'text' :
			this.field  = new PMUI.field.TextField({disabled : true});
		break;
		case 'dropDownList' :
			this.field = new PMUI.field.DropDownListField();
		break;
		case 'checkBox' :
			this.field = new PMUI.field.CheckBoxGroupField({
				controlPositioning: 'horizontal',
				maxDirectionOptions: 1
			});
		break;
		case 'radioButtonGroup':
			this.field = new PMUI.field.RadioButtonGroupField({
				controlPositioning: 'horizontal',
				maxDirectionOptions: 1
			});
		break;
		case 'calendar' :
			this.field = new PMUI.field.DateTimeField();
		break;
		case 'textArea' :
			this.field = new PMUI.field.TextAreaField({disabled : true});
		break;
		case 'button' :
			this.field = new PMUI.field.ButtonField({
				labelVisible : false,
				buttonAlign : 'center'
			});
		break;
		case 'submit' :
			this.field = new PMUI.field.ButtonField({
				labelVisible : false,
				buttonAlign : 'center'
			});
		break;
		case 'label' :
			this.field = new PMLabelField();
		break;
		case 'title':
			this.field = new PMTitleField({
				width : '95%'
			});
		break; 
		case 'subtitle':
			this.field = new PMSubtitleField({
				width : '95%'
			});
		break; 
		case 'suggest' :
			this.field = new PMSuggestField({disabled : true});
		break;
		case 'grid' : 
			this.field = new GridField({
				behavior:'sort',
                height : 94,
                width : 'auto',
                parent : this
			});
		break;
		case 'file' :
			this.field = new PMUI.field.UploadField();
		break;
		case 'image' :
			this.field = new PMImageField();
		break;
		case 'link' :
			this.field = new PMLinkField();
		break;
		case 'textLabel' :
			this.field = new PMTextLabelField();
		break;
		case 'form' :
			this.field = new PMFormField();
		break;
	}
	return this;
};
FieldWrapper.prototype.getField = function (){
	return this.field;
};

FieldWrapper.prototype.setName = function (name){
	if(this.field){
		this.field.setName(name);
	}
	this.name = name;
	return this;
};

FieldWrapper.prototype.getName = function(){
	return this.name ;
};

FieldWrapper.prototype.setLabel = function (label) {
	if(this.field){
		this.field.setLabel(label);
		if(this.field.html){
			switch (this.getColSpan()) {
				case 12: 
						if (label.length > 20){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						}
					break;
				case 11:
						if (label.length > 18){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						} 
					break;
				case 10:
						if (label.length > 15){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						} 
					break;
				case 9:
						if (label.length > 12){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						} 
					break;
				case 8: 
						if (label.length > 10){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						}
					break;
				case 7:
						if (label.length > 8){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						}				 
					break;
				case 6:
						if (label.length > 8){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						} 
					break;
				case 5:
						if (label.length > 6){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						} 
					break;
				case 4:
						if (label.length > 6){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						} 
					break;
				case 3: 
						if (label.length > 4){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						}
					break;
				case 2:
						if (label.length > 4){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						}				
					break;
				case 1:
						if (label.length > 4){
							this.field.dom.fieldTextLabel.title = label;
						}else{
							this.field.dom.fieldTextLabel.title = "";
						}				 
					break;
			}
		}
	}
	this.label = label;
	return this;
};

FieldWrapper.prototype.getLabel = function (){
	return this.label;
};
FieldWrapper.prototype.setRequired = function (value){
	if(this.field){
		this.field.setRequired(value);
	}
	this.required = value;
	return this;
};
FieldWrapper.prototype.getRequired = function (){
	return this.required;
};

FieldWrapper.prototype.setHint = function (hint){
	this.hint = hint;
	return this;
};
FieldWrapper.prototype.getHint = function (){
	return this.hint;
};

FieldWrapper.prototype.setMode = function (mode){
	this.mode = mode;
	if(this.field){
		this.activeMode(mode);
	}
	return this;
};
FieldWrapper.prototype.getMode = function (){
	return this.mode;
};

FieldWrapper.prototype.setDefaultValue = function (defaultValue){
	if(this.field){
		this.defaultValue = defaultValue;
		this.field.setValue(defaultValue);
	}
	return this;
};
FieldWrapper.prototype.getDefaultValue = function (){
	return this.defaultValue;
};

FieldWrapper.prototype.setSqlConnection = function (sqlConnection){
	this.sqlConnection = sqlConnection;
	return this;
};

FieldWrapper.prototype.getSqlConnection = function (){
	return this.sqlConnection;
};

FieldWrapper.prototype.setSql = function (sql){
	this.sql = sql;
	return this;
};

FieldWrapper.prototype.getSql = function (){
	return this.sql;
};

FieldWrapper.prototype.setColSpan = function (colSpan){
	var parent = this.getParent();
	if(parent) {
		parent.removeCSSClasses([this.getPreviousColSpanClass(this.previousColspan)]);
		if(this.type !== "title" && this.type !== "subtitle" && this.type !== "grid" && this.type !== "annotation"){
			switch (colSpan) {
				case (12):
					parent.addCSSClasses(["colspan_"+12+"-"+11]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.1946 + "px";
						if(this.label.length > 20){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}
					break;
				case (11): 
					parent.addCSSClasses(["colspan_"+12+"-"+11]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.191+ "px";
						if(this.label.length > 18){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case (10):
					parent.addCSSClasses(["colspan_"+10+"-"+9]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.188 + "px";
						if(this.label.length > 15){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case (9): 
					parent.addCSSClasses(["colspan_"+10+"-"+9]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.1838 + "px";
						if(this.label.length > 12){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case (8): 
					parent.addCSSClasses(["colspan_"+8+"-"+7]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.179919 + "px";
						if(this.label.length > 10){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case (7): 
					parent.addCSSClasses(["colspan_"+8+"-"+7]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.17156 + "px";
						if(this.label.length > 8){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case (6): 
					parent.addCSSClasses(["colspan_"+6]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.1636 + "px";
						if(this.label.length > 8){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case 5: 
					parent.addCSSClasses(["colspan_"+5]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.1505 + "px";
						if(this.label.length > 6){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case 4: 
					parent.addCSSClasses(["colspan_"+4]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.1317 + "px";
						if(this.label.length > 6){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case 3: 
					parent.addCSSClasses(["colspan_"+3]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.0994 + "px";
						if(this.label.length > 4){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case 2: 
					parent.addCSSClasses(["colspan_"+2]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.0994 + "px";
						if(this.label.length > 4){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;
				case 1: 
					parent.addCSSClasses(["colspan_"+1]);
					if(this.html){
						this.field.dom.fieldTextLabel.style.width = $(parent.html).outerWidth()*0.0994 + "px";
						if(this.label.length > 4){
							this.field.dom.fieldTextLabel.title = this.label;
						}	
					}		
					break;						
			}
		}
		parent.setColSpan(colSpan);
		this.previousColspan = colSpan;
	}
	return this;
};

FieldWrapper.prototype.getPreviousColSpanClass = function (previousColSpan){
	var previosClass = "";
	if(previousColSpan){
		switch (previousColSpan) {
			case 12:
				previosClass = "colspan_"+12+"-"+11;
				break;
			case 11: 
				previosClass = "colspan_"+12+"-"+11;
				break;
			case 10: 
				previosClass = "colspan_"+10+"-"+9;			
				break;
			case 9: 
				previosClass = "colspan_"+10+"-"+9;
				break;
			case 8:
				previosClass = "colspan_"+8+"-"+7;
				break;
			case 7: 
				previosClass = "colspan_"+8+"-"+7;
				break;
			case 6: 
				previosClass = "colspan_"+6;
				break;
			case 5: 
				previosClass = "colspan_"+5;
				break;
			case 4: 
				previosClass = "colspan_"+4;
				break;
			case 3: 
				previosClass = "colspan_"+3;
				break;
			case 2: 
				previosClass = "colspan_"+2;
				break;
			case 1: 
				previosClass = "colspan_"+1;
				break;						
		}	
	}
	return previosClass;  
};

FieldWrapper.prototype.getColSpan = function (){
	var parent = this.getParent();
	return (parent && parent.colSpan) || null;
};
/*
FieldWrapper.prototype.createHTML = function(){
	if(this.field.html){
		return this.field.html;
	}
	this.field.createHTML();
	return this.field.html;			
};*/

FieldWrapper.prototype.getHTML  = function(){
	var icon;
	if(!this.html) {
		this.html = this.field.getHTML();
		/*if(this.field.label.length > 10){
			this.field.dom.fieldTextLabel.textContent = this.field.label.substring(0,10)+"... ";
			this.field.dom.fieldTextLabel.title = this.label; 
		}*/
		icon = PMUI.createHTMLElement('i');
		icon.className = 'icon-field';
		this.html.appendChild(icon);
		PMUI.linkToPMUIObject(this.html, this);
		if(this.field.dom.messageContainer){
			this.field.dom.messageContainer.style.display = 'none';			
		}
		if(!(this.type == 'title' || this.type == 'subtitle')){
			this.field.dom.labelTextContainer.style.width = "22.5%";			
		}
	}
	this.setColSpan(this.getColSpan());
	return this.html;
};

FieldWrapper.prototype.defineEvents = function (){
	var that = this; 	
    this.field.defineEvents();
    if (this.parent){
		this.addEvent('click').listen(this.parent.html, function(e){
			if( typeof that.onClick === "function"){
				e.stopPropagation();
				that.onClick(that);
			}
		}); 	
    } 
    /*
	this.field.addEvent('click').listen(this.field.html, function(e){
		if( typeof that.onClick === "function"){
			that.onClick(that);
		}
	});
    */
	return this;
};
/*
FieldWrapper.prototype.setValue = function (value){
	if(this.field) {
		this.field.setValue(value);
		this.value = value;
	}
	return this;
};*/

FieldWrapper.prototype.getValue = function (){
	return this.value;
};

FieldWrapper.prototype.getData = function (){
	var i, data = {};
	for (i = 0 ; i< this.properties.length ; i+=1) {
		if(this.properties[i]==="defaultValueToBoolean"){
			this.properties[i]="defaultValue";
		}
		if(this.properties[i] === 'variable') {
			if(this.variable){
				data['variable'] = this.variable.getName();//todo
				data['variable_uid'] = this.variable.uid;//todo
				data['var_name'] = this.variable.getName();
				data['var_uid'] = this.variable.uid;	
			}
		} else if (this.properties[i] == 'dependentFields') {
			var list=[];
			for(var j = 0 ; j < this.dependentFields.length ; j++){
				list.push(this.dependentFields[j].name);
			}
			data[this.properties[i]] = list;
			this.saveDependenceStates();
			data.dependenceStates = this.dependenceStates;
		}else if (this.properties[i] === 'colSpan') {
			data[this.properties[i]] = this.getParent().colSpan;
		}else {
			data[this.properties[i]] = this[this.properties[i]];	
		}
	}
	if(this.type == "dropdown" || this.type == "checkbox" || this.type == "radio" || this.type === 'suggest'){
		data['options'] = this.getOptions();
	}
	return data;
};

FieldWrapper.prototype.setDependentFields = function (fields) {
	var i;
	this.dependentFields = [];
	for (i=0;i<fields.length;i++){
		this.addDependentField(fields[i]);
	}
	return this;
};

FieldWrapper.prototype.addDependentField = function (field){
	if(this.dependentFields){
		this.dependentFields.push(field);
	};
	return this;
}


FieldWrapper.prototype.getDependentFields = function () {
	return this.dependentFields;
};

FieldWrapper.prototype.addCSSClasses = function(classes) {
	this.field.addCSSClasses(classes);
	return this;
};

FieldWrapper.prototype.removeCSSClasses = function(classes) {
	this.field.removeCSSClasses(classes);
	return this;
};

FieldWrapper.prototype.setDataType = function (type){
	if (typeof type === 'string'){
		this.dataType = type;	
	}
	return this;
};

FieldWrapper.prototype.getDataType = function (){
	return this.dataType;
};


/*FieldWrapper.prototype.setDependents = function (dependets) {
	var i;
	if(jQuery.isArray(dependets)){
		this.dependets = [];
		for ( i = 0 ; i < dependets.length ; i+=1) {
			this.addDependets(dependets[i]);
		}	
	}
};*/

FieldWrapper.prototype.addDependents = function(field){
	if (field instanceof FieldWrapper) {
		this.dependets.push(field);
	}
};



FieldWrapper.prototype.setIndirectDependence = function (indirectDependence) {
	var i;
	if(jQuery.isArray(indirectDependence)){
		this.indirectDependence = [];
		for ( i = 0 ; i < indirectDependence.length ; i+=1) {
			this.addIndirectDependence(indirectDependence[i]);
		}	
	}
};

FieldWrapper.prototype.addIndirectDependence = function(field){
	if (field instanceof FieldWrapper) {
		this.indirectDependence.push(field);
	}
};

FieldWrapper.prototype.getIndirectDependence = function (){
	return this.indirectDependence;
};

FieldWrapper.prototype.setDirectDependence = function (directDependence){
	var i;
	if(jQuery.isArray(directDependence)){
		this.directDependence = [];
		for ( i = 0 ; i < directDependence.length ; i+=1) {
			this.addDirectDependence(directDependence[i]);
		}		
	}
};

FieldWrapper.prototype.addDirectDependence = function(field){
	if ( field instanceof FieldWrapper){
		this.directDependence.push(field);
	}
};

FieldWrapper.prototype.getDirectDependence = function (){
	return this.indirectDependence;
};

FieldWrapper.prototype.saveDependenceStates = function (){
	var i;
	this.dependenceStates.directDependence = [];
	this.dependenceStates.indirectDependence = [];
	this.dependenceStates.dependentFields = [];

	for(i = 0 ; i < this.directDependence.length ; i++){
		this.dependenceStates.directDependence.push(this.directDependence[i].name);
	}
	this.dependenceStates.directDependence = JSON.stringify(this.dependenceStates.directDependence);
	for(i = 0 ; i < this.indirectDependence.length ; i++){
		this.dependenceStates.indirectDependence.push(this.indirectDependence[i].name);
	}
	this.dependenceStates.indirectDependence = JSON.stringify(this.dependenceStates.indirectDependence);
	for(i = 0 ; i < this.dependentFields.length ; i++){
		this.dependenceStates.dependentFields.push(this.dependentFields[i].name);
	}
	this.dependenceStates.dependentFields = JSON.stringify(this.dependenceStates.dependentFields); 
	return this;
};

FieldWrapper.prototype.setId = function (id){
	if(!(typeof id === "string")){
		throw new Error ("setId(): You must enter a string value");		
	}
	this.id = id;
	return this;
};

FieldWrapper.prototype.getId = function (){
	return this.id; 
};

FieldWrapper.prototype.activeMode = function (mode) {
	this.removeCSSClasses(['formview-view', 'formview-disabled']);
	switch (mode) {
		case 'edit':
				this.field.enable();
			break;
		case 'view' :
				this.addCSSClasses(['formview-view']);
				this.field.disable();
			break;
		case 'disabled' :
				this.addCSSClasses(['formview-disabled']);
				this.field.disable();
			break;
	}
	return this;
};
var WrappedTextField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "text"
	}));
	this.width = null;
	this.readOnly = null;
	this.formula = null;
	this.textTransform = null;
	this.validate = null;
	this.mask = null;
	this.maxLength =null;
	this.disabled = null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValue",
		"required",
		"hint",
		"dependentFields",
		"textTransform",
		"validate",
		"mask",
		"maxLength",
		"formula",
		//"disabled",
		"mode"
		//"readOnly",
		//"width",
		//"formula",
		//"sqlConnection",
		//"sql"
	];
	WrappedTextField.prototype.init.call(this, options);
};

WrappedTextField.prototype = new FieldWrapper();
WrappedTextField.prototype.type = "text";

WrappedTextField.prototype.init = function(options){
	var defaults = {
		width : "100%",
		disabled : false,
		formula : "",
		textTransform : "none",
		validate : "any",
		mask : "",
		maxLength : 100
	};
	jQuery.extend(true, defaults, options);
	
	this.setWidth(defaults.width);
	this.setDisabled(defaults.readOnly);
	this.setFormula(defaults.formula);
	this.setTextTransform(defaults.textTransform);
	this.setValidate(defaults.validate);
	this.setMask(defaults.mask);
	this.setMaxLength(defaults.maxLength);
};

WrappedTextField.prototype.setWidth = function (width){
	if(this.field){
		this.field.setWidth(width);		
	}
	this.width = width;
	return this;
};

WrappedTextField.prototype.getWidth = function (){
	return this.width;
};

WrappedTextField.prototype.setDisabled = function(value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled = value;
	}
	return this;
};

WrappedTextField.prototype.getDisabled = function(){
	return this.disabled; 
};

WrappedTextField.prototype.setFormula = function(formula){
	this.formula = formula;
	return this;
};

WrappedTextField.prototype.getFormula = function(){
	return this.formula;
};

WrappedTextField.prototype.setTextTransform = function (values) {
	this.textTransform = values;
	return this;
};

WrappedTextField.prototype.getTextTransform = function () {
	return this.textTransform;
};

WrappedTextField.prototype.setValidate = function (validate) {
	this.validate = validate;
	return this;
};

WrappedTextField.prototype.getValidate = function () {
	return this.validate;
};

WrappedTextField.prototype.setMask = function (mask) {
	this.mask = mask;
	return this;
};

WrappedTextField.prototype.getMask = function () {
	return this.mask;
};

WrappedTextField.prototype.setMaxLength = function (maxLength) {
	this.maxLength = maxLength;
	return this;
};

WrappedTextField.prototype.getMaxLength = function () {
	return this.maxLength;
};
var WrappedDropDownField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "dropDownList"
	}));

	this.disabled = null;
	this.includeOptionGroup = null;
	this.handler = null;
	this.options = null;

	WrappedDropDownField.prototype.init.call(this, options);
};

WrappedDropDownField.prototype = new FieldWrapper();

WrappedDropDownField.prototype.type = "dropdown";

WrappedDropDownField.prototype.properties = [
	"variable",
	"dataType",
	"colSpan",
	"name",
	"id",
	"label",
	"defaultValue",
	"required",
	"hint",
	"dependentFields",
	//"includeOptionGroup",
	"mode"
	//"disabled"
	//"readOnly",
	//"sqlConnection",
	//"sql",
];

WrappedDropDownField.prototype.init = function(options){
	var defaults = {
		disabled : false,
		includeOptionGroup : false,
		options : []
	};
	jQuery.extend(true, defaults, options);

	this.setDisabled(defaults.disabled);
	this.setIncludeOptionGroup(defaults.includeOptionGroup);
	this.setOptions(defaults.options);
};

WrappedDropDownField.prototype.setDisabled = function(value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled= value;
	}
	return this;
};

WrappedDropDownField.prototype.getDisabled = function(){
	return this.disabled; 
};

WrappedDropDownField.prototype.setIncludeOptionGroup = function (value){
	this.includeOptionGroup = value;
	return this;
};

WrappedDropDownField.prototype.getIncludeOptionGroup = function (value){
	return this.includeOptionGroup;
};

WrappedDropDownField.prototype.setOptions = function (options){
	if(this.field){
		this.field.setOptions(options);		
		this.options = options;
	}
	return this;
};
WrappedDropDownField.prototype.addOption = function (option){
	if(this.field) {
		this.field.addOption(option);
	}
	return this;
};

WrappedDropDownField.prototype.getValue = function (){
	if(this.field){
		return this.field.getValue();
	}
	return this;
};

WrappedDropDownField.prototype.setValue = function (value){
	if(this.field){
		this.field.setValue(value);
	}
	return this;
};
WrappedDropDownField.prototype.getOptions = function (){
	if(this.field){
		return this.field.getOptions();
	}
	return this;
};

WrappedDropDownField.prototype.setDefaultValueForBoolean = function (defaultValue){
	if(this.field){
		this.defaultValue = defaultValue;
		this.field.setValue(defaultValue);
	}
	return this;
};
WrappedDropDownField.prototype.getDefaultValueForBoolean = function (){
	return this.defaultValue;
};
var WrappedCheckBoxField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "checkBox"
	}));

	this.disabled = null;
	this.value = null;
	this.options = null;
	this.properties = [
		"variable",
		"dataType",		
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValue",
		"required",
		"hint",
		"mode"
		//"disabled"
		//"dependentFields",
		//"sqlConnection",
		//"sql"
	];

	WrappedCheckBoxField.prototype.init.call(this, options);
};

WrappedCheckBoxField.prototype = new FieldWrapper();

WrappedCheckBoxField.prototype.type = "checkbox";

WrappedCheckBoxField.prototype.init = function(options){
	var defaults = {
		disabled : false,
		value : "",
		options : []
	};
	jQuery.extend(true, defaults, options);
	
	this.setDisabled(defaults.disabled);
	this.setValue(defaults.value);
	this.setOptions(defaults.options);
};

WrappedCheckBoxField.prototype.setDisabled = function(value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled = value;
	}
	return this;
};

WrappedCheckBoxField.prototype.getDisabled = function(){
	return this.disabled; 
};
WrappedCheckBoxField.prototype.setValue = function (value) {
	if(this.field){
		this.field.setValue(value);
		this.value = value;
	}
	return this;
};
WrappedCheckBoxField.prototype.getValue = function (){
	return this.value;
};
WrappedCheckBoxField.prototype.setOptions = function (options){
	if(this.field){
		this.field.setOptions(options);		
		this.options = options;
	}
	return this;
};
WrappedCheckBoxField.prototype.getOptions = function (){
	if(this.field){
		return this.field.getOptions();	
	}
	return this;
};
var WrappedRadioGroupField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "radioButtonGroup"
	}));
	this.options = null;
	this.disabled = null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValueToBoolean",		
		"required",
		"hint",
		"mode"
		//"disabled"
		//"dependentFields"		
		//"sqlConnection",
		//"sql"
	];
	
	WrappedRadioGroupField.prototype.init.call(this, options);
};

WrappedRadioGroupField.prototype = new FieldWrapper();

WrappedRadioGroupField.prototype.type = "radio";

WrappedRadioGroupField.prototype.init = function(options){
	var defaults = {
		readOnly : false,
		value : "",
		options : [],
		disabled : false
	};
	jQuery.extend(true, defaults, options);
	this.setOptions(defaults.options);
};

WrappedRadioGroupField.prototype.setDisabled = function (value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled = value;
	}
	return this;
};

WrappedRadioGroupField.prototype.getDisabled = function (){
	return  this.disabled;
};

WrappedRadioGroupField.prototype.setOptions = function (options){
	if(this.field){
		this.field.setOptions(options);		
		this.options = options;
	}
	return this;
};
WrappedRadioGroupField.prototype.getOptions = function (){
	if(this.field){
		return this.field.getOptions();	
	}
	return this;
};
var WrappedButton = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "button"
	}));
	this.name = null;
	this.label = null;
	this.javascriptExecute = null;
	this.colspan = null;
	this.properties = [
		//"name",
		"id",
		"label",
		//"javascriptExecute",
		"colSpan"

		//"variable"
	];
	WrappedButton.prototype.init.call(this, options);
};


WrappedButton.prototype = new FieldWrapper();

WrappedButton.prototype.type = "button";

WrappedButton.prototype.init = function (options){
	var defaults = {
		name : PMUI.generateUniqueId(),
		label : "Button",
		colspan :12,
		javascriptExecute : ""
	};

	jQuery.extend(true, defaults, options);
	
	this.setName(defaults.name);
	this.setLabel(defaults.label);
	this.setColspan(defaults.colspan);
	this.setJavaScriptExecute(defaults.javascriptExecute);
};

WrappedButton.prototype.setName = function (name){	
	this.name = name;
	return this;
};

WrappedButton.prototype.getName = function (){
	return this.name;
};

WrappedButton.prototype.setLabel = function (label){
	if(this.field){
		this.field.setValue(label);
		this.label = label;
	}
	return this;
};

WrappedButton.prototype.getLabel = function (){
	return this.label;
};

WrappedButton.prototype.setColspan = function(colspan){
	this.colspan = colspan;
	return this;
};
WrappedButton.prototype.getColspan = function(){
	return this.colspan;
};

WrappedButton.prototype.setJavaScriptExecute = function(script){
	this.javascriptExecute = script;
	return this;
};

WrappedButton.prototype.getJavaScriptExecute = function (){
	return this.javascriptExecute;
};

var WrappedDateTimerField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "calendar"
	}));
	this.width = null;
	this.mask  = null;
	this.value = null;
	this.typeOfDateRange = null;
	this.editable = null;
	this.pickDate = null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValue",
		"required",
		"hint",
		//"dependentFields",
		"mask",
		//"typeOfDateRange",
		//"editable",
		"pickType",
		"mode"
		//"disabled"
		//"width"
	];

	WrappedDateTimerField.prototype.init.call(this, options);
};

WrappedDateTimerField.prototype = new FieldWrapper();
WrappedDateTimerField.prototype.type = "datetime";

WrappedDateTimerField.prototype.init = function(options){
	var defaults = {
		width : "100%",
		mask : "",
		editable : false,
		typeOfDateRange :[],
		value : "",
		pickDate : 'datetime',
		disabled : false
	};
	jQuery.extend(true, defaults, options);
	
	this.setWidth(defaults.width);
	this.setMask(defaults.mask);
	this.setEditable(defaults.editable);
	this.setTypeOfDateRange(defaults.typeOfDateRange);
	this.setPickDate(defaults.pickDate);
	this.setDisabled(defaults.disabled);
};

WrappedDateTimerField.prototype.setWidth = function (width){
	if(this.field){
		this.field.setWidth(width);		
	}
	this.width = width;
	return this;
};

WrappedDateTimerField.prototype.getWidth = function (){
	return this.width;
};

WrappedDateTimerField.prototype.setMask = function (mask) {
	this.mask = mask;
	return this;
};

WrappedDateTimerField.prototype.getMask = function () {
	return this.mask;
};

WrappedDateTimerField.prototype.setEditable = function(value){
	this.editable = value;
	return this;
};

WrappedDateTimerField.prototype.getEditable = function(){
	return this.editable;
};

WrappedDateTimerField.prototype.setTypeOfDateRange = function(options){
	this.typeOfDateRange = options;
	return this;
};

WrappedDateTimerField.prototype.getTypeOfDateRange = function(){
	return JSON.stringify(this.typeOfDateRange);
};

WrappedDateTimerField.prototype.setValue = function (value){
	if(this.field){
		if(value){
			this.field.enable(value);
		}else{
			this.field.disabled(value);
		}		
		this.disabled = value;
	}	
	return this;
};	

WrappedDateTimerField.prototype.getValue = function (){
	return this.value;
};


WrappedDateTimerField.prototype.setPickDate = function(value){
	this.pickDate = value;
	return this;
};
WrappedDateTimerField.prototype.getPickDate = function(){
	return this.pickDate;
};

WrappedDateTimerField.prototype.setDisabled = function(value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.value = value;
	}
	return this;
};

WrappedDateTimerField.prototype.getDisabled = function(){
	return this.disabled; 
};
var WrappedTextAreaField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "textArea"
	}));
	this.disabled = null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValue",
		"required",
		"hint",
		//"disabled"
		"mode"		
		//"dependentFields"
		//"formula",
		//"sqlConnection",
		//"sql"
		//"readOnly",
	];
	WrappedTextAreaField.prototype.init.call(this, options);
};

WrappedTextAreaField.prototype = new FieldWrapper();
WrappedTextAreaField.prototype.type = "textarea";

WrappedTextAreaField.prototype.init = function(options){
	var defaults = {
		readOnly : false
	};
	jQuery.extend(true, defaults, options);
	this.setDisabled(defaults.readOnly);
};

WrappedTextAreaField.prototype.setDisabled = function(value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled = value;
	}
	return this;
};

WrappedTextAreaField.prototype.getDisabled = function(){
	return this.disabled; 
};

var WrappedLabelField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "label"
	}));
	this.formula = null;
	this.textTransform = null;
	this.validate = null;
	this.mask = null;
	this.maxLength =null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValue",
		"hint",
		//"dependentFields",
		"textTransform",
		"validate",
		"maxLength"
		//"readOnly",
		//"width",
		//"formula",
		//"sqlConnection",
		//"sql"
	];
	WrappedLabelField.prototype.init.call(this, options);
};

WrappedLabelField.prototype = new FieldWrapper();
WrappedLabelField.prototype.type = "label";

WrappedLabelField.prototype.init = function(options){
	var defaults = {
		readOnly : true,
		formula : "",
		textTransform : "none",
		validate : "any",
		maxLength : 100
	};
	jQuery.extend(true, defaults, options);
	this.setFormula(defaults.formula);
	this.setTextTransform(defaults.textTransform);
	this.setValidate(defaults.validate);
	this.setMaxLength(defaults.maxLength);
};

WrappedLabelField.prototype.setFormula = function(formula){
	this.formula = formula;
	return this;
};

WrappedLabelField.prototype.getFormula = function(){
	return this.formula;
};

WrappedLabelField.prototype.setTextTransform = function (values) {
	this.textTransform = values;
	return this;
};

WrappedLabelField.prototype.getTextTransform = function () {
	return this.textTransform;
};

WrappedLabelField.prototype.setValidate = function (validate) {
	this.validate = validate;
	return this;
};

WrappedLabelField.prototype.getValidate = function () {
	return this.validate;
};

WrappedLabelField.prototype.setMaxLength = function (maxLength) {
	this.maxLength = maxLength;
	return this;
};

WrappedLabelField.prototype.getMaxLength = function () {
	return this.maxLength;
};

var WrappedTitleField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "title"
	}));
	this.properties = [
		"colSpan",
		"name",
		"id",
		"label"
		//"sql"
		//"sqlConnection",
	];
	WrappedTitleField.prototype.init.call(this, options);
};

WrappedTitleField.prototype = new FieldWrapper();
WrappedTitleField.prototype.type = "title";

WrappedTitleField.prototype.init = function(options){
	var defaults = {
		label : '-Title-',
		name : '',
		colSpan : 12
	};
	jQuery.extend(true, defaults, options);
	this.setLabel(defaults.label);
};

WrappedTitleField.prototype.setLabel = function (label) {
	if(this.field){
		this.field.setLabel(label);	}
	this.label = label;
	return this;
};
var WrappedButtonSubmit = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "submit"
	}));
	this.name = null;
	this.label = null;
	this.javascriptExecute = null;
	this.colspan = null;
	this.properties = [
		//"name",
		"id",
		"label",
		//"javascriptExecute",
		"colSpan"

		//"variable"
	];
	WrappedButtonSubmit.prototype.init.call(this, options);
};


WrappedButtonSubmit.prototype = new FieldWrapper();

WrappedButtonSubmit.prototype.type = "submit";

WrappedButtonSubmit.prototype.init = function (options){
	var defaults = {
		name : PMUI.generateUniqueId(),
		label : "Submit",
		colspan :12,
		javascriptExecute : ""
	};

	jQuery.extend(true, defaults, options);
	
	this.setName(defaults.name);
	this.setLabel(defaults.label);
	this.setColspan(defaults.colspan);
	this.setJavaScriptExecute(defaults.javascriptExecute);
};

WrappedButtonSubmit.prototype.setName = function (name){	
	this.name = name;
	return this;
};

WrappedButtonSubmit.prototype.getName = function (){
	return this.name;
};

WrappedButtonSubmit.prototype.setLabel = function (label){
	if(this.field){
		this.field.setValue(label);
		this.label = label;
	}
	return this;
};

WrappedButtonSubmit.prototype.getLabel = function (){
	return this.label;
};

WrappedButtonSubmit.prototype.setColspan = function(colspan){
	this.colspan = colspan;
	return this;
};
WrappedButtonSubmit.prototype.getColspan = function(){
	return this.colspan;
};

WrappedButtonSubmit.prototype.setJavaScriptExecute = function(script){
	this.javascriptExecute = script;
	return this;
};

WrappedButtonSubmit.prototype.getJavaScriptExecute = function (){
	return this.javascriptExecute;
};

var WrappedSubtitleField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "subtitle"
	}));
	this.properties = [
		"colSpan",
		"name",
		"id",
		"label"
		//"sql"
		//"sqlConnection",
	];
	WrappedSubtitleField.prototype.init.call(this, options);
};

WrappedSubtitleField.prototype = new FieldWrapper();
WrappedSubtitleField.prototype.type = "subtitle";

WrappedSubtitleField.prototype.init = function(options){
	var defaults = {
		label : '-Subtitle-',
		name : '',
		colSpan : 12
	};
	jQuery.extend(true, defaults, options);
	this.setLabel(defaults.label);
};

WrappedSubtitleField.prototype.setLabel = function (label) {
	if(this.field){
		this.field.setLabel(label);	}
	this.label = label;
	return this;
};
var WrappedSuggestField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "suggest"
	}));
	this.options = null;
	this.disabled = null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValue",
		"required",
		"hint",
		"dependentFields",
		//"textTransform",
		"mask",
		"maxLength",
		//"sql",
		//"disabled"
		"mode"
	];
	WrappedSuggestField.prototype.init.call(this, options);
};

WrappedSuggestField.prototype = new FieldWrapper();
WrappedSuggestField.prototype.type = "suggest";

WrappedSuggestField.prototype.init = function(options){
	var defaults = {
		label : '[Sugges Field]',
		name : '',
		colSpan : 12,
		disabled : false,
		options : []
	};
	this.options = [];
	jQuery.extend(true, defaults, options);
	this.setLabel(defaults.label);
	this.setDisabled(defaults.disabled);
	this.setOptions(defaults.options);
};

WrappedSuggestField.prototype.setOptions = function (options){
	if(jQuery.isArray(options)){
		for (var i = 0 ; i < options.length ; i+=1){
			this.addOption(options[i]);
		}
	}
	return this;
};
WrappedSuggestField.prototype.addOption = function (option){
	this.options.push(option);
	return this;
};

WrappedSuggestField.prototype.getOptions = function(){
	return this.options;
};

WrappedSuggestField.prototype.setDisabled = function (value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled = value;
	}
	return this;
};

WrappedSuggestField.prototype.getDisabled = function () {
	return this.disabled;
};

WrappedSuggestField.prototype.setTextTransform = function (values) {
	this.textTransform = values;
	return this;
};

WrappedSuggestField.prototype.getTextTransform = function () {
	return this.textTransform;
};


WrappedSuggestField.prototype.setMask = function (mask) {
	this.mask = mask;
	return this;
};

WrappedSuggestField.prototype.getMask = function () {
	return this.mask;
};

WrappedSuggestField.prototype.setMaxLength = function (maxLength) {
	this.maxLength = maxLength;
	return this;
};

WrappedSuggestField.prototype.getMaxLength = function () {
	return this.maxLength;
};

WrappedSuggestField.prototype.setFormula = function(formula){
	this.formula = formula;
	return this;
};

WrappedSuggestField.prototype.getFormula = function(){
	return this.formula;
};

var WrappedYesNoRadioGroupField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "radioButtonGroup"
	}));
	this.options = null;
	this.disabled = null;
	this.properties = [
		"variable",
		"dataType",
		"colSpan",
		"name",
		"id",
		"label",
		"defaultValueToBoolean",		
		"required",
		"hint",
		"mode"
		//"disabled"
		//"dependentFields"		
		//"sqlConnection",
		//"sql"
	];
	
	WrappedYesNoRadioGroupField.prototype.init.call(this, options);
};

WrappedYesNoRadioGroupField.prototype = new FieldWrapper();

WrappedYesNoRadioGroupField.prototype.type = "radio";

WrappedYesNoRadioGroupField.prototype.init = function(options){
	var defaults = {
		readOnly : false,
		value : "",
		options : [],
		disabled : false,
		defaultValue : '1'
	};
	jQuery.extend(true, defaults, options);
	this.setOptions(defaults.options);
	this.setDefaultValue(defaults.defaultValue);
};

WrappedYesNoRadioGroupField.prototype.setDisabled = function (value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled = value;
	}
	return this;
};

WrappedYesNoRadioGroupField.prototype.getDisabled = function (){
	return  this.disabled;
};

WrappedYesNoRadioGroupField.prototype.setOptions = function (options){
	if(this.field){
		this.field.setOptions(options);		
		this.options = options;
	}
	return this;
};
WrappedYesNoRadioGroupField.prototype.getOptions = function (){
	if(this.field){
		return this.field.getOptions();	
	}
	return this;
};

WrappedYesNoRadioGroupField.prototype.setDefaultValueForBoolean = function (defaultValue){
	if(this.field){
		this.defaultValue = defaultValue;
		this.field.setValue(defaultValue);
	}
	return this;
};
WrappedYesNoRadioGroupField.prototype.getDefaultValueForBoolean = function (){
	return this.defaultValue;
};
var WrappedYesNoDropDownField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "dropDownList"
	}));

	this.disabled = null;
	this.includeOptionGroup = null;
	this.handler = null;
	this.options = null;

	WrappedYesNoDropDownField.prototype.init.call(this, options);
};

WrappedYesNoDropDownField.prototype = new FieldWrapper();

WrappedYesNoDropDownField.prototype.type = "dropdown";

WrappedYesNoDropDownField.prototype.properties = [
	"variable",
	"dataType",
	"colSpan",
	"name",
	"id",
	"label",
	"defaultValueToBoolean",
	"required",
	"hint",
	"dependentFields",
	//"includeOptionGroup",
	//"disabled"
	"mode"
	//"readOnly",
	//"sqlConnection",
	//"sql",
];

WrappedYesNoDropDownField.prototype.init = function(options){
	var defaults = {
		disabled : false,
		includeOptionGroup : false,
		options : [],
		defaultValue : '1'
	};
	jQuery.extend(true, defaults, options);

	this.setDisabled(defaults.disabled);
	this.setIncludeOptionGroup(defaults.includeOptionGroup);
	this.setOptions(defaults.options);
	this.setDefaultValue(defaults.defaultValue);
};

WrappedYesNoDropDownField.prototype.setDisabled = function(value){
	if(this.field){
		if(value){
			this.field.disable(value);
		}else{
			this.field.enable(value);
		}		
		this.disabled= value;
	}
	return this;
};

WrappedYesNoDropDownField.prototype.getDisabled = function(){
	return this.disabled; 
};

WrappedYesNoDropDownField.prototype.setIncludeOptionGroup = function (value){
	this.includeOptionGroup = value;
	return this;
};

WrappedYesNoDropDownField.prototype.getIncludeOptionGroup = function (value){
	return this.includeOptionGroup;
};

WrappedYesNoDropDownField.prototype.setOptions = function (options){
	if(this.field){
		this.field.setOptions(options);		
		this.options = options;
	}
	return this;
};
WrappedYesNoDropDownField.prototype.addOption = function (option){
	if(this.field) {
		this.field.addOption(option);
	}
	return this;
};

WrappedYesNoDropDownField.prototype.getValue = function (){
	if(this.field){
		return this.field.getValue();
	}
	return this;
};

WrappedYesNoDropDownField.prototype.setValue = function (value){
	if(this.field){
		this.field.setValue(value);
	}
	return this;
};
WrappedYesNoDropDownField.prototype.getOptions = function (){
	if(this.field){
		return this.field.getOptions();
	}
	return this;
};

WrappedYesNoDropDownField.prototype.setDefaultValueForBoolean = function (defaultValue){
	if(this.field){
		this.defaultValue = defaultValue;
		this.field.setValue(defaultValue);
	}
	return this;
};
WrappedYesNoDropDownField.prototype.getDefaultValueForBoolean = function (){
	return this.defaultValue;
};
var WrappedGridField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "grid"
	}));
	this.properties = [
		"colSpan",
		"name",
		"id",
        "label",
        "required",
        "rows",
        "mode",
        "hint",
        "pager"
	];
	this.onDropHandlerNewCell = null;
	this.pager = null;
	this.rows = null;
	this.columns = null;
	this.onClickItemConfigHandler = null;
	this.onAddColum = null;
	/*for dependency*/
	this.listOfColumnsForDependecy = null;
	this.windowOfDependency = null;
	this.listColumnGrid = null;
	this.dependentColumnGrid = null;
	this.panelRigth = null;
	this.panelLeft = null;
	this.panelConatinerGrid = null;
	this.listValidColumns = null;
	this.selectedColumn = null;
	this.dependentColumns = null;
	WrappedGridField.prototype.init.call(this, options);
};

WrappedGridField.prototype = new FieldWrapper();
WrappedGridField.prototype.type = "grid";
WrappedGridField.prototype.listOfEligibleForDependecy = [
	"suggest",
	"text",
	"dropdown"
];

WrappedGridField.prototype.init = function(options){
	var defaults = {
		name : '-Field-grid-',
		colSpan : 12,
		onDropHandlerNewCell : null,
		pager : false,
		rows : 1,
		columns : [],
		onClickItemConfigHandler : null,
		menuItems : null,
		onAddColum : null
	};
	this.columns = new PMUI.util.ArrayList();

	this.listOfColumnsForDependecy = new PMUI.util.ArrayList();	
	this.dependentColumns = [];
	jQuery.extend(true, defaults, options);
	this.setOnClickItemConfigHandler(defaults.onClickItemConfigHandler);
	this.setOnDropHandlerNewCell(defaults.onDropHandlerNewCell);
	this.setColumns(defaults.columns);
	this.setPager(defaults.pager);
	this.setRows(defaults.rows);
	this.setOnAddColum(defaults.onAddColum);
};

WrappedGridField.prototype.setOnAddColum = function (handler) {
	if ( !(typeof handler === 'function' || handler === null ) ) {
		throw new error ("WrappedGridField.setMenuItems(): the parameter is not valid, should be a funtion type")
	}
	if (this.field){
		this.menuItems  = handler;
		this.field.setOnAddColumn(handler);
	}
	return this;
};
WrappedGridField.prototype.setOnClickItemConfigHandler = function (handler) {
	if (this.field) {
		this.field.setOnClickItemConfigHandler(handler);
	}
	this.onClickItemConfigHandler = handler;
	return this;
};

WrappedGridField.prototype.setRequired = function (value){
	if(this.field){
		//this.field.setRequired(value);
	}
	this.required = value;
	return this;
};

WrappedGridField.prototype.setMode = function (mode){
	this.mode = mode;
	if(this.field){
		//this.activeMode(mode);
	}
	return this;
};


WrappedGridField.prototype.setDefaultValue = function (defaultValue){
	if(this.field){
		this.defaultValue = defaultValue;
		//this.field.setValue(defaultValue);
	}
	return this;
};

WrappedGridField.prototype.setName = function (name){
	if(this.field){
		//this.field.setName(name);
	}
	this.name = name;
	return this;
};

WrappedGridField.prototype.setLabel = function (label) {
	this.label = label;
	return this;
};

WrappedGridField.prototype.getHTML  = function(){
	if(!this.html) {
		this.html = this.field.getHTML();
		PMUI.linkToPMUIObject(this.html, this);
	}
	this.setColSpan(this.getColSpan());
	return this.html;
};

WrappedGridField.prototype.setOnDropHandlerNewCell = function (handler) {
	if ( this.field ) {
		this.field.setOnDropHandlerNewCell(handler);
	}
	this.onDropHandlerNewCell = handler;
	return this;
};

WrappedGridField.prototype.setPager = function ( value ) {
	if ( typeof value === 'boolean' ) {
		this.pager = value; 
	}
	return this;
};

WrappedGridField.prototype.getPager = function (){
	return this.pager;
};

WrappedGridField.prototype.setRows = function (rows) {
	this.rows = rows;
	return this;
};

WrappedGridField.prototype.getRows = function () {
	return this.rows;
};

WrappedGridField.prototype.getData = function (){
	var i, data = {};
	for (i = 0 ; i< this.properties.length ; i+=1) {
		if (this.properties[i] === 'colSpan') {
			if (this.getParent()){
				data[this.properties[i]] = this.getParent().colSpan;	
			}
		} else {
			data[this.properties[i]] = this[this.properties[i]];	
		}
	}
	data.columns = this.field.getData();
	return data;
};

WrappedGridField.prototype.setColumns = function (columns) {
	var i;
	this.clearColumns();
	for ( i = 0 ; i < columns.length ; i+=1 ) {
		this.columns.insert(columns[i]);
	}
	if (this.field){
		this.field.setItems(columns);
	}
	return this;
};

WrappedGridField.prototype.clearColumns = function () {
	this.columns.clear();
	this.field.items.clear();
	return this;
};

WrappedGridField.prototype.addColumn = function (column){
	if(this.field) {
		this.field.addItem(column);
	}
	return this;
};

WrappedGridField.prototype.setListEligibleColumns = function (columns) {
	var i;
	this.listOfColumnsForDependecy.clear();
	for ( i = 0 ;  i < columns.length ; i+=1 ) {
		this.listOfColumnsForDependecy.insert(columns[i])
	}
	return this;
};

WrappedGridField.prototype.getEligibleForDependecy = function (gridField){
	var that = this, index1, index2;
	return gridField.getItems().filter(function(column){
			if ( that.listOfEligibleForDependecy.indexOf(column.getControlType())!== -1){
				if ( that.selectedColumn !== column.getItem(0) ) {
					index1 = that.selectedColumn.dependentColumns.indexOf(column.getControlName());
					index2 = that.selectedColumn.getDirectDependence().indexOf(column.getControlName());
					if ( index1 === -1 && index2 === -1 ) {
						return column;
					}
				}
			}
		});
};

WrappedGridField.prototype.getDependentColumns = function (gridField) {
	var that = this, i, index, dependentColumns = [];
	if (this.selectedColumn.getDependentColumns().length){
		dependentColumns = gridField.getItems().filter(function (column) {
			if ( that.listOfEligibleForDependecy.indexOf(column.getControlType())!== -1) {
				if ( that.selectedColumn !== column.getItem(0) ) {
					index = that.selectedColumn.dependentColumns.indexOf(column.getControlName());
					if (index !== -1){
						return column.getControl();	
					}
				}
			}
		});
	}
	return dependentColumns;
};

WrappedGridField.prototype.showDependentColumns = function (targetColumn) {
	var i, that = this, gridField, listOfValidColumns;
	this.selectedColumn = targetColumn;
	this.createWindowOfDependency();
	if (this.listOfEligibleForDependecy.indexOf(targetColumn.type) !== -1) {
		gridField = targetColumn.getContainer();
		this.listValidColumns = this.getEligibleForDependecy(gridField); 
		this.listColumnGrid.clearItems();
		this.dependentColumnGrid.clearItems();
		if ( this.listValidColumns.length ) {
	        for ( i = 0 ; i < this.listValidColumns.length ; i+=1 ) {
	            this.listColumnGrid.addDataItem({
	                name : this.listValidColumns[i].getControlName(),
	                title : this.listValidColumns[i].getControlTitle(),
	                type : this.listValidColumns[i].getControlType()
	            })
	        }
	    }
	    this.dependentColumns = this.getDependentColumns(gridField);
	    if ( this.dependentColumns.length ) {
	        for ( i = 0 ; i < this.dependentColumns.length ; i+=1 ) {
	            this.dependentColumnGrid.addDataItem({
	                name : this.dependentColumns[i].getControlName(),
	                title : this.dependentColumns[i].getControlTitle(),
	                type : this.dependentColumns[i].getControlType()
	            })
	        }	
	    }
	} else {
		this.listColumnGrid.clearItems();
		this.dependentColumnGrid.clearItems();
	}
    this.windowOfDependency.open();
};
WrappedGridField.prototype.createListColumnGrid = function () {
	var that = this;
	if (!this.listColumnGrid){
		this.listColumnGrid = new PMUI.grid.GridPanel({
	        filterable : true,
	        width : 400,
	        pageSize : 6,
	        columns : [
	            {
	                columnData : 'name',
	                title : 'Name',
	                width : 130,
	                alignmentTitle : 'center',
	                alignmentCell : 'left',
	                dataType : 'string'
	            },{
	                columnData : 'title',
	                title : 'Title',
	                width : 100,
	                alignmentTitle : 'center',
	                alignmentCell : 'left',
	                dataType : 'string'
	            },{
	                columnData : 'type',
	                title : 'Type',
	                width : 60,
	                alignmentCell : 'left',
	                alignmentTitle : 'center',
	                dataType : 'string'                         
	            },{
	                title : 'Add',
	                dataType : 'button',
	                buttonLabel : 'Add',
	                width : 50,
	                onButtonClick : function (row){
	                	that.dependentColumnGrid.addDataItem(row.getData());
	                	row.parent.removeItem(row);
	                }
	            }
	        ],
	        display : 'inline-block',
	        style : {
	            cssClasses : ['pm-listColumnGrid']
	        }
	    });
	}
	return this;
};
WrappedGridField.prototype.createDependentColumnGrid = function (){	
	var that = this;
	if (!this.dependentColumnGrid){
		this.dependentColumnGrid  = new PMUI.grid.GridPanel({
            filterable : true,
            width : 400,
            display : 'inline-block',
            pageSize : 6,
            columns:[
	            {
	                columnData : 'name',
	                title : 'Name',
	                width : 130,
	                alignmentTitle : 'center',
	                alignmentCell : 'left',
	                dataType : 'string'
	            },{
	                columnData : 'title',
	                title : 'Title',
	                width : 100,
	                alignmentTitle : 'center',
	                alignmentCell : 'left',
	                dataType : 'string'
	            },{
	                columnData : 'type',
	                title : 'Type',
	                width : 60,
	                alignmentCell : 'left',
	                alignmentTitle : 'center',
	                dataType : 'string'                         
	            },{
	                title : 'remove',
	                dataType : 'button',
	                buttonLabel : 'Remove',
	                width : 50,
	                onButtonClick : function (row){
	                	that.listColumnGrid.addDataItem(row.getData());
	                	row.parent.removeItem(row);
	                }
	            }
            ],
            style : {
                cssClasses : ['pm-dependentColumnGrid']
            }
        });
	}
	return this;
};
WrappedGridField.prototype.createContainerGrids = function (){
	if (!this.panelLeft){
		this.createListColumnGrid();
		this.panelLeft = new PMUI.core.Panel({
			id : "panelLeft",
            style : {
                cssClasses : ['pm-dependent-panelLeft']
            },
            items : [
            	this.listColumnGrid
            ]			
		});
	}
	if (!this.panelRigth){
		this.createDependentColumnGrid();
		this.panelRigth = new PMUI.core.Panel({
			id : "panelRigth",
            style : {
                cssClasses : ['pm-dependent-panelRight']
            },
            items : [
            	this.dependentColumnGrid
            ]
		});
	}
	if (!this.panelConatinerGrid) {
		this.panelConatinerGrid = new PMUI.core.Panel({	
			id : "panelConatinerGrid", 
			layout: 'hbox',
	        width : 850,
	        style : {
	            cssClasses : ['pm-dependent-columns'],
	            cssProperties :{
	                'marginLeft': '5px'
	            }
	        },
	        items : [
	        	this.panelLeft,
	        	this.panelRigth
	        ]
        });
	}
	return this;
};
WrappedGridField.prototype.createWindowOfDependency = function (){
	var that = this;
	if (!this.windowOfDependency){
		this.createContainerGrids();
		this.windowOfDependency = new PMUI.ui.Window({
	            title: "Add column dependents",
	            width : 880,
	            height : 455,
	            items : [
	            	this.panelConatinerGrid
	            ],
	            style: {
	                cssClasses: ['pmdesigner-dependencyColumnWindow']
	            },
	            buttonPanelPosition : 'top',
	            footerAlign : 'right',
	            footerItems: [
	                {
	                    text: "Save",
	                    handler: function() {
	                    	var i, columName, dependentDataItems;
	                    	dependentDataItems = that.dependentColumnGrid.getData();
	                    	listColumnsDataItems = that.listColumnGrid.getData();
                    		that.updateDependentColumns(dependentDataItems);
                    		that.updateDirectdependentColumns(dependentDataItems, listColumnsDataItems );
	                    	that.windowOfDependency.close();
	                    },
	                    buttonType : 'success',
	                    height : 31
	                },{
	                    pmType: "label",
	                    text: "or"
	                },{
	                    buttonType: "link",
	                    text: "Cancel",
	                    handler: function() {
	                    	console.log("cancel");
	                    },
	                    style : {
	                        cssClasses:['pm-button_dependent_add']
	                    }
	                }
	            ],
	            visibleFooter: true
		});	
	}
	return this;
};

WrappedGridField.prototype.updateDependentColumns = function (dataItems){
	var i;
	this.selectedColumn.dependentColumns = [];
	for ( i = 0 ; i < dataItems.length ; i+=1 ) {
		columName = dataItems[i].name;
		this.selectedColumn.addDependentColumn(columName);
	}
	return this;
};

WrappedGridField.prototype.updateDirectdependentColumns = function (dependentDataItems, listColumnDataItems) {
	var i, columName, columns = this.field.getItems(), columnsAfected = [], columnList = [];
	for ( i = 0 ; i < dependentDataItems.length ; i+=1 ) {
		columName = dependentDataItems[i].name;
		columns.filter(function (item) {
			if (item.getControl() !== null) {
				if (item.getControl().getName() === columName){
					columnsAfected.push(item.getControl());
				}
				return item;	
			}
		});
	}
	for ( i = 0 ; i < columnsAfected.length ; i++ ) {
		columnsAfected[i].addDirectDependence(this.selectedColumn.getName());
	}

	for ( i = 0 ; i < listColumnDataItems.length ; i+=1 ) {
		columName = listColumnDataItems[i].name;
		columns.filter(function (item) {
			if (item.getControl() !== null ) {
				if (item.getControl().getName() === columName){
					columnList.push(item.getControl());
				}
				return item;	
			}
		});
	}
	for ( i = 0 ; i < columnList.length ; i++ ) {
		columnList[i].removeDirectDependence(this.selectedColumn.getName());
	}
	return this;
};
var WrappedFileField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "file"
	}));
	this.multiple = null;
	this.dnd = null;
	this.preview = null;
	this.extensions = null;
	this.size = null;
	this.properties = [
		"colSpan",
		"label",
		"name",
		"id",
		"required",
		"multiple",
		"preview",
		"dnd",
		"extensions",
		"size",
		"hint"
	] 
	WrappedFileField.prototype.init.call(this, options);
};

WrappedFileField.prototype = new FieldWrapper();
WrappedFileField.prototype.type = "file";

WrappedFileField.prototype.init = function(options){
	var defaults = {
		width : "100%",
		multiple : false,
		dnd : false,
		preview : false,
		size : 1,
		extensions : '*'		
	};
	jQuery.extend(true, defaults, options);
	
	this.setMultiple(defaults.multiple);
	this.setDnd(defaults.dnd);
	this.setPreview(defaults.preview);
	this.setSize(defaults.size);
	this.setExtensions(defaults.extensions);
	this.setWidth(defaults.width);
};

WrappedFileField.prototype.setWidth = function (width){
	if(this.field){
		this.field.setWidth(width);		
	}
	this.width = width;
	return this;
};

WrappedFileField.prototype.getWidth = function (){
	return this.width;
};

WrappedFileField.prototype.setMultiple = function (value) {
	if (!(typeof value === 'boolean')){
		throw new Error ("WrappedFileField.setMultiple(): the value is invalid, a value expected type boolean");
	}
	this.multiple = value;
	return this;
};

WrappedFileField.prototype.getMultiple = function () {
	return this.multiple;
};

WrappedFileField.prototype.setDnd = function (value) {
	if (!(typeof value === 'boolean')){
		throw new Error ("WrappedFileField.setDnd(): the value is invalid, a value expected type boolean");
	}
	this.dnd = value;
	return this;
};

WrappedFileField.prototype.getDnd = function () {
	return this.dnd;
};

WrappedFileField.prototype.setPreview = function (value) {
	if (!(typeof value === 'boolean')){
		throw new Error ("WrappedFileField.setPreview(): the value is invalid, a value expected type boolean");
	}
	this.preview = value;
	return this;
};

WrappedFileField.prototype.getPreview = function () {
	return this.preview;
};

WrappedFileField.prototype.setSize = function (size) {
	var size = parseInt(size,10); 
	if (!(typeof size === 'number')){
		throw new Error ("WrappedFileField.setSize(): the value is invalid, a value expected type number");
	}
	this.size = size;
	return this;
};

WrappedFileField.prototype.getSize = function () {
	return this.size;
};

WrappedFileField.prototype.setExtensions = function (extensions) {
	if (!(typeof extensions === 'string')){
		throw new Error ("WrappedFileField.setExtensions(): the value is invalid, a value expected type string");
	}
	this.extensions = extensions;
	return this;
};

WrappedFileField.prototype.getExtensions = function () {
	return this.extensions;
};

WrappedFileField.prototype.getHTML = function (){
	FieldWrapper.prototype.getHTML.call(this);
	if (this.html){
		this.field.controls[0].html.onclick = function (e){
			e.preventDefault();
		}
	}	
	this.field.controls[0].setWidth('100%');
	return this.html;
};
var WrappedImageField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "image"
	}));

	this.shape = null;
	this.alt = null;
	this.comment = null;
	this.src = null;

	this.properties = [
		"colSpan",
		"name",
		"id",
		"label",
		"shape",
		"alt",
		"comment",
		"src",
		"hint"
	];

	WrappedImageField.prototype.init.call(this, options);
};

WrappedImageField.prototype = new FieldWrapper();
WrappedImageField.prototype.type = "image";

WrappedImageField.prototype.init = function(options){
	var defaults = {
			width : "100%",
			shape : "thumbnail",
			alt : "",
			comment : "",
			src : ""
		};
	jQuery.extend(true, defaults, options);

	this.setShape(defaults.shape);
	this.setAlt(defaults.alt);
	this.setComment(defaults.comment);
	this.setSrc(defaults.src);
};

WrappedImageField.prototype.setWidth = function (width){
	if(this.field){
		this.field.setWidth(width);		
	}
	this.width = width;
	return this;
};

WrappedImageField.prototype.getWidth = function (){
	return this.width;
};

WrappedImageField.prototype.setShape = function(shape){
	if ( !(typeof shape === "string") ) {
		throw new Error ("WrappedImageField.setShape(): the value is invalid, a value expected type string");
	}
	this.shape = shape;
	return this;
};

WrappedImageField.prototype.getShape = function(){
	return this.shape;
};

WrappedImageField.prototype.setAlt = function(alt){
	if ( !(typeof alt === "string") ) {
		throw new Error ("WrappedImageField.setAlt(): the value is invalid, a value expected type string");
	}
	this.alt = alt;
	return this;
};

WrappedImageField.prototype.getAlt = function(){
	return this.alt;
};

WrappedImageField.prototype.setComment = function(comment){
	if ( !(typeof comment === "string") ) {
		throw new Error ("WrappedImageField.setComment(): the value is invalid, a value expected type string");
	}
	if (this.field) {
		this.field.setComment(comment);
	}
	this.comment = comment;
	return this;
};

WrappedImageField.prototype.getComment = function(){
	return this.comment;
};

WrappedImageField.prototype.setSrc = function(src){
	if ( !(typeof src === "string") ) {
		throw new Error ("WrappedImageField.setSrc(): the value is invalid, a value expected type string");
	}
	this.src = src;
	return this;
};

WrappedImageField.prototype.getSrc = function(){
	return this.src;
};
var WrappedLinkField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "link"
	}));

	this.href = null;
	this.value = null;

	this.properties = [
		"colSpan",
		"name",
		"id",
		/*"value",*/
		"label",
		"href",		
		"hint"
	];

	WrappedLinkField.prototype.init.call(this, options);
};

WrappedLinkField.prototype = new FieldWrapper();
WrappedLinkField.prototype.type = "link";

WrappedLinkField.prototype.init = function(options){
	var defaults = {
			width : "100%",
			href : ""
		};
	jQuery.extend(true, defaults, options);
	this.setHref(defaults.href);
};

WrappedLinkField.prototype.setWidth = function (width){
	if(this.field){
		this.field.setWidth(width);		
	}
	this.width = width;
	return this;
};

WrappedLinkField.prototype.getWidth = function (){
	return this.width;
};

WrappedLinkField.prototype.setHref = function(href){
	if ( !(typeof href === "string") ) {
		throw new Error ("WrappedLinkField.setHref(): the value is invalid, a value expected type string");
	}
	this.href = href;
	this.value = href;
	if (this.field){
		this.field.setUrl(href);
	}
	return this;
};

WrappedLinkField.prototype.getHref = function(){
	return this.href;
};

WrappedLinkField.prototype.getData = function () {
	var i, data = {};
	for (i = 0 ; i< this.properties.length ; i+=1) {
		if (this.properties[i] === 'colSpan') {
			data[this.properties[i]] = this.getParent().colSpan;
		}else {
			if (this.properties[i] === "href"){
				data["value"] = this[this.properties[i]]; 
			}
			data[this.properties[i]] = this[this.properties[i]];	
		}
	}
	return data;
};
var WrappedTextLabelField = function (options){
	FieldWrapper.call(this, jQuery.extend(true,options,{
		field : "textLabel"
	}));
	this.properties = [
		"colSpan",
		"name",
		"id",
		"label"
		//"sql"
		//"sqlConnection",
	];
	WrappedTextLabelField.prototype.init.call(this, options);
};

WrappedTextLabelField.prototype = new FieldWrapper();
WrappedTextLabelField.prototype.type = "annotation";

WrappedTextLabelField.prototype.init = function(options){
	var defaults = {
		label : 'comment...',
		name : '',
		colSpan : 12
	};
	jQuery.extend(true, defaults, options);
	this.setLabel(defaults.label);
};

WrappedTextLabelField.prototype.setLabel = function (label) {
	if(this.field){
		this.field.setLabel(label);	}
	this.label = label;
	return this;
};
var WrappedFormField = function (options) {
    FieldWrapper.call(this, jQuery.extend(true, options, {
        field: "form"
    }));
    this.onEditClick = null;
    this.properties = [
        "colSpan",
        "name",
        "id",
        "label"
    ];
    WrappedFormField.prototype.init.call(this, options);
};

WrappedFormField.prototype = new FieldWrapper();
WrappedFormField.prototype.type = "subform";

WrappedFormField.prototype.init = function (options) {
    var defaults = {
        label: '[New Form]',
        name: '',
        colSpan: 12,
        onEditClick: null
    };
    jQuery.extend(true, defaults, options);
    this.setLabel(defaults.label);
    this.setOnEditClick(defaults.onEditClick);
};

WrappedFormField.prototype.setOnEditClick = function (handler) {
    if (!(typeof handler === 'function' || handler === null)) {
        throw new Error(' the value handler should be type function');
    }
    this.onEditClick = handler;
    if (this.field) {
        this.field.onEditClick = handler;
    }
    return this;
};

WrappedFormField.prototype.setLabel = function (label) {
    if (this.field) {
        this.field.setLabel(label);
    }
    this.label = label;
    return this;
};

var PMFieldFactory = new PMUI.util.Factory({
	products: {
		"text": WrappedTextField,
		"button": WrappedButton,
		"checkbox": WrappedCheckBoxField,
		"datetime": WrappedDateTimerField,
		"dropdown": WrappedDropDownField,
		"radio": WrappedRadioGroupField,
		"textarea": WrappedTextAreaField,	
		"label" : WrappedLabelField,
		"submit" : WrappedButtonSubmit,
		"button" : WrappedButton,
		"title" : WrappedTitleField,
		"subtitle" : WrappedSubtitleField,
		"suggest" : WrappedSuggestField,
		"yesnodropdown" : WrappedYesNoDropDownField,
		"yesnoradio" :WrappedYesNoRadioGroupField,
		"grid" : WrappedGridField,
		"file" : WrappedFileField,
		"image" : WrappedImageField,
		"link" : WrappedLinkField,
		"annotation" : WrappedTextLabelField,
		"subform" : WrappedFormField
		},
	defaultProduct: "text"
});
var PMListItem = function(options){
	PMUI.item.ListItem.call(this,options);
	this.textType = null;
	this.textName = null;
	this.variable = null;
	this.buttonEdit = null;
	this.onButtonEditClick = null;
	PMListItem.prototype.init.call(this, options);

};
PMListItem.prototype = new PMUI.item.ListItem();

PMListItem.prototype.init = function(options){
	var defaults = {
		textType : '[undefined-type]',
		textName : '[undefined-name]',
		variable: null,
		onButtonEditClick : null 
	};
	this.buttonEdit = new PMUI.ui.Button({
		text : 'edit',
		style : {
			cssClasses : ['pmListItem-buttonEdit']
		},
		height : 20,
		buttonType : 'success',
		parent : this
	});
	jQuery.extend(true, defaults, options);

	this.setTextType(defaults.textType);
	this.setTextName(defaults.textName);
	this.setVariable(defaults.variable);
	this.setOnButtonEditClick(defaults.onButtonEditClick);
};

PMListItem.prototype.setOnButtonEditClick  = function (handler) {
	if ( !(typeof handler === 'function' || handler === null) ){
		throw new Error ('PMListItem.setOnButtonEditClick(): the value handler should be type function');
	}
	this.onButtonEditClick = handler;
	this.buttonEdit.setHandler(this.onButtonEditClickHandler());
	return this;
};
PMListItem.prototype.onButtonEditClickHandler = function () {
	var that = this;
	return function(){
		if (typeof that.onButtonEditClick == 'function') {
			that.onButtonEditClick(that, that.variable, this);
		}
	};
};

PMListItem.prototype.setVariable = function (variable){
	if(variable === null || variable instanceof PMVariable) {
		this.variable = variable;
	} else if(typeof variable === 'object') {
		this.variable = new PMVariable(variable);
	} else {
		throw new Error('setVariable(): The parametermust be an instance of PMVariable, an object literal or null.');
	}
	return this;
};

PMListItem.prototype.getVariable = function (){
	if(this.variable){
		return this.variable;
	}
	return null;
};

PMListItem.prototype.setTextType = function(type){
	if(typeof type !== 'string'){
		throw new error('setTextType(), the parameter sent is not valid');
	}
	this.textType = type;
	this.text = this.textType + (this.textName || '');
	if(this.dom.typeContent){
		this.dom.typeContent.innerHTML = "["+this.textType+"]";
	}
	return this;
};

PMListItem.prototype.getTextType = function(){
	return this.textType;
};

PMListItem.prototype.setTextName = function (name){
	if(typeof name !== 'string'){
		throw new error('setTextName(), the parameter sent is not valid');
	}
	this.textName = name;
	this.text = this.textName + (this.textType || '');
	if(this.dom.nameContent){
		this.dom.nameContent.innerHTML = name;
		this.dom.nameContent.title = name;
	}
	return this;
};

PMListItem.prototype.getTextName = function(){
	return this.textName;	
};
/*
PMListItem.prototype.setTextLabel = function (label){
	if(typeof label !== 'string'){
		throw new error('setTextLabel(), the parameter sent is not valid');
	}
	this.textLabel = label;
	if(this.dom.labelContent){
		this.dom.labelContent.innerHTML = this.textLabel+"]";
		this.dom.labelContent.title = this.textLabel;
	}
	return this;
};
PMListItem.prototype.getTextLabel = function (){
	this.textLabel;
};*/
PMListItem.prototype.createHTML = function(){
	var nameContent, typeContent, labelContent,container1, container2;
	var textContainer1, textContainer2;	
	if(this.html) {
		return this.html;
	}

	PMUI.core.Item.prototype.createHTML.call(this);
	
	textContainer1 = PMUI.createHTMLElement('div');
	textContainer1.className = 'pmTextContainer1';
	textContainer2 = PMUI.createHTMLElement('div');
	textContainer2.className = 'pmTextContainer2';

	nameContent = PMUI.createHTMLElement('span');
	nameContent.className = 'pmNameContent';

	typeContent = PMUI.createHTMLElement('span');
	typeContent.className = 'pmTypeContent';
	/*
	labelContent = PMUI.createHTMLElement('span');
	labelContent.className = 'pmLabelContent';
	*/
	container1 = PMUI.createHTMLElement('span');
	container2 = PMUI.createHTMLElement('span');
	
	iconContainer = PMUI.createHTMLElement('i');
	iconContainer.className = 'pmui-listitem-icon';

	this.dom.iconContainer = iconContainer;
	this.dom.nameContent = nameContent;
	this.dom.typeContent = typeContent;
	//this.dom.labelContent = labelContent;

	this.setTextName(this.textName);
	//this.setTextLabel(this.textLabel);
	this.setTextType(this.textType);
	textContainer1.appendChild(typeContent);
	//textContainer1.appendChild(labelContent);

	textContainer2.appendChild(nameContent);

	this.html.appendChild(iconContainer);
	this.html.appendChild(textContainer1);
	this.html.appendChild(textContainer2);
	this.html.appendChild(this.buttonEdit.getHTML());
	this.html.appendChild(this.toolbar.getHTML());

	this.setText(this.text);

	if(this.visibleIcon) {
		this.showIcon();
	} else {
		this.hideIcon();
	}
	return this.html;
};

PMListItem.prototype.defineEvents = function () {
	PMUI.item.ListItem.prototype.defineEvents.call();
	this.buttonEdit.defineEvents();
};
var PMListPanel = function (settings){
	PMUI.panel.ListPanel.call(this, settings);
	this.onButtonEditItemClick = null;
	PMListPanel.prototype.init.call(this, settings);
};

PMListPanel.prototype = new PMUI.panel.ListPanel();

PMListPanel.prototype.setFactory = function() {
	this.factory = new PMUI.util.Factory({
		products: {
			'pmlistitem': PMListItem
		},
		defaultProduct: 'pmlistitem'
	});
	return this;
};

PMListPanel.prototype.init = function (settings) {
	var defaults = {
		onButtonEditItemClick : null
	}
	jQuery.extend(true, defaults, settings);
	this.setOnButtonEditItemClick(defaults.onButtonEditItemClick);
};

PMListPanel.prototype.setOnButtonEditItemClick = function (handler) {
	var i;
	if (!(handler == null || typeof handler === 'function')){
		throw new Error('PMListPanel.setOnButtonEditItemClick(): the argument is no valid, should be a function');
	}
	this.onButtonEditItemClick = handler;
	for ( i = 0 ;  i < this.items.asArray().length ; i+=1 ) {
		this.getItem(i).setOnButtonEditClick(handler);
	}
	return this;
};


PMListPanel.prototype.addItem = function(item) {
	if(item instanceof PMUI.item.ListItem) {
		item.setActions(this.actions).setTextDataBind(this.itemTextDataBind);
		item.setOnButtonEditClick(this.onButtonEditItemClick);
	} else if(!item.actions) {
		item.actions =  this.actions;
		item.setTextDataBind = this.itemTextDataBind;
		item.onButtonEditClick = this.onButtonEditItemClick;
	}
	PMUI.panel.ListPanel.prototype.addItem.call(this, item);
	return this;
};
var PMLabelControl = function(options){
	PMUI.control.HTMLControl.call(this, options);
	this.elementTag = 'span';
	PMLabelControl.prototype.init.call(this, options);
};

PMLabelControl.prototype = new PMUI.control.HTMLControl();

PMLabelControl.prototype.setElementTag = function(){
	this.elementTag = 'span';
	return this;
};

PMLabelControl.prototype.setValue = function(value) {
    PMUI.control.Control.prototype.setValue.call(this, value);
    if(this.html && this.html.value !== this.value) {
        this.html.value = this.value;
        this.html.innerHTML = this.value;           
    }
    return this;
};
PMLabelField = function(options){
	PMUI.form.Field.call(this, options);

	PMLabelField.prototype.init.call(this, options);
};

PMLabelField.prototype = new PMUI.form.Field();

PMLabelField.prototype.type = 'PMLabelField';

PMLabelField.prototype.setControls = function() {
    if(this.controls.length) {
        return this;
    }

    this.controls.push(new PMLabelControl());
    return this;
};


PMSuggestField = function(options){
	PMUI.field.TextField.call(this, options);

	PMSuggestField.prototype.init.call(this, options);
};

PMSuggestField.prototype = new PMUI.field.TextField();

PMSuggestField.prototype.type = 'PMSuggestField';

PMTitleField = function(options){
	PMUI.form.Field.call(this, options);

	PMTitleField.prototype.init.call(this, options);
};

PMTitleField.prototype = new PMUI.form.Field();

PMTitleField.prototype.type = 'PMTitleField';


PMTitleField.prototype.init = function (options){
	var defaults =  {
		label : '-Title-',
		labelWidth : '100%'
	};

	jQuery.extend(true, defaults, options);

	this.setLabel(defaults.label);
	this.setLabelWidth(defaults.labelWidth);
};


PMTitleField.prototype.createHTML = function (){
        var html;

        if(!this.html) {
            //html = PMUI.createHTMLElement("div");
            this.style.addClasses(['pmui-field']);
            PMUI.core.Element.prototype.createHTML.call(this);
            labelTextContainer = PMUI.createHTMLElement("h4");
            labelTextContainer.className = 'pmui-field-label'; // contenedor de todos los labels
            labelTextContainer.style.marginLeft = "10px";
            this.dom.labelTextContainer = labelTextContainer;
            this.html.appendChild(labelTextContainer);
            this.setLabelWidth(this.labelWidth);
            this.setLabel(this.label);
            this.setValue(this.value);
            this.setLabelPosition(this.labelPosition);
        }
        return this.html;
};

PMTitleField.prototype.setLabel = function(label) {
        if(typeof label === 'string') {
            this.label = label;
        } else {
            throw new Error("The setLabel() method only accepts string values!");
        }
        if(this.dom.labelTextContainer) {
            this.dom.labelTextContainer.innerHTML = this.label;
        }
        return  this;
};

PMTitleField.prototype.defineEvents = function() {
    var i, that = this;
    PMUI.core.Element.prototype.defineEvents.call(this);
    this.addEvent('click').listen(this.html, function(e) {
        if(typeof that.onClick === 'function') {
            that.onClick(that);
        }
    });
  this.eventsDefined = true;

    return this;
};

PMTitleField.prototype.setLabelPosition = function(position) {
    this.labelPosition = position;
    return this;
};
PMSubtitleField = function(options){
	PMUI.form.Field.call(this, options);

	PMSubtitleField.prototype.init.call(this, options);
};

PMSubtitleField.prototype = new PMUI.form.Field();

PMSubtitleField.prototype.type = 'PMSub-titleField';


PMSubtitleField.prototype.init = function (options){
	var defaults =  {
		label : '-Subtitle-',
		labelWidth : '100%'
	};

	jQuery.extend(true, defaults, options);

	this.setLabel(defaults.label);
	this.setLabelWidth(defaults.labelWidth);
};


PMSubtitleField.prototype.createHTML = function (){
        var html;

        if(!this.html) {
            //html = PMUI.createHTMLElement("div");
            this.style.addClasses(['pmui-field']);
            PMUI.core.Element.prototype.createHTML.call(this);
            labelTextContainer = PMUI.createHTMLElement("h5");
            labelTextContainer.className = 'pmui-field-label'; // contenedor de todos los labels
            labelTextContainer.style.marginLeft = "10px";
            this.dom.labelTextContainer = labelTextContainer;
            this.html.appendChild(labelTextContainer);
            this.setLabelWidth(this.labelWidth);
            this.setLabel(this.label);
            this.setValue(this.value);
            this.setLabelPosition(this.labelPosition);
        }
        return this.html;
};

PMSubtitleField.prototype.setLabel = function(label) {
        if(typeof label === 'string') {
            this.label = label;
        } else {
            throw new Error("The setLabel() method only accepts string values!");
        }
        if(this.dom.labelTextContainer) {
            this.dom.labelTextContainer.innerHTML = this.label;
        }
        return  this;
};

PMSubtitleField.prototype.defineEvents = function() {
    var i, that = this;
    PMUI.core.Element.prototype.defineEvents.call(this);
    this.addEvent('click').listen(this.html, function(e) {
        if(typeof that.onClick === 'function') {
            that.onClick(that);
        }
    });
  this.eventsDefined = true;

    return this;
};

PMSubtitleField.prototype.setLabelPosition = function(position) {
    this.labelPosition = position;
    return this;
};
PMImageField = function(options){
	PMUI.form.Field.call(this, options);
    this.comment = null;
	PMImageField.prototype.init.call(this, options);
};

PMImageField.prototype = new PMUI.form.Field();

PMImageField.prototype.type = 'PMImageField';


PMImageField.prototype.init = function (options){
	var defaults =  {
		label : '-Image-',
        comment : 'image comments....'
	};

	jQuery.extend(true, defaults, options);

	this.setLabel(defaults.label);
    this.setComment(defaults.comment);
};


PMImageField.prototype.createHTML = function (){
    var html, imageContainer, commentContainer;
    if(!this.html) {
        PMUI.form.Field.prototype.createHTML.call(this);
        imageContainer = PMUI.createHTMLElement('div');
        imageContainer.className = 'pmimagefield-imageContainer';
        this.dom.controlContainer.style.width = "70%";

        commentContainer = PMUI.createHTMLElement('span');
        commentContainer.textContent = this.comment? this.comment : 'image comments....';
        commentContainer.className = "pmimagefield-commentContainer";
        
        this.dom.commentContainer = commentContainer;
        this.dom.controlContainer.appendChild(imageContainer);
        this.dom.controlContainer.appendChild(commentContainer);
        this.dom.imageContainer = imageContainer;
        this.dom.messageContainer.style.display='none';
    }
    return this.html;
};

PMImageField.prototype.defineEvents = function() {
    var i, that = this;
    PMUI.core.Element.prototype.defineEvents.call(this);
    this.addEvent('click').listen(this.html, function(e) {
        if(typeof that.onClick === 'function') {
            that.onClick(that);
        }
    });
  this.eventsDefined = true;

    return this;
};

PMImageField.prototype.setComment = function (comment) {
    this.comment = comment;
    if ( this.dom.commentContainer ) {
        this.dom.commentContainer.textContent = comment;
    }
    return this;
};
PMImageField.prototype.getComment = function () {
    return this.comment;
};
PMLinkField = function(options){
	PMUI.form.Field.call(this, options);
    this.url = null;
	PMLinkField.prototype.init.call(this, options);
};

PMLinkField.prototype = new PMUI.form.Field();

PMLinkField.prototype.type = 'PMLinkField';


PMLinkField.prototype.init = function (options){
	var defaults =  {
        url : ''
	};

	jQuery.extend(true, defaults, options);
    this.setUrl(defaults.url);
};

PMLinkField.prototype.createHTML = function (){
    var linkContainer, link;
    if(!this.html) {
        PMUI.form.Field.prototype.createHTML.call(this);

        linkContainer = PMUI.createHTMLElement('div');
        linkContainer.className ="PMLinkField-linkContainer";

        link = PMUI.createHTMLElement('span');
        link.className = "PMLinkField-link";

        this.dom.messageContainer.style.display='none';
        this.dom.controlContainer.style.width = "70%";

        linkContainer.appendChild(link);

        this.dom.controlContainer.appendChild(linkContainer);
        this.dom.linkContainer = linkContainer;
        this.dom.link = link;
        this.setUrl(this.url);
    }
    return this.html;
};

PMLinkField.prototype.setUrl = function (url) {
    var lengthStringUrl;
    if ( !(typeof  url === 'string') ){
        throw new error ("PMLinkField.setUrl(): The value is invalid, a value expected type string")
    }
    this.url = url;
    if ( this.dom.link) {
        lengthStringUrl = url.trim().length;
        if (lengthStringUrl){
            this.removeCSSClasses(['PMLinkField-noUrl']);
            this.dom.link.textContent = url;
        }else{
            this.addCSSClasses(['PMLinkField-noUrl']);
            this.dom.link.textContent = url;
        }
    }
    return this;
};

PMLinkField.prototype.getUrl = function () {
    return this.url;
};
PMTextLabelField = function(options){
	PMUI.form.Field.call(this, options);

	PMTextLabelField.prototype.init.call(this, options);
};

PMTextLabelField.prototype = new PMUI.form.Field();

PMTextLabelField.prototype.type = 'PM-textLabelField';


PMTextLabelField.prototype.init = function (options){
	var defaults =  {
		label : 'text...',
		labelWidth : '100%'
	};

	jQuery.extend(true, defaults, options);

	this.setLabel(defaults.label);
	this.setLabelWidth(defaults.labelWidth);
};


PMTextLabelField.prototype.createHTML = function (){
        var html;

        if(!this.html) {
            //html = PMUI.createHTMLElement("div");
            this.style.addClasses(['pmui-field']);
            PMUI.core.Element.prototype.createHTML.call(this);
            labelTextContainer = PMUI.createHTMLElement("span");
            labelTextContainer.className = 'pmui-textlabel-field'; // contenedor de todos los labels
            this.dom.labelTextContainer = labelTextContainer;
            this.html.appendChild(labelTextContainer);
            this.setLabelWidth(this.labelWidth);
            this.setLabel(this.label);
            this.setValue(this.value);
            this.setLabelPosition(this.labelPosition);
        }
        return this.html;
};

PMTextLabelField.prototype.setLabel = function(label) {
        if(typeof label === 'string') {
            this.label = label;
        } else {
            throw new Error("The setLabel() method only accepts string values!");
        }
        if(this.dom.labelTextContainer) {
            this.dom.labelTextContainer.innerHTML = this.label;
        }
        return  this;
};

PMTextLabelField.prototype.defineEvents = function() {
    var i, that = this;
    PMUI.core.Element.prototype.defineEvents.call(this);
    this.addEvent('click').listen(this.html, function(e) {
        if(typeof that.onClick === 'function') {
            that.onClick(that);
        }
    });
  this.eventsDefined = true;

    return this;
};

PMTextLabelField.prototype.setLabelPosition = function(position) {
    this.labelPosition = position;
    return this;
};
PMFormField = function (options) {
    this.onEditClick = null;
    PMUI.form.Field.call(this, options);
    PMFormField.prototype.init.call(this, options);
};

PMFormField.prototype = new PMUI.form.Field();

PMFormField.prototype.type = 'PMFormField';

PMFormField.prototype.init = function (options) {
    var defaults = {
        label: '[New Form]',
        onEditClick: null
    };

    jQuery.extend(true, defaults, options);
    this.setLabel(defaults.label);
    this.setOnEditClick(defaults.onEditClick);
};

PMFormField.prototype.createHTML = function () {
    var that = this;
    var formContainer, formIcon, editIcon;
    if (!this.html) {
        PMUI.form.Field.prototype.createHTML.call(this);

        formContainer = PMUI.createHTMLElement('div');
        formContainer.className = "pmFormField-formContainer";

        formIcon = PMUI.createHTMLElement('span');
        formIcon.className = "pmFormField-formIcon";
        editIcon = PMUI.createHTMLElement('i');
        editIcon.className = "pmFormField-editIcon";

        this.dom.messageContainer.style.display = 'none';
        this.dom.controlContainer.style.width = "100%";
        this.dom.labelTextContainer.style.width = "100%";
        this.dom.labelTextContainer.appendChild(editIcon);
        this.dom.editIcon = editIcon;
        formContainer.appendChild(formIcon);
        this.dom.controlContainer.appendChild(formContainer);
        this.dom.formContainer = formContainer;
        this.dom.formIcon = formIcon;
        this.dom.fieldColon.style.display = "none";
        //this.html.appendChild(editIcon);
        this.setLabelPosition('top');
    }
    return this.html;
};

PMFormField.prototype.defineEvents = function () {
    var that = this;
    PMUI.form.Field.prototype.defineEvents.call(this);
    this.addEvent('click').listen(this.dom.editIcon, function (e) {
        if (typeof that.onEditClick === 'function') {
            that.onEditClick(that);
        }
    });
    return this;
};

PMFormField.prototype.setOnEditClick = function (handler) {
    if (!(typeof handler === 'function' || handler === null)) {
        throw new Error(' the value handler should be type function');
    }
    this.onEditClick = handler;
    return this;
};


var PMPool = function (options) {
    PMShape.call(this, options);
    //LNS_NAME (String)
    /**
     *
     * @type {String}
     */
    this.name = '';
    /**
     *
     * @type {String}
     */
    //this.type= '';
    //PRO_UID (String)
    /**
     *
     * @type {String}
     */
    this.proUid = '';
    //PRO_TYPE (String)
    /**
     *
     * @type {String}
     */
    this.proType = '';
    //PRO_IS_EXECUTABLE
    /**
     *
     * @type {Boolean}
     */
    this.executable = false;
    //PRO_IS_CLOSED
    /**
     *
     * @type {Boolean}
     */
    this.closed = false;
    //LNS_IS_HORIZONTAL
    /**
     *
     * @type {String}
     */
    //this.orientation = 'HORIZONTAL';
    //LNS_PARENT_LANE (String)
    /**
     *
     * @type {String}
     */
    this.parentLane = null;
    //BOU_REL_POSITION (Int)
    /**
     *
     * @type {Number}
     */
    this.relPosition = 0;
    //BOU_SIZE_IDENTICAL
    /**
     *
     * @type {Boolean}
     */
    this.sizeIdentical = false;
    //PAR_NUM_PARTICIPANTS (Int)
    /**
     *
     * @type {Number}
     */
    this.participants = 0;
    this.graphic = null;
    this.headLineCoord = 40;
    this.orientation = 'HORIZONTAL';
    //this.resizing = 'HERARCHICAL';
    this.participantObject = null;
    this.bpmnLanes = new PMUI.util.ArrayList();

    PMPool.prototype.initObject.call(this, options);
};
PMPool.prototype = new PMShape();
PMPool.prototype.type = 'PMPool';

PMPool.prototype.poolContainerBehavior = null;
PMPool.prototype.poolResizeBehavior = null;

PMPool.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        lns_uid: this.getID(),
        lns_name: name,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_container: 'bpmnDiagram',
        _extended: this.getExtendedObject()
    };
};

/**
 * Object init method (internal)
 * @param {Object} options
 */
PMPool.prototype.initObject = function (options) {

    var defaultOptions = {
        name : 'Pool',
        proUid : '',
        proType : '',
        executable : false,
        closed: false,
        parentLane: '',
        relPosition: 0,
        sizeIdentical: false,
        participants: 0,
        orientation: 'HORIZONTAL',
        resizing: false,
        parentLane: null,
        identicalSize: false
    };
    $.extend(true, defaultOptions, options);

    this.setName(defaultOptions.name)
        .setProUid(defaultOptions.proUid)
        .setProType(defaultOptions.proType)
        .setExecutable(defaultOptions.executable)
        .setClosed(defaultOptions.closed)
        .setParentLane(defaultOptions.parentLane)
        .setRelPosition(defaultOptions.relPosition)
        .setSizeIdentical(defaultOptions.sizeIdentical)
        .setOrientation(defaultOptions.orientation)
        //.setResizing(defaultOptions.resizing)
        .setParentLane(defaultOptions.parentLane)
        .setIdenticalSize(defaultOptions.identicalSize);
};

/**
 * Creates the HTML representation of the layer
 * @returns {HTMLElement}
 */
PMPool.prototype.createHTML = function () {
    PMShape.prototype.createHTML.call(this);
    //this.style.addClasses(['bpmn_pool', 'bpmn_exclusive']);
    return this.html;
};



PMPool.prototype.applyZoom = function () {
    PMShape.prototype.applyZoom.call(this);
    this.updateResizeMinimuns();
};
/**
 * Paints the corresponding Pool, in this case adds the
 * corresponding css classes and margins
 * @chainable
 */
PMPool.prototype.paint= function() {
    var zoomFactor = this.canvas.zoomFactor,
        label = this.getLabels().get(0);
    if (typeof this.graphic === 'undefined' || this.graphic === null) {
        this.graphic = new JSGraphics(this.id);
    } else {
        this.graphic.clear();
    }
    this.graphic.setColor('#D60707'); //change color
    this.graphic.setStroke(2);
    if (this.orientation === 'VERTICAL') {
        this.graphic.drawLine(0, this.headLineCoord * zoomFactor,
            this.zoomWidth, this.headLineCoord * zoomFactor);
        label.setOrientation('horizontal');
        label.setLabelPosition('top');
    } else {
        this.graphic.drawLine(this.headLineCoord * zoomFactor, 0,
            this.headLineCoord * zoomFactor, this.zoomHeight - 5);
        //label.setOrientation('vertical');
        //label.setLabelPosition('center-left', 20, 0);

    }
    this.graphic.paint();
};

/**
 * Factory of pool behaviors. It uses lazy instantiation to create
 * instances of the different container behaviors
 * @param {String} type An string that specifies the container behavior we want
 * an instance to have, it can be regular or nocontainer
 * @return {ContainerBehavior}
 */
PMPool.prototype.containerBehaviorFactory = function (type) {
    if (type === 'pool'){
        if(!this.poolContainerBehavior) {
            this.poolContainerBehavior = new PoolContainerBehavior();
        }
        return this.poolContainerBehavior;
    } else {

        return PMShape.prototype.containerBehaviorFactory.call(this, type);
    }
};

/**
 * Handler for the onmousedown event, changes the draggable properties
 * according to the drag behavior that is being applied
 * @param {CustomShape} CustomShape
 * @returns {Function}
 * TODO Implement Mouse Down handler
 */
PMPool.prototype.onMouseDown = function (shape) {
    if (shape.getParentLane()) {
        return function (e, ui) {
            e.stopPropagation();
        };
    } else {
        return PMShape.prototype.onMouseDown.call(this, shape);
    }
};

PMPool.prototype.setResizeBehavior = function (behavior) {
        var factory = new PMUI.behavior.BehaviorFactory({
                products: {
                    "regularresize": PMUI.behavior.RegularResizeBehavior,
                    "Resize": PMUI.behavior.RegularResizeBehavior,
                    "yes": PMUI.behavior.RegularResizeBehavior,
                    "resize": PMUI.behavior.RegularResizeBehavior,
                    "noresize": PMUI.behavior.NoResizeBehavior,
                    "NoResize": PMUI.behavior.NoResizeBehavior,
                    "no": PMUI.behavior.NoResizeBehavior,
                    "poolResize": PMPoolResizeBehavior
                },
                defaultProduct: "noresize"
            });
        this.resizeBehavior = factory.make(behavior);
        if (this.html) {
            this.resize.init(this);
        }
        return this;
};
/**
 * Add a lane and refactor all lane positions and dimensions
 * @param {BPMNLane} newLane
 * @returns {PMPool}
 */
PMPool.prototype.addLane = function (newLane) {
        if (this.canvas.buildingDiagram){
            this.bpmnLanes.insert(newLane);
        }
        newLane.setRelPosition(this.bpmnLanes.getSize());
        newLane.setParentPool(this.getID());
    return this;
};

/**
 * remove a lane and refactor all lane positions and dimensions
 * @param {BPMNLane} lane
 * @chainable
 */
PMPool.prototype.removeLane = function (lane) {
    this.bpmnLanes.remove(lane);
    //console.log('remove');

    return this;
};

PMPool.prototype.updateResizeMinimuns = function () {
    var $shape,
        minimums,
        minW,
        minH;

    $shape = $(this.getHTML());
    //console.log(this.getAllChildLanesNum());
    minimums = this.getPoolResizeMinimums([0, 99999999]);
    minW = (this.getOrientation() === 'HORIZONTAL')
        ? minimums[0]: minimums[0];
    minH = (this.getOrientation() === 'HORIZONTAL')
        ? minimums[1] : minimums[1];
    //console.log(minimums);
    minH = this.getHeight() - minH;
    //minH = minH + (this.getAllChildLanesNum() - 1) * lane.getHeight();
    // update jQueryUI's minWidth and minHeight
    $shape.resizable('option', 'minWidth', minW);
    $shape.resizable('option', 'minHeight', minH);
    return this;
};

PMPool.prototype.getPoolResizeMinimums = function(array) {
    var i , j, limits, margin, w, h, lane, childPool, children, auxChild,
        childs2 = new PMUI.util.ArrayList();
    for (i = 0; i < this.bpmnLanes.getSize(); i += 1){
        lane = this.bpmnLanes.get(i);
        childPool = this.canvas.customShapes.find('id',lane.getChildPool());

        children = lane.getChildren();
        //console.log(children.asArray());
        for(j = 0; j<children.getSize();j += 1) {
            auxChild = children.get(j);
            if (auxChild.getType() !== 'bpmnPool'){
                childs2.insert(auxChild);
            }
        }

        limits = childs2.getDimensionLimit();
        margin = this.headLineCoord * this.canvas.getZoomFactor();
        //factor = (this.getAllChildLanesNum()-1 )*lane.
        w = limits[1] * this.canvas.getZoomFactor() + margin * array[2];
        //console.log(limits);
        h = lane.getHeight() - limits[2] * this.canvas.getZoomFactor();
        //console.log(h)
        array[0] = (array[0] < w) ? w : array[0];
        array[1] = (array[1] > h) ? h : array[1];
        array[2] = 1;
        //array[1] = ;
        if (childPool) {
            array[2] += 1;
            childPool.getPoolResizeMinimums(array);
        }
    }
    return array;
};
/**
 * Get number of lanes into a pool
 * @return {Number}
 */
PMPool.prototype.getAllChildLanesNum = function (num){
    var i, lane, childPool;
    for (i = 0; i < this.bpmnLanes.getSize(); i += 1) {
        lane = this.bpmnLanes.get(i);
        childPool = this.canvas.customShapes.find('id', lane.getChildPool());
        if (childPool) {
            num += childPool.getAllChildLanesNum (0);
        } else {
            num +=  1;
        }
    }
    return num;
};

/**
 * Destroy a pool and update lane parentLane property if is a child pool
 * @chainable
 */
PMPool.prototype.destroy = function () {
    var parentLane = this.canvas.customShapes.find('id', this.getParentLane());
    if (parentLane) {
        this.parent.labels.get(0).setVisible(true);
        parentLane.childPool = null;
            
    }
    //this.saveAndDestroy();
    return this;
};

/**
 * Comparison function for ordering layers according to priority
 * @param {BPMNLane} lane1
 * @param {BPMNLane} lane2
 * @returns {boolean}
 */
PMPool.prototype.comparisonFunction = function (lane1, lane2) {
    return lane1.relPosition > lane2.relPosition;
};
/**
 * Refactor recursively all lane position an dimensions
 * @chainable
 */
PMPool.prototype.refactorLanePositionsAndDimensions = function () {
    var numLanes,
        oldX,
        oldY,
        newx,
        newy,
        oldWidth,
        oldHeight,
        newWidth,
        newHeight,
        oldRelPosition,
        lane,
        i,
        label,
        numLanes2,
        newHeight2,
        newWidth2,
        childPool;

    numLanes = this.bpmnLanes.getSize();
    newx = (this.orientation === 'HORIZONTAL') ? this.headLineCoord : -1;
    newy = (this.orientation === 'HORIZONTAL') ? 0 : this.headLineCoord;
    newWidth = (this.orientation === 'HORIZONTAL') ?
        this.getWidth() - this.headLineCoord : this.getWidth() / numLanes;
    newHeight = (this.orientation === 'HORIZONTAL') ?
        (this.getHeight() -1) / numLanes: this.getHeight() - this.headLineCoord;

    // FOR IDENTICAL OPTION
    numLanes2 = this.getAllChildLanesNum(0);
    newWidth2 = (this.orientation === 'HORIZONTAL') ?
        this.getWidth() - this.headLineCoord-1 : this.getWidth() / numLanes2;
    newHeight2 = (this.orientation === 'HORIZONTAL') ?
        this.getHeight()/numLanes2: this.getHeight() - this.headLineCoord;

    for (i = 0; i < this.bpmnLanes.getSize(); i += 1) {
        lane = this.bpmnLanes.get(i);
        oldX = lane.getX();
        oldY = lane. getY();
        oldWidth = lane.getWidth();
        oldHeight = lane.getHeight();
        oldRelPosition = lane.getRelPosition();
        // remove top border for firstLane
        if(i > 0) {
            if (lane.parent.getOrientation() === 'HORIZONTAL') {
                lane.style.addProperties({
                    'border-top':'2px solid #D60707'
                });
            } else {
                lane.style.addProperties({
                    'border-left':'2px solid #D60707'
                });
            }

        } else {
            //lane.html.removeAttribute("style");
            lane.style.removeProperties(['border-top', 'border-left']);

        }
        // FOR IDENTICAL OPTION
        if (this.getIdenticalSize()) {
            childPool = lane.canvas.customShapes.find('id', lane.getChildPool());
            if ( childPool &&
                childPool.bpmnLanes.getSize() > 0) {
                newHeight =  (this.orientation === 'HORIZONTAL') ?
                    //newHeight2 * childPool.bpmnLanes.getSize() :
                    newHeight2 * childPool.getAllChildLanesNum(0) :
                    newHeight;

                newWidth =  (this.orientation === 'HORIZONTAL') ?
                    newWidth :
                    newWidth2 * childPool.bpmnLanes.getSize();
            } else {
                newHeight = newHeight2;
                newWidth = newWidth2;
            }
        }

        lane.setDimension(newWidth, newHeight);
        lane.setPosition(newx, newy);
        lane.setRelPosition(i+1);
        label = lane.getLabels().get(0);
        label.setLabelPosition(label.location, label.diffX, label.diffY);
       // label.setVisible(true);
        //Triggers for update lane changes

        //this.canvas.triggerLaneChangeEvent(lane, lane.getAbsoluteX(),
        //    this.getAbsoluteX() + newx, 'newX');
        //this.canvas.triggerLaneChangeEvent(lane, lane.getAbsoluteY(),
        //    this.getAbsoluteY() + newy, 'newY');

        //this.canvas.triggerLaneChangeEvent(lane, oldRelPosition,
        //    lane.getRelPosition(), 'relPosition');
        
        //trigger for update dimensions
        //this.canvas.triggerLaneChangeEvent(lane, oldWidth, newWidth, 'width');
        //this.canvas.triggerLaneChangeEvent(lane, oldHeight, newHeight, 'height');
        //this.canvas.triggerLaneChangeEvent(lane, oldRelPosition,
        //    lane.getRelPosition(), 'relPosition');
        childPool = this.canvas.customShapes.find('id', lane.getChildPool());
        if (childPool) {
            childPool.setPosition(0, 0);
            childPool.setDimension(newWidth, newHeight);
            childPool.canvas.triggerOrientationChangeEvent(childPool,
                childPool.getOrientation() == 'HORIZONTAL' ? 1:0,
                this.getOrientation() == 'HORIZONTAL' ? 1:0,
                'orientation' );
            childPool.setOrientation(this.getOrientation());
            //childPool.canvas.triggerLaneChangeEvent(childPool, childPool.getAbsoluteX(),
            //    this.getAbsoluteX() + newx, 'newX');
            //childPool.canvas.triggerLaneChangeEvent(childPool, childPool.getAbsoluteY(),
            //    lane.getAbsoluteY(), 'newY' );
            //childPool.canvas.triggerLaneChangeEvent(childPool, oldWidth, newWidth, 'width' );
            //childPool.canvas.triggerLaneChangeEvent(childPool, oldHeight, newHeight, 'height');

            childPool.paint();
            label.setVisible(false);
            childPool.labels.get(0).setVisible(true);
            childPool.setIdenticalSize(false);

        }

        newy = (this.orientation === 'HORIZONTAL') ? newy + newHeight : newy;
        newx = (this.orientation === 'HORIZONTAL') ? newx : newx + newWidth;
        lane.paint();
        this.paint();
        //if has childs Pool
        childPool = this.canvas.customShapes.find('id', lane.getChildPool());
        if (childPool
            && childPool.bpmnLanes.getSize() > 0) {

            childPool.refactorLanePositionsAndDimensions();
        }
    }
    return this;
};

/**
 * Refactor recursively all lane position an dimensions
 * @chainable
 */
PMPool.prototype.setLanePositionAndDimension= function (lane) {
    var numLanes,
        oldX,
        oldY,
        newx,
        newy,
        oldWidth,
        oldHeight,
        newWidth,
        newHeight,
        oldRelPosition,
        lane,
        i,
        label,
        numLanes2,
        newHeight2,
        newWidth2,
        childPool;

    numLanes = this.bpmnLanes.getSize();
    newx = (this.orientation === 'HORIZONTAL') ? this.headLineCoord : -1;
    newy = (this.orientation === 'HORIZONTAL') ? 0 : this.headLineCoord;
    newWidth = (this.orientation === 'HORIZONTAL') ?
        this.getWidth() - this.headLineCoord : this.getWidth() / numLanes;
    newHeight = (this.orientation === 'HORIZONTAL') ?
        (this.getHeight() -1) / numLanes: this.getHeight() - this.headLineCoord;

    // FOR IDENTICAL OPTION
    numLanes2 = this.getAllChildLanesNum(0);
    newWidth2 = (this.orientation === 'HORIZONTAL') ?
        this.getWidth() - this.headLineCoord-1 : this.getWidth() / numLanes2;
    newHeight2 = (this.orientation === 'HORIZONTAL') ?
        this.getHeight()/numLanes2: this.getHeight() - this.headLineCoord;

    if (numLanes > 1) {
        lane.style.addProperties({
                    'border-top':'2px solid #D60707'
        });
        lane.setDimension(newWidth , lane.getHeight());
        lane.setPosition(newx, newy + this.getHeight());
        lane.setRelPosition(numLanes);
        this.setDimension(this.getWidth(), this.getHeight() + lane.getHeight());
        this.paint();      
        
    } else {
        lane.style.removeProperties(['border-top', 'border-left']);
        lane.setDimension(newWidth, this.getHeight());
        lane.setPosition(newx, newy);
        lane.setRelPosition(numLanes);
    }
    lane.paint();
    lane.updateBounds(lane.businessObject.di);
    this.updateBounds(this.participantObject.di);
    return this;
};

PMPool.prototype.updateOnRemoveLane= function (lane) {
    var i, diffH=0, nextLane, tempLane = lane, tempX = lane.getX(), tempY = lane.getY(),newY = 0;
    for (i = lane.getRelPosition()-1; i < this.bpmnLanes.getSize(); i += 1) {
        nextLane = this.bpmnLanes.get(i);
        //diffH += nextLane.getHeight();
        if (i === 0) {
             nextLane.style.removeProperties(['border-top', 'border-left']);
        }
//        oldX = nextLane.getX();
//        oldY = nextLane.getY();
        if (i > 0) {
            newY += this.bpmnLanes.get(i-1).getHeight();
        }
        nextLane.setPosition(lane.getX(), newY);
        nextLane.setRelPosition(nextLane.getRelPosition()-1);
        nextLane.paint();       
    }
    if (this.bpmnLanes.getSize() > 0) {
        this.setDimension(this.getWidth(), this.getHeight() - lane.getHeight());
        this.paint();
    }
    
    return this;
};

PMPool.prototype.updateOnResizeEnd = function() {
    var diffH = this.getHeight() - this.oldHeight,
        relativeH = diffH / this.bpmnLanes.getSize(),
        newWidth = this.getWidth() - this.headLineCoord - 4,
        lane,
        newY = 0,
        i;
    for (i = 0; i < this.bpmnLanes.getSize(); i += 1) {
        lane = this.bpmnLanes.get(i)
        lane.setDimension(newWidth, lane.getHeight() + relativeH);
        if (i > 0) {
            newY += this.bpmnLanes.get(i-1).getHeight();
            lane.setPosition(lane.getX(), newY);
        }
        lane.paint();
    }
};

PMPool.prototype.updateAllLaneDimension= function() {
    var newWidth = this.getWidth() - this.headLineCoord - 4, lane, newY = 0, i, parentHeight = 0;
    for (i = 0; i < this.bpmnLanes.getSize(); i += 1) {
        lane = this.bpmnLanes.get(i)
        lane.setDimension(newWidth, lane.getHeight());
        lane.setRelPosition(i+1);
        if (i > 0) {
            newY += this.bpmnLanes.get(i-1).getHeight();
            lane.setPosition(lane.getX(), newY);
            lane.style.addProperties({
                'border-top':'2px solid #D60707'
            });
        } else {
            lane.style.removeProperties(['border-top', 'border-left']);

        }
        parentHeight += lane.getHeight();
        lane.paint();
        lane.updateBounds(lane.businessObject.di);
    }
    this.setDimension(this.getWidth(), parentHeight);
    this.paint()
    this.updateBounds(this.participantObject.di);
};


PMPool.prototype.getMasterPool = function () {
    if (this.parent.family !== 'Canvas') {
        return this.parent.parent.getMasterPool();
    } else {
        return this;
    }

};

/**
 * Change pool orientation dinamically
 * @param {String} orientation
 * @returns {PMPool}
 */
//PMPool.prototype.changeOrientation = function (orientation){
//    var command = new BPMNCommandUpdateOrientation(this, {
//        before:  this.getOrientation(),
//        after: orientation.toUpperCase()
//    });
//    command.execute();
//    this.getCanvas().commandStack.add(command);
//    return this;
//};

/**
 * Change pool Size to Identical or herarchical
 * @param {Boolean} orientation
 * @returns {PMPool}
 * @chainable
 */
//PMPool.prototype.changeIdenticalSize = function (size) {
//    var command = new BPMNCommandUpdateSize(this, {
//        before:  this.getIdenticalSize(),
//        after: size
//    });
//    command.execute();
//    this.getCanvas().commandStack.add(command);
//    return this;
//};
//SETTERS
/**
 * Set pool name
 * @param {String} name
 * @returns {PMPool}
 */
PMPool.prototype.setName = function (name) {
    this.name = name;
    return this;
};
/**
 * Set pool type
 * @param {String} name
 * @returns {PMPool}
 */
PMPool.prototype.setType = function (newType) {
    this.type = newType;
    return this;
};
/**
 * Set proUid attached to pool
 * @param {String} uid
 * @returns {PMPool}
 */
PMPool.prototype.setProUid = function (uid) {
    this.proUid = uid;
    return this;
};
/**
 * Set pool type
 * @param {String} proType
 * @returns {PMPool}
 */
PMPool.prototype.setProType = function (proType) {
    this.proType = proType;
    return this;
};
/**
 * Set executable mode to pool
 * @param {Boolean} executable
 * @returns {PMPool}
 */
PMPool.prototype.setExecutable = function (executable) {
    this.executable = executable;
    return this;
};
/**
 * Set closed mode to pool
 * @param {Boolean} closed
 * @returns {PMPool}
 */
PMPool.prototype.setClosed = function (closed) {
    this.closed = closed;
    return this;
};
/**
 * Set pool orientation
 * @param {String} orientation
 * @returns {PMPool}
 */
PMPool.prototype.setOrientation = function (orientation) {
    this.orientation = orientation;
    return this;
};
/**
 * Set pool resizing mode
 * @param {String} orientation
 * @returns {PMPool}
 */
PMPool.prototype.setResizing = function (resizing) {
    this.resizing = resizing;
    return this;
};
/**
 * Set parent Lane UID to pool
 * @param {String} parentLane
 * @returns {PMPool}
 */
PMPool.prototype.setParentLane = function (parentLane) {
    this.parentLane = parentLane;
    return this;
};
/**
 * Set pool rel position
 * @param {Number} relPosition
 * @returns {PMPool}
 */
PMPool.prototype.setRelPosition = function (relPosition) {
    this.relPosition = relPosition;
    return this;
};
/**
 * Set size identical mode if we want identical size of pool childs
 * @param {Number} relPosition
 * @returns {PMPool}
 */
PMPool.prototype.setSizeIdentical = function (sizeIdentical) {
    this.sizeIdentical = sizeIdentical;
    return this;
};
/**
 * Set number of participants into a pool
 * @param {Number} num
 * @returns {PMPool}
 */
PMPool.prototype.setParticipants = function (num) {
    this.participants = num;
    return this;
};

/**
 * Set identical Size to a pool
 * @param {Boolean} val
 * @returns {PMPool}
 */
PMPool.prototype.setIdenticalSize = function (val) {
    this.identicalSize = val;
    return this;
};



//GETTERS
/**
 * Get the pool name
 * @returns {String}
 */
PMPool.prototype.getName = function () {
    return this.name;
};
/**
 * Get the pool type
 * @returns {String}
 */
PMPool.prototype.getType = function () {
    return this.type;
};
/**
 * Get the process uid attached to pool
 * @returns {String}
 */
PMPool.prototype.getProUid = function () {
    return this.proUid;
};
/**
 * Get the process uid attached to pool
 * @returns {String}
 */
PMPool.getProcessType = function () {
    return this.proType;
};
/**
 * Get a boolean value if the pool is in executable mode
 * @returns {Boolean}
 */
PMPool.isExecutable = function () {
    return this.executable;
};
/**
 * Get a boolean value if the pool is closed
 * @returns {Boolean}
 */
PMPool.prototype.isClosed = function (){
    return this.closed;
};
/**
 * Get the pool orientation
 * @returns {Sring}
 */
PMPool.prototype.getOrientation = function () {
    return this.orientation;
};
/**
 * Get the pool resizing mode
 * @returns {String}
 */
PMPool.prototype.getResizing = function () {
    return this.resizing;
};
/**
 * Get the relative position of the pool
 * @returns {Number}
 */
PMPool.prototype.getRelPosition = function () {
    return this.relPosition;
};
/**
 * Get a boolean value if pool have identical size
 * @returns {Boolean}
 */
PMPool.prototype.isSizeIdentical = function () {
    return this.sizeIdentical;
};
/**
 * Get a parent lane
 * @returns {BPMNLane}
 */
PMPool.prototype.getParentLane = function () {
    return this.parentLane;
};
/**
 * Get a number of participants asociate to pool
 * @returns {Boolean}
 */
PMPool.prototype.getParticipants = function () {
    return this.participants;   
};

/**
 * Get a identical size value
 * @returns {Boolean}
 */
PMPool.prototype.getIdenticalSize = function () {
    return this.identicalSize;
};

PMPool.prototype.updateDimension = function() {
    alert('update dimensions');
};




//Shape.prototype.updateSize = function (newMargin) {
//        var children = this.children,
//            limits = children.getDimensionLimit(),
//            left = limits[3],
//            top = limits[0],
//            right = limits[1],
//            bottom = limits[2],
//            newLeft = this.getX(),
//            newTop = this.getY(),
//            newWidth = this.getWidth(),
//            newHeight = this.getHeight(),
//            margin,
//            diffX = 0,
//            diffY = 0,
//            positionShift = false,
//            dimensionIncrement = false;
//
//        if (newMargin !== "undefined") {
//            margin = newMargin;
//        } else {
//            margin = 15;
//        }
//
//        if (left < 0) {
//            diffX = margin - left;
//            positionShift = true;
//            this.oldX = this.x;
//            this.oldAbsoluteX = this.x;
//            this.oldY = this.y;
//            this.oldAbsoluteY = this.absoluteY;
//        }
//
//        if (top < 0) {
//            diffY = margin - top;
//            positionShift = true;
//            this.oldX = this.x;
//            this.oldAbsoluteX = this.x;
//            this.oldY = this.y;
//            this.oldAbsoluteY = this.absoluteY;
//        }
//
//        newLeft -= diffX;
//        newTop -= diffY;
//        newWidth += diffX;
//        newHeight += diffY;
//
//        if (right > this.width) {
//            newWidth += right - this.width + margin;
//            dimensionIncrement = true;
//            this.oldWidth = this.width;
//        }
//        if (bottom > this.height) {
//            newHeight += bottom - this.height + margin;
//            dimensionIncrement = true;
//            this.oldHeight = this.height;
//        }
//
//        // move the shape to the new coordinates
//        this.setPosition(newLeft, newTop);
//
//        // TODO:  CHECK WHERE THIS FUNCTION MUST GO
//        // update the positions of its ports
//        //this.updatePortsPosition(newWidth - this.width, newHeight - this.height);
//
//        // update the shape's dimension
//        this.setDimension(newWidth, newHeight);
//
//        // custom triggers
//        if (positionShift) {
//            this.changePosition(this.oldX, this.oldY,
//                this.absoluteX, this.absoluteY);
//        }
//        if (dimensionIncrement) {
//            this.changeSize(this.oldWidth, this.oldHeight);
//        }
//
//        // move the children
//        this.updateChildrenPosition(diffX, diffY);
//
//        return this;
//    };
//
//PMPool.prototype.createBpmn = function() {
//
//    //if (!(this instanceof PMUI.draw.MultipleSelectionContainer)
//    //    && !(this instanceof PMLine)
//    //    && !(this instanceof PMLabel)) {
//    //    if(!this.businessObject && !(this instanceof PMUI.draw.MultipleSelectionContainer)){
//    //        this.createWithBpmn();
//    //    }
//    //    this.updateBounds();
//    //    this.updateShapeParent();
//    //
//    //    PMDesigner.moddle.toXML(PMDesigner.businessObject, function (err, xmlStrUpdated) {
//    //
//    //        console.log(xmlStrUpdated);
//    //        // xmlStrUpdated contains new id and the added process
//    //
//    //    });
//    //}
//    console.log('createWithBpmn -->pool');
//};
PMPool.prototype.stringify = function(){
    var inheritedJSON = PMShape.prototype.stringify.call(this),
        thisJSON = {
            name : this.getName(),
            proUid : this.getProUid(),
            proType : this.proType,
            executable : this.executable,
            closed: this.isClosed(),
            parentLane: this.parentLane,
            relPosition: this.getRelPosition(),
            sizeIdentical: this.isSizeIdentical(),
            participants: this.getParticipants(),
            orientation: this.getOrientation(),
            parentLane: this.getParentLane()
            // TODO: CREATE PROPERTIES FOR THE BEHAVIORS
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;

};



PMPool.prototype.createBpmn = function(type) {
    var bpmnCollaboration;
    if (!(_.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"}))) {
        bpmnCollaboration = PMDesigner.moddle.create('bpmn:Collaboration', {id: 'pmui-' + PMUI.generateUniqueId()});
        //PMDesigner.businessObject.collaboration =  bpmnCollaboration
        PMDesigner.businessObject.get('rootElements').push(bpmnCollaboration);
        this.parent.businessObject.di.bpmnElement = bpmnCollaboration;
        bpmnCollaboration.participants = [];
    } else {
        bpmnCollaboration = _.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"});
    }

    this.createWithBpmn(type, 'participantObject');

    this.updateBounds(this.participantObject.di);
    //this.updateShapeParent();
    this.updateSemanticParent(this.participantObject, bpmnCollaboration);

    this.updateDiParent(this.participantObject.di, this.parent.businessObject.di);
    //}
    //PMDesigner.moddle.toXML(PMDesigner.businessObject, function (err, xmlStrUpdated) {
    //
    //    // xmlStrUpdated contains new id and the added process
    //});
};
PMPool.prototype.updateSemanticParent = function(businessObject, newParent) {

    if (businessObject.$parent === newParent) {
        return;
    }

    var children;

    if (businessObject.$parent) {
        // remove from old parent
        children = businessObject.$parent.get('participants');
        CollectionRemove(children, businessObject);
    }

    if (!newParent) {
        businessObject.$parent = null;
    } else {
        // add to new parent
        children = newParent.get('participants');
        children.push(businessObject);
        businessObject.$parent = newParent;
    }
};

PMPool.prototype.updateDiParent = function(di, parentDi) {
    PMShape.prototype.updateDiParent.call(this, di, parentDi);
};


PMPool.prototype.createBusinesObject = function() {

    //id: this.id,
    var participant = _.findWhere(this.participantObject.$parent.get('participants'), {id: 'el_' + this.id});

    var bpmnProcess =  PMDesigner.moddle.create('bpmn:Process', { id:  'pmui-' + PMUI.generateUniqueId() });
    PMDesigner.businessObject.get('rootElements').push(bpmnProcess);
    this.businessObject = bpmnProcess
    this.businessObject.di = this.canvas.businessObject.di;
    participant.processRef = bpmnProcess;
};

//remove bpmn section
PMPool.prototype.removeBpmn = function() {
    var coll, children, pros;

    if ((_.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Collaboration"}))) {
        coll = _.findWhere(PMDesigner.businessObject.get('rootElements'), {$type: "bpmn:Collaboration"});
        if (coll.participants.length === 1){
            children = PMDesigner.businessObject.get('rootElements');
            CollectionRemove(children, coll);
            //PMDesigner.businessObject.get
            this.parent.businessObject.di.bpmnElement = this.parent.businessObject;
        }
    }
    if (this.businessObject && (_.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Process", id: this.businessObject.id})) ) {
        pros = _.findWhere(PMDesigner.businessObject .get('rootElements'), {$type: "bpmn:Process", id: this.businessObject.id});
        //if (pros.participants.length === 1){
            children = PMDesigner.businessObject.get('rootElements');
            CollectionRemove(children, pros);
            this.businessObject = null;
            //PMDesigner.businessObject.get
            //this.parent.businessObject.di.bpmnElement = this.parent.businessObject;

       // }
    }
    this.updateSemanticParent(this.participantObject);
    this.updateDiParent(this.participantObject.di);
};

PMPool.prototype.updateBpmn = function() {
    this.updateBounds(this.participantObject.di);
};

var PMLane = function (options) {
    PMShape.call(this, options);
    //PAR_NAME (String)
    /**
     *
     * @type {String}
     */
    this.name = '';
    //PAR_IS_HORIZONTAL (inherited)

    //PRO_UID (String)
    /**
     *
     * @type {String}
     */
    this.proUid = '';

    //LAN_CHILD_LANESET (String)
    /**
     *
     * @type {String}
     */
    this.childLaneset = '';

    //BOU_REL_POSITION (Number)
    /**
     *
     * @type {Number}
     */
    this.relPosition = 0;

    this.parentPool = null;

    this.childPool = null;

    PMLane.prototype.initObject.call(this, options);
};

PMLane.prototype = new PMShape();
PMLane.prototype.type = 'PMLane';

PMLane.prototype.getDataObject = function () {
    var name = this.getName();
    return {
        lan_uid: this.id,
        lns_uid: this.parent.id,
        lan_name: name,
        bou_x: this.x,
        bou_y: this.y,
        bou_width: this.width,
        bou_height: this.height,
        bou_rel_position: this.getRelPosition(),
        element_id: this.parent.id,
        bou_container: 'bpmnPool',
        lan_parent_pool: this.parentPool,
        _extended: this.getExtendedObject()
    };
};

PMLane.prototype.initObject = function (options) {
var defaultOptions = {
        name : 'Lane',
        proUid: null,
        childLaneset : null,
        relPosition: 0,
        childPool: null,
        orientation: 'HORIZONTAL'
    };
    $.extend(true, defaultOptions, options);

    this.setName(defaultOptions.name)
        .setProUid(defaultOptions.proUid)
        .setRelPosition(defaultOptions.relPosition)
        .setChildPool(defaultOptions.childPool)
        .setOrientation(defaultOptions.orientation);
};
PMLane.prototype.paint = function(){

  if (this.parent.orientation === 'VERTICAL') {
       // this.graphic.drawLine(0, this.headLineCoord, this.width,
        //     this.headLineCoord);
        this.getLabels().get(0).setOrientation('horizontal');
        this.getLabels().get(0).setLabelPosition('top');
    } else {
        this.getLabels().get(0).setOrientation('vertical');
        this.getLabels().get(0).setLabelPosition('center-left', 20, 0);
 
    }
    if (this.childPool) {
        this.getLabels().get(0).setVisible(false);
    }
    //this.points.getFirst();

};
PMLane.prototype.containerBehaviorFactory = function (type) {
    return PMShape.prototype.containerBehaviorFactory.call(this, type);
};

PMLane.prototype.setResizeBehavior = function (behavior) {
        var factory = new PMUI.behavior.BehaviorFactory({
                products: {
                    "regularresize": PMUI.behavior.RegularResizeBehavior,
                    "Resize": PMUI.behavior.RegularResizeBehavior,
                    "yes": PMUI.behavior.RegularResizeBehavior,
                    "resize": PMUI.behavior.RegularResizeBehavior,
                    "noresize": PMUI.behavior.NoResizeBehavior,
                    "NoResize": PMUI.behavior.NoResizeBehavior,
                    "no": PMUI.behavior.NoResizeBehavior,
                    //"poolResize": PMPoolResizeBehavior
                    "laneResize": PMLaneResizeBehavior
                },
                defaultProduct: "noresize"
            });
        this.resizeBehavior = factory.make(behavior);
        if (this.html) {
            this.resize.init(this);
        }
        return this;
};

/**
 * Convert a lane to Pool
 */
PMLane.prototype.transformToPool = function () {
  //TODO TRANFORM TO POOL
   var customShape = new BPMNPool({
                        width: this.getWidth()-1,
                        height: this.getHeight()-1,
                        "canvas" : this.canvas,
                        "connectAtMiddlePoints": false,
                        container : 'pool',
                        topLeft:true,

                        drop : {
                            type: 'bpmnconnectioncontainer',
                            selectors : ["#BPMNLane",
                                "#BPMNActivity", "#BPMNSubProcess", "#BPMNStartEvent",
                                "#BPMNEndEvent", "#BPMNIntermediateEvent", "#BPMNGateway",
                                "#BPMNDataObject", "#BPMNDataStore", "#BPMNGroup",
                                "#BPMNAnnotation", ".bpmn_droppable", ".custom_shape"],
                            overwrite : true
                        },
                        drag: 'noDrag',
                        resizeBehavior: "no",
                        resizeHandlers: {
                            type: "Rectangle",
                            total: 4,
                            resizableStyle: {
                                cssProperties: {
                                    'background-color': "rgb(0, 255, 0)",
                                    'border': '1px solid black'
                                }
                            },
                            nonResizableStyle: {
                                cssProperties: {
                                    'background-color': "white",
                                    'border': '1px solid black'
                                }
                            }
                        },
                        "style": {
                            cssClasses: []
//                            cssProperties: {
//                                border: '1px solid #000000',
//                                '-webkit-box-shadow':  'none',
//                                '-moz-box-shadow':  'none',
//                                'box-shadow': 'none'
//                            }

                        },
                        layers: [
                            {
                                layerName : "first-layer",
                                priority: 2,
                                visible: true,
                                style: {
                                    cssProperties: {

                                    }
                                }
                            }
                        ],
                        labels : [
                            {
                                message : this.getMessage(),
                                width : 50,
                                height : 10,
                                orientation:'vertical',
                                position: {
                                    location: 'center-left',
                                    diffX : 20,
                                    diffY : 0

                                    },
                                updateParent: false
                            }
                        ],
                        orientation: this.parent.getOrientation(),
                        name: this.getName(),
                        parentLane: this.getID()
                    });
    this.labels.get(0).setVisible(false);
    this.setChildPool(customShape.getID());
    this.addElement(customShape, 1, 0, true);
    customShape.labels.get(0).setVisible(true);
    this.canvas.triggerSinglePropertyChangeEvent(this, 'childPool',
        this.getChildPool() ,customShape.getID());


    customShape.attachListeners();
    this.canvas.updatedElement = customShape;
    var command = new jCore.CommandCreate(customShape);
    this.canvas.commandStack.add(command);
    command.execute();


};

PMLane.prototype.createHTML = function () {
    PMShape.prototype.createHTML.call(this);
    if (this.getRelPosition() > 1) {
        //if (this.getOrientation() === 'HORIZONTAL') {
        //    this.style.addProperties({
        //        'border-top':'1px solid black'
        //    });
        //} else {
        //    this.style.addProperties({
        //        'border-left':'1px solid black'
        //    });
        //}
        this.style.addProperties({
            'border-top':'2px solid #D60707'
        });
    }
    return this.html;
};

PMLane.prototype.attachListeners = function () {

    var $lane = $(this.html);
    if (!this.html) {
        return this;
    }
    PMShape.prototype.attachListeners.call(this);
};

PMLane.prototype.onKeyDown = function (customShape) {
    return  function (e) {
        alert('hello');
    }
};

PMLane.prototype.onMouseDown = function (shape) {
    return function (e, ui) {
        PMUI.draw.CustomShape.prototype.onMouseDown.call(this, shape) (e,ui);
        shape.setDragBehavior('nodrag');
    };
};
//BPMNLane.prototype.onMouseUp = function (shape) {
//    return function (e, ui) {
//        //e.stopPropagation();
//    };
//};
//BPMNLane.prototype.onClick = function (shape) {
//    return function (e, ui) {
//       // e.stopPropagation();
//    };
//};

PMLane.prototype.destroy = function () {
    //BPMNShape.prototype.destroy.call(this);
    var parentPool = this.canvas.customShapes.find('id',this.parentPool);
    if (parentPool){
        parentPool.removeLane(this);
        parentPool.updateOnRemoveLane(this);
        
    }
    //this.saveAndDestroy();
    return this;
};
//SETTERS
PMLane.prototype.setChildPool = function (pPool) {
    this.childPool = pPool;
    return this;
};
PMLane.prototype.setParentPool = function (pPool) {
    this.parentPool = pPool;
    return this;
};
/**
 * Set lane name
 * @param {String} name
 * @returns {BPMNLane}
 */
PMLane.prototype.setName = function (name) {
    this.name = name;
    return this;
};
/**
 * Set lane type
 * @param {String} newType
 * @returns {BPMNLane}
 */
PMLane.prototype.setType = function (newType) {
    this.type = newType;
    return this;
};
/**
 * Set process uid asociated to lane
 * @param {String} uid
 * @returns {BPMNLane}
 */
PMLane.prototype.setProUid = function (uid) {
    this.proUid = uid;
    return this;
};
/**
 * Set the relative position of lane
 * @param {Number} relPosition
 * @returns {BPMNLane}
 */
PMLane.prototype.setRelPosition = function (relPosition) {
    this.relPosition = relPosition;
    return this;
};

PMLane.prototype.setOrientation = function (orientation) {
    this.orientation = orientation;
    return this;
};
/**
 * Set ChildLaneset to lane
 * @param {BPMNPool} childLane
 * @returns {BPMNLane}
 */
PMLane.prototype.setChildLaneset = function (childLane) {
    this.childLaneset = childLane;
    return this;
};


//GETTERS
/**
 * Get the lane name
 * @returns {String}
 */
PMLane.prototype.getName = function () {
    return this.name;
};

PMLane.prototype.getType = function () {
    return this.type;
};
/**
 * Get pro uid asociated to lane
 * @returns {String}
 */
PMLane.prototype.getProUid = function () {
    return this.proUid;
};
/**
 * Get the relative position of lane
 * @returns {Number}
 */
PMLane.prototype.getRelPosition = function () {
    return this.relPosition;
};
PMLane.prototype.getOrientation = function () {
    return this.orientation;
};
/**
 * Get ChildLaneSet
 * @returns {BPMNPool}
 */
PMLane.prototype.getChildLaneset = function () {
    return this.childLaneset;
};
PMLane.prototype.getChildPool = function () {
    return this.childPool;
};

PMLane.prototype.updateDimensions = function (margin) {
        this.updateLaneDimensions(this,10);

};

PMLane.prototype.updateLaneDimensions = function (lane, margin) {
    //lane = this;
    var children,
        limits,
        $shape,
        minW,
        minH;
    if (this.parent.family !== 'Canvas') {
        shape = this.parent
        PMLane.prototype.updateLaneDimensions.call(shape, lane, margin);
    }
    //pool
    if (this.getType() === 'bpmnPool') {
        this.updateResizeMinimuns();

    }
    return this;
};

PMLane.prototype.showOrHideResizeHandlers = function (visible) {

    var i;
    if (!visible) {
        visible = false;
    }
    for (i = 0; i < this.cornerResizeHandlers.getSize(); i += 1) {
        this.cornerResizeHandlers.get(i).setVisible(false);
    }

    for (i = 0; i < this.midResizeHandlers.getSize(); i += 1) {
        if (i === 1 || i === 2) {
            this.midResizeHandlers.get(i).setVisible(visible);
        } else {
            this.midResizeHandlers.get(i).setVisible(false);
        }
    }
    return this;
};

PMLane.prototype.updateAllRelatedDimensions = function () {
    var diffH = this.getHeight() - this.oldHeight,
        diffW = this.getWidth() - this.oldWidth;
    
    this.parent.setDimension(this.parent.getWidth() + diffW, this.parent.getHeight() + diffH);
    this.parent.updateAllLaneDimension();
    this.parent.paint();
    return this;
};

PMLane.prototype.stringify = function(){
    var inheritedJSON = PMShape.prototype.stringify.call(this),
        thisJSON = {
            name : this.getName(),
            proUid: this.getProUid(),
            relPosition: this.getRelPosition(),
            childPool: this.getChildPool()
            // TODO: CREATE PROPERTIES FOR THE BEHAVIORS
        };
    $.extend(true, inheritedJSON, thisJSON);
    return inheritedJSON;
};

PMLane.prototype.createBpmn = function(type) {
    var bpmnLaneset;
    if (this.parent.businessObject){
        //this.updateShapeParent(this.businessObject, this.parent.businessObject);
    } else {
        this.parent.createBusinesObject();

    }
    bpmnLaneset = this.createLaneset();
    this.createWithBpmn('bpmn:Lane', 'businessObject');
    //this.businessObject.
    this.updateBounds(this.businessObject.di);
    //this.updateShapeParent();
    this.updateSemanticParent(this.businessObject, bpmnLaneset) ;
    //this.updateShapeParent(this.businessObject, this.parent.businessObject);
    this.updateDiParent(this.businessObject.di,  this.parent.parent.businessObject.di);
};

PMLane.prototype.createLaneset = function() {
    var bpmnLaneset;
    if (!(_.findWhere(this.parent.businessObject.get('flowElements'), {$type: "bpmn:LaneSet"}))) {
        bpmnLaneset =  PMDesigner.moddle.create('bpmn:LaneSet');
        bpmnLaneset.$parent  = this.parent.businessObject;
        this.parent.businessObject.get('flowElements').push(bpmnLaneset);
    } else {
        bpmnLaneset = _.findWhere(this.parent.businessObject.get('flowElements'), {$type: "bpmn:LaneSet"});

    }
    return bpmnLaneset;
}

PMLane.prototype.updateSemanticParent = function(businessObject, newParent) {

    if (businessObject.$parent === newParent) {
        return;
    }

    var children;

    if (businessObject.$parent) {
        // remove from old parent
        children = businessObject.$parent.get('lanes');
        CollectionRemove(children, businessObject);
    }

    if (!newParent) {
        businessObject.$parent = null;
    } else {
        // add to new parent
        children = newParent.get('lanes');
        children.push(businessObject);
        businessObject.$parent = newParent;
    }
};

PMLane.prototype.updateLaneSetParent = function(businessObject, newParent) {
    if (businessObject.$lane) {
        // remove from old parent
        children = businessObject.$lane.get('flowNodeRef');
        CollectionRemove(children, businessObject);
    }
    if (!newParent) {
        //businessObject.$parent = null;
    } else {
        // add to new parent

        children = newParent.get('flowNodeRef');
        children.push(businessObject);
        businessObject.$lane = newParent;

    }
};
//remove bpmn section
PMLane.prototype.removeBpmn = function() {
    var bpmnLaneset;
    this.parent.updateBounds(this.parent.participantObject.di);
    PMShape.prototype.removeBpmn.call(this);

    if ((_.findWhere(this.parent.businessObject.get('flowElements'), {$type: "bpmn:LaneSet"}))) {
        bpmnLaneset =  _.findWhere(this.parent.businessObject.get('flowElements'), {$type: "bpmn:LaneSet"});
        if (bpmnLaneset.lanes < 1) {
            CollectionRemove(this.parent.businessObject.get('flowElements'), bpmnLaneset);
        }
        //this.parent.businessObject.get('flowElements').push(bpmnLaneset);

    }
};

PMLane.prototype.updateBpmn = function() {
    this.updateBounds(this.businessObject.di);

    //if (!this.parent.businessObject){
    //    //Here create busines object to new process
    //    this.parent.createBusinesObject();
    //    this.updateShapeParent(this.businessObject, this.parent.businessObject);
    //}

};
/**
 * Command create: command created when a lane is created (from the toolbar)
 * @class BPMNCommandCreateLane
 * @constructor
 */
var PMCommandCreateLane = function (receiver) {
    var NewObj = function (receiver) {
        PMUI.command.CommandCreate.call(this, receiver);
    };

    NewObj.prototype = new PMUI.command.CommandCreate(receiver);
    /**
     * Type of command of this object
     * @type {String}
     */
    NewObj.prototype.type = 'PMCommandCreateLane';


    /**
     * Executes the command
     */
    NewObj.prototype.execute = function () {
        PMUI.command.CommandCreate.prototype.execute.call(this);
        this.receiver.parent.bpmnLanes.insert(this.receiver);

        //this.receiver.parent.refactorLanePositionsAndDimensions();
        this.receiver.parent.setLanePositionAndDimension(this.receiver);
    };

    /**
     * Inverse executes the command a.k.a. undo
     */
    NewObj.prototype.undo = function () {
        PMUI.command.CommandCreate.prototype.undo.call(this);
        this.receiver.parent.bpmnLanes.remove(this.receiver);

        this.receiver.parent.updateOnRemoveLane(this.receiver);
    };
    NewObj.prototype.redo = function () {
        this.execute();
        return this;
    };
    return new NewObj(receiver);
};


/**
 * @class PMUI.behavior.ContainerDropBehavior
 * Encapsulates the drop behavior of a container
 * @extends PMUI.behavior.DropBehavior
 *
 * @constructor
 * Creates a new instance of the class
 * @param {Array} [selectors=[]] css selectors that this drop behavior will
 * accept
 */
var PMContainerDropBehavior = function (selectors) {
    PMUI.behavior.DropBehavior.call(this, selectors);

};
PMContainerDropBehavior.prototype = new PMUI.behavior.DropBehavior();
//PMUI.inheritFrom('PMUI.behavior.DropBehavior', ContainerDropBehavior);
/**
 * Type of the instances
 * @property {String}
 */
PMContainerDropBehavior.prototype.type = "PMContainerDropBehavior";
/**
 * Default selectors for this drop behavior
 * @property {String}
 */
PMContainerDropBehavior.prototype.defaultSelector = ".custom_shape";

/**
 * On drop handler for this drop behavior, creates shapes when dropped from the
 * toolbar, or move shapes among containers
 * @param {PMUI.draw.Shape} shape
 * @return {Function}
 */
PMContainerDropBehavior.prototype.onDrop = function (shape) {
    return function (e, ui) {
        var customShape = null,
            canvas = shape.getCanvas(),
            selection,
            sibling,
            i,
            command,
            coordinates,
            id,
            shapesAdded = [],
            containerBehavior = shape.containerBehavior;
        if (canvas.readOnly) {
            return false;
        }

        shape.entered = false;
        if (ui.helper && ui.helper.attr('id') === "drag-helper") {
            return false;
        }
        id = ui.draggable.attr('id');

        customShape = canvas.shapeFactory(id);
        if (customShape === null) {

            customShape = canvas.customShapes.find('id', id);
            if (!customShape || !shape.dropBehavior.dropHook(shape, e, ui)) {
                return false;
            }

            if (!(customShape.parent &&
                customShape.parent.id === shape.id)) {

                selection = canvas.currentSelection;
                for (i = 0; i < selection.getSize(); i += 1) {
                    sibling = selection.get(i);
                    coordinates = PMUI.getPointRelativeToPage(sibling);
                    coordinates = PMUI.pageCoordinatesToShapeCoordinates(shape, null,
                        coordinates.x, coordinates.y, customShape);
                    shapesAdded.push({
                        shape: sibling,
                        container: shape,
                        x: coordinates.x,
                        y: coordinates.y,
                        topLeft: false
                    });
                }
                command = new PMUI.command.CommandSwitchContainer(shapesAdded);
                command.execute();
                canvas.commandStack.add(command);
                canvas.multipleDrop = true;

            }

            // fix resize minWidth and minHeight and also fix the dimension
            // of this shape (if a child made it grow)
            shape.updateDimensions(10);
            canvas.updatedElement = null;

        } else {
            coordinates = PMUI.pageCoordinatesToShapeCoordinates(shape, e,null,null,customShape);
                if (PMUI.validCoordinatedToCreate(shape, e, customShape)) {
                    shape.addElement(customShape, coordinates.x, coordinates.y,
                        customShape.topLeftOnCreation);

                    //since it is a new element in the designer, we triggered the
                    //custom on create element event
                    canvas.updatedElement = customShape;
                if (customShape.getType() === 'PMLane') {
                    command = new PMCommandCreateLane(customShape);
                    canvas.commandStack.add(command);
                    command.execute();
                } else {
                    // create the command for this new shape
                    command = new PMUI.command.CommandCreate(customShape);
                    canvas.commandStack.add(command);
                    command.execute();

                }
            }
        }
    };
};


PMContainerDropBehavior.prototype.setSelectors = function (selectors, overwrite) {
    PMUI.behavior.DropBehavior.prototype
        .setSelectors.call(this, selectors, overwrite);
    this.selectors.push(".port");
    this.selectors.push(".custom_shape");
    return this;
};
var PoolContainerBehavior = function () {
};

PoolContainerBehavior.prototype = new PMUI.behavior.RegularContainerBehavior();
PoolContainerBehavior.prototype.type = "PoolContainerBehavior";

PoolContainerBehavior.prototype.addToContainer = function (container,
                                                              shape, x, y,
                                                              topLeftCorner) {

    if (shape.type === 'PMLane') {
        var shapeLeft = 0,
            shapeTop = 0,
            shapeWidth,
            shapeHeight,
            canvas,
            point,
            topLeftFactor = (topLeftCorner === true) ? 0 : 1;
        if (container.type === "Canvas") {
            canvas = container;
        } else {
            canvas = container.canvas;
        }
        shapeWidth = container.getWidth() - container.headLineCoord;
        shapeHeight = container.getHeight();

        shapeLeft += x - (shapeWidth / 2) * topLeftFactor;
        shapeTop += y - (shapeHeight / 2) * topLeftFactor;

        shapeLeft /= canvas.zoomFactor;
         shapeTop /= canvas.zoomFactor;
        //shape.setDimension(shapeWidth, shapeHeight);
        shape.setParent(container);
        container.getChildren().insert(shape);

       // point = container.getLanePoint();
        this.addShape(container, shape, shapeLeft, shapeTop);
        container.addLane(shape);
        shape.fixZIndex(shape, 0);
        // adds the shape to either the customShape arrayList or the regularShapes
        // arrayList if possible
        canvas.addToList(shape);

    } else {
        if (PMUI.draw.Geometry.pointInRectangle(new PMUI.util.Point(x, y),
                                      new PMUI.util.Point(container.headLineCoord, 0),
                                      new PMUI.util.Point(container.getWidth(),
                                          container.getHeight())
                                     )) {
            PMUI.behavior.RegularContainerBehavior.prototype.addToContainer.call(this, container,
                shape, x, y, topLeftCorner);

//            if (container.graphic) {
//                container.paint();
//            }

        } else {
           // alert('('+shape.getOldX()+','+shape.getOldY()+')');
            //shape.setPosition(shape.getOldX(), shape.getOldY());
            shape.setParent(container.canvas);
            container.canvas.getChildren().insert(shape);
            this.addShape(container.canvas, shape, shape.getOldX(), shape.getOldY());
            shape.fixZIndex(shape, 0);
            // adds the shape to either the customShape arrayList or the regularShapes
            // arrayList if possible
            container.canvas.addToList(shape);
            //TODO IF SHAPE IS IN POOL HEADER
        }
    }
};


PoolContainerBehavior.prototype.addShape = function (container, shape, x, y) {
    PMUI.behavior.RegularContainerBehavior.prototype.addShape.call(this, container, shape, x, y);

};

/**
 * Command resize: command resize when a poll is resized (mazimized or minimized)
 * @class BPMNCommandPoolResize
 * @constructor
 */
var PMCommandPoolResize = function (receiver) {
     PMUI.command.CommandResize.call(this, receiver);
    };
/**
 * Type of command of this object
 * @type {String}
 */
 //CommandChangeGatewayType.prototype = new PMUI.command.Command();
PMUI.inheritFrom('PMUI.command.CommandResize', PMCommandPoolResize);
PMCommandPoolResize.prototype.type = 'PMCommandPoolResize';

/**
 * Executes the command
 */
PMCommandPoolResize.prototype.execute = function () {

    PMUI.command.CommandResize.prototype.execute.call(this);
    //this.receiver.refreshChildDimensions();
    //if(this.receiver.refactorLanePositionsAndDimensions)
    //    this.receiver.refactorLanePositionsAndDimensions();
    //if (this.receiver.graphic) {
    //    this.receiver.paint();
    //}  
};

/**
 * Inverse executes the command a.k.a. undo
 */
PMCommandPoolResize.prototype.undo = function () {
    this.receiver.oldHeight = this.receiver.getHeight();
    PMUI.command.CommandResize.prototype.undo.call(this);
    this.receiver.updateOnResizeEnd();
//    if(this.receiver.refactorLanePositionsAndDimensions)
//        this.receiver.refactorLanePositionsAndDimensions();
    if (this.receiver.graphic) {
        this.receiver.paint();
    }
};

/**
 * Executes the command a.k.a redo
 */
PMCommandPoolResize.prototype.redo = function () {
    this.execute();
};

/*global jCore*/
var PMLaneResizeBehavior = function () {
};

PMLaneResizeBehavior.prototype = new PMUI.behavior.RegularResizeBehavior();
PMLaneResizeBehavior.prototype.type = "PMLaneResizeBehavior";


/**
 * Sets a shape's container to a given container
 * @param container
 * @param shape
 */
PMLaneResizeBehavior.prototype.onResizeStart = function (shape) {
    return PMUI.behavior.RegularResizeBehavior
        .prototype.onResizeStart.call(this, shape);
};
/**
 * Removes shape from its current container
 * @param shape
 */
PMLaneResizeBehavior.prototype.onResize = function (shape) {
    //RegularResizeBehavior.prototype.onResize.call(this, shape);
    return function (e, ui) {
        PMUI.behavior.RegularResizeBehavior
            .prototype.onResize.call(this, shape)(e, ui);
    };
};

PMLaneResizeBehavior.prototype.onResizeEnd = function (shape) {
    return function (e, ui) {
        var i,
            label,
            command;
        shape.resizing = false;
        shape.canvas.isResizing = false;
        // last resize
        PMUI.behavior.RegularResizeBehavior.prototype.onResize.call(this, shape)(e, ui);
        // show the handlers again
        shape.showOrHideResizeHandlers(true);

        // update the dimensions of the parent if possible (a shape might
        // have been resized out of the dimensions of its parent)
        //shape.parent.updateDimensions(0);

               

        if (shape.ports) {
            shape.firePortsChange();
        }

        // TESTING COMMANDS
        command = new PMCommandLaneResize(shape);
        shape.canvas.commandStack.add(command);
        command.execute();
        for (i = 0; i < shape.labels.getSize(); i += 1) {
            label = shape.labels.get(i);
            label.setLabelPosition(label.location, label.diffX, label.diffY);
        }

        return true;
    };
};

/**
 * @class CommandDelete
 * Class CommandDelete determines the actions executed when some shapes are deleted (redo) and the actions
 * executed when they're recreated (undo).
 *
 * Instances of this class are created in {@link Canvas#removeElements}.
 * @extends Command
 *
 * @constructor Creates an instance of the class CommandDelete
 * @param {Object} receiver The object that will execute the command
 */
PMCommandDelete = function (receiver) {
    PMUI.command.Command.call(this, receiver);

    /**
     * A stack of commandsConnect
     * @property {Array}
     */
    this.stackCommandConnect = [];

    /**
     * ArrayList that represents the selection that was active before deleting the elements
     * @property {ArrayList}
     */
    this.currentSelection = new  PMUI.util.ArrayList();

    /**
     * Reference to the current connection in the canvas
     * @property {Connection}
     */
    this.currentConnection = null;

    /**
     * List of all the elements related to the commands
     * @property {Array}
     */
    this.relatedElements = [];
    this.beforeRelPositions = [];
    this.tempLanes = new  PMUI.util.ArrayList();

    PMCommandDelete.prototype.initObject.call(this, receiver);
};

PMUI.inheritFrom('PMUI.command.Command', PMCommandDelete);

/**
 * Type of command
 * @property {String}
 */
PMCommandDelete.prototype.type = "PMCommandDelete";

/**
 * Instance initializer which uses options to extend the config options to initialize the instance
 * @param {Object} receiver The object that will execute the command
 * @private
 */
PMCommandDelete.prototype.initObject = function (receiver) {
    var i,
        shape;

    // move the current selection to this.currentSelection array
    for (i = 0; i < receiver.getCurrentSelection().getSize() > 0; i += 1) {
        shape = receiver.getCurrentSelection().get(i);
        this.currentSelection.insert(shape);
    }

    // save the currentConnection of the canvas if possible
    if (receiver.currentConnection) {
        this.currentConnection = receiver.currentConnection;
    }

};

/**
 * Saves and destroys connections and shapes
 * @private
 * @param {Object} shape
 * @param {boolean} root True if `shape` is a root element in the tree
 * @param {boolean} [fillArray] If set to true it'll fill `this.relatedElements` with the objects erased
 * @return {boolean}
 */
PMCommandDelete.prototype.saveAndDestroy = function (shape, root, fillArray) {
    var i,
        child,
        parent,
        children = null,
        connection,
        canvas = shape.canvas;

    if (shape.hasOwnProperty("children")) {
        children = shape.children;
    }

    // special function to be called as an afterwards
    // BIG NOTE: doesn't have to delete html
    if (shape.destroy) {
        shape.destroy();
    }

    for (i = 0; i < children.getSize(); i += 1) {
        child = children.get(i);
        this.saveAndDestroy(child, false, fillArray);
    }

    while (shape.ports && shape.ports.getSize() > 0) {
        connection = shape.ports.getFirst().connection;
        if (fillArray) {
            this.relatedElements.push(connection);
        }

        this.stackCommandConnect.push(
            new PMUI.command.CommandConnect(connection)
        );
        connection.saveAndDestroy();
    }

    // remove from the children array of its parent
    if (root) {
        parent = shape.parent;
        parent.getChildren().remove(shape);
        if (parent.isResizable()) {
            parent.resizeBehavior.updateResizeMinimums(shape.parent);
        }

        // remove from the currentSelection and from either the customShapes
        // arrayList or the regularShapes arrayList
        //canvas.removeFromList(shape);

        // remove the html only from the root
        shape.html = $(shape.html).detach()[0];

        if (shape.getType() === 'PMLane') {
            this.beforeRelPositions[shape.getID()] = shape.getRelPosition();
            shape.parent.bpmnLanes.remove(shape);
            //shape.parent.refactorLanePositionsAndDimensions();
        }

    }
    if (fillArray) {
        this.relatedElements.push(shape);
    }
    // remove from the currentSelection and from either the customShapes
    // arrayList or the regularShapes arrayList
    canvas.removeFromList(shape);
    return true;
};
/**
 * Executes the command
 *
 * @chainable
 */
PMCommandDelete.prototype.execute = function () {
    var shape,
        i,
        canvas = this.receiver,
        currentConnection,
        stringified,
        fillArray = false,
        mainShape = null;
    if (this.relatedElements.length === 0) {
        fillArray = true;
    }

    canvas.emptyCurrentSelection();

    // copy from this.currentConnection
    for (i = 0; i < this.currentSelection.getSize(); i += 1) {
        shape = this.currentSelection.get(i);
        canvas.addToSelection(shape);
    }
    if (canvas.currentSelection.getSize() === 1) {
        mainShape = shape;
    }
    // remove the elements in the canvas current selection

    stringified = [];

    if (shape && shape.getType() === 'PMPool') {
        for (i = 0; i < shape.bpmnLanes.getSize(); i += 1) {
            this.tempLanes.insert(shape.bpmnLanes.get(i));
        }
    }

    while (canvas.getCurrentSelection().getSize() > 0) {
        shape = canvas.getCurrentSelection().getFirst();


//        // TESTING JSON
//        canvas.stringifyTest(JSON.stringify(
//            shape.stringify()
//        ));

        this.saveAndDestroy(shape, true, fillArray);

       // stringified.push(shape.stringify());
//        this.saveAndDestroy(shape, true);

    }
    if (shape && shape.getType() === 'PMLane') {
        //shape.parent.refactorLanePositionsAndDimensions();

        for (i = 0; i < shape.parent.bpmnLanes.getSize(); i += 1) {
            shape.parent.bpmnLanes.get(i)
                .refreshChildrenPositions(true)
                .refreshConnections(false, false);
        }
    }



    // destroy the currentConnection
    canvas.currentConnection = this.currentConnection;
    currentConnection = canvas.currentConnection;
    if (currentConnection) {

//        // TESTING JSON
//        canvas.stringifyTest(JSON.stringify(
//            this.currentConnection.stringify()
//        ));

        // add to relatedElements just in the case when only a connection is
        // selected and deleted
        this.relatedElements.push(currentConnection);

        this.stackCommandConnect.push(
            new PMUI.command.CommandConnect(currentConnection)
        );

        currentConnection.saveAndDestroy();
        currentConnection = null;
    }
    canvas.triggerRemoveEvent(mainShape, this.relatedElements);
    return this;
};

/**
 * Inverse executes the command a.k.a. undo
 *
 * @chainable
 */
PMCommandDelete.prototype.undo = function () {
    // undo recreates the shapes
    var i,
        shape,
        mainShape = this.currentSelection.getFirst(),
        size,
        haveLanes = false,
        shapeBefore,
        j,
        element;
    this.currentSelection.sort(function (lane1, lane2) {
        return lane1.relPosition > lane2.relPosition;
    });

    for (i = 0; i < this.currentSelection.getSize(); i += 1) {
        shape = this.currentSelection.get(i);
        shapeBefore = null;
        // add to the canvas array of regularShapes and customShapes
        shape.canvas.addToList(shape);
        // add to the children of the parent
        shape.parent.getChildren().insert(shape);
       // PMUI.behavior.ResizeBehavior.prototype.updateResizeMinimums(shape.parent);
        shape.showOrHideResizeHandlers(false);

        if (shape.getType() !== 'PMLane') {
            shape.parent.html.appendChild(shape.getHTML());
        } else {
            shapeBefore = shape.parent.bpmnLanes
                .get(this.beforeRelPositions[shape.getID()] - 1);

            //console.log(shapeBefore);

            if (shapeBefore) {
                shape.parent.html
                    .insertBefore(shape.getHTML(), shapeBefore.getHTML());
            } else {
                shape.parent.html.appendChild(shape.getHTML());
            }
            size = shape.parent.bpmnLanes.getSize();
            for (j = this.beforeRelPositions[shape.getID()] - 1; j < size; j += 1) {
                element = shape.parent.bpmnLanes.get(j);
                element.setRelPosition(j + 2);
            }
            shape.setRelPosition(this.beforeRelPositions[shape.getID()]);
            shape.parent.bpmnLanes.insert(shape);
            shape.parent.bpmnLanes.sort(shape.parent.comparisonFunction);
            shape.parent.updateAllLaneDimension();
//            haveLanes = true;
        }
        if (shape.getType() === 'PMPool'){
            for (i = 0; i < this.tempLanes.getSize(); i += 1) {
                shape.bpmnLanes.insert(this.tempLanes.get(i));
            }
            shape.updateAllLaneDimension();
        }
    }


    // reconnect using the stack of commandConnect
    for (i = this.stackCommandConnect.length - 1; i >= 0; i -= 1) {
        //this.stackCommandConnect[i].redo();
        this.stackCommandConnect[i].buildConnection();
    }

    this.receiver.triggerCreateEvent(mainShape, this.relatedElements);
    if (haveLanes) {
        // mainShape.parent.bpmnLanes.sort(mainShape.parent.comparisonFunction);
        //mainShape.parent.refactorLanePositionsAndDimensions();
        //mainShape.parent.setLanePositionAndDimension(mainShape);

//        mainShape.parent.setDimension(mainShape.parent.getWidth(), mainShape.parent.getHeight() + mainShape.getHeight());
//        mainShape.parent.paint();
        //mainShape.parent.updateAllLaneDimension();
        for (i = 0; i < mainShape.parent.bpmnLanes.getSize(); i += 1) {
            mainShape.parent.bpmnLanes.get(i)
                .refreshChildrenPositions(true)
                .refreshConnections(false);
        }

    }

    return this;
};
/**
 * Executes the command (a.k.a redo)
 * @chainable
 */
PMCommandDelete.prototype.redo = function () {
    this.execute();
    return this;
};
/**
 * Command resize: command resize when a poll is resized (mazimized or minimized)
 * @class BPMNCommandPoolResize
 * @constructor
 */
var PMCommandLaneResize = function(receiver){
    PMUI.command.CommandResize.call(this, receiver);
};
/**
 * Type of command of this object
 * @type {String}
 */
    //CommandChangeGatewayType.prototype = new PMUI.command.Command();
PMUI.inheritFrom('PMUI.command.CommandResize', PMCommandLaneResize);
PMCommandLaneResize.prototype.type = 'PMCommandLaneResize';

/**
 * Executes the command
 */
PMCommandLaneResize.prototype.execute = function (){

    PMUI.command.CommandResize.prototype.execute.call(this);
    this.receiver.updateAllRelatedDimensions();
};

/**
 * Inverse executes the command a.k.a. undo
 */
PMCommandLaneResize.prototype.undo = function () {
    this.receiver.oldWidth = this.receiver.getWidth();
    this.receiver.oldHeight = this.receiver.getHeight();
            PMUI.command.CommandResize.prototype.undo.call(this);
    this.receiver.updateAllRelatedDimensions();

};

/**
 * Executes the command a.k.a redo
 */
PMCommandLaneResize.prototype.redo = function () {
    this.execute();
};

var CommandChangeEventMarker = function (receiver, options) {
    PMUI.command.Command.call(this, receiver);
    this.before = null;
    this.after = null;
    CommandChangeEventMarker.prototype.initObject.call(this, options);
};

//CommandChangeGatewayType.prototype = new PMUI.command.Command();
PMUI.inheritFrom('PMUI.command.Command', CommandChangeEventMarker);
/**
 * Type of the instances of this class
 * @property {String}
 */
CommandChangeEventMarker.prototype.type = "CommandChangeEventMarker";

/**
 * Initializes the command parameters
 * @param {PMUI.draw.Core} receiver The object that will perform the action
 */
CommandChangeEventMarker.prototype.initObject = function (options) {

    var parsedClass = options;
    this.layer = this.receiver.getLayers().get(0);
    //layer.setZoomSprites(newSprite);

    this.before = {
        zoomSprite: this.layer.zoomSprites,
        marker: this.receiver.evn_marker
    };
//    if (options === 'COMPLEX') {
//        parsedClass = 'EXCLUSIVE';
//    }
    this.after = {
        zoomSprite: [
            'mafe-event-' + this.receiver.getEventType().toLowerCase() + '-' +
                parsedClass.toLowerCase() + '-16',
            'mafe-event-' + this.receiver.getEventType().toLowerCase() + '-' +
                parsedClass.toLowerCase() + '-24',
            'mafe-event-' + this.receiver.getEventType().toLowerCase() + '-' +
                parsedClass.toLowerCase() + '-33',
            'mafe-event-' + this.receiver.getEventType().toLowerCase() + '-' +
                parsedClass.toLowerCase() + '-41',
            'mafe-event-' + this.receiver.getEventType().toLowerCase() + '-' +
                parsedClass.toLowerCase() + '-49'
        ],
        marker: options
    };
};

/**
 * Executes the command, changes the position of the element, and if necessary
 * updates the position of its children, and refreshes all connections
 */
CommandChangeEventMarker.prototype.execute = function () {
    var menuShape;
    this.layer.setZoomSprites(this.after.zoomSprite);
    this.layer.paint();

    this.receiver.setEventMarker(this.after.marker);
    this.receiver
        .updateBpmEventMarker(this.receiver.getBpmnElementType());
    PMDesigner.project.updateElement([]);
    menuShape = PMDesigner.getMenuFactory(this.receiver.getEventType());
    this.receiver.setContextMenu(menuShape);

};

/**
 * Returns to the state before the command was executed
 */
CommandChangeEventMarker.prototype.undo = function () {
    this.layer.setZoomSprites(this.before.zoomSprite);
    this.layer.paint();
    this.receiver.setEventMarker(this.before.marker);
    this.receiver
        .updateBpmEventMarker(this.receiver.getBpmnElementType());
    this.receiver.extendedType = this.before.marker;
    PMDesigner.project.setDirty(true);
    $(this.receiver.html).trigger('changeelement');

    menuShape = PMDesigner.getMenuFactory(this.before.marker);
    this.receiver.setContextMenu(menuShape);
};

/**
 *  Executes the command again after an undo action has been done
 */
CommandChangeEventMarker.prototype.redo = function () {
    this.execute();
};


var CanvasContainerBehavior = function () {
};

CanvasContainerBehavior.prototype = new PMUI.behavior.RegularContainerBehavior();
CanvasContainerBehavior.prototype.type = "CanvasContainerBehavior";


CanvasContainerBehavior.prototype.addShape = function (container, shape, x, y) {
    shape.setPosition(x, y);
    //insert the shape HTML to the DOM
    if (shape instanceof PMArtifact && shape.art_type === 'GROUP') {
        $(container.getHTML()).prepend(shape.getHTML());
    } else {
        container.getHTML().appendChild(shape.getHTML());
    }
    shape.updateHTML();
    shape.paint();
    shape.applyBehaviors();
    //shape.defineEvents();
    shape.attachListeners();
    return this;

};

'use strict';

/**
 * An empty collection stub. Use {@link RefsCollection.extend} to extend a
 * collection with ref semantics.
 *
 * @classdesc A change and inverse-reference aware collection with set semantics.
 *
 * @class RefsCollection
 */
function RefsCollection() { }

/**
 * Extends a collection with {@link Refs} aware methods
 *
 * @memberof RefsCollection
 * @static
 *
 * @param  {Array<Object>} collection
 * @param  {Refs} refs instance
 * @param  {Object} property represented by the collection
 * @param  {Object} target object the collection is attached to
 *
 * @return {RefsCollection<Object>} the extended array
 */
function extend(collection, refs, property, target) {

    var inverseProperty = property.inverse;

    /**
     * Removes the given element from the array and returns it.
     *
     * @method RefsCollection#remove
     *
     * @param {Object} element the element to remove
     */
    collection.remove = function(element) {
        var idx = this.indexOf(element);
        if (idx !== -1) {
            this.splice(idx, 1);

            // unset inverse
            refs.unset(element, inverseProperty, target);
        }

        return element;
    };

    /**
     * Returns true if the collection contains the given element
     *
     * @method RefsCollection#contains
     *
     * @param {Object} element the element to check for
     */
    collection.contains = function(element) {
        return this.indexOf(element) !== -1;
    };

    /**
     * Adds an element to the array, unless it exists already (set semantics).
     *
     * @method RefsCollection#add
     *
     * @param {Object} element the element to add
     */
    collection.add = function(element) {

        if (!this.contains(element)) {
            this.push(element);

            // set inverse
            refs.set(element, inverseProperty, target);
        }
    };

    return collection;
}


//module.exports.extend = extend;
'use strict';

//var Collection = require('./collection');

function hasOwnProperty(e, property) {
    return Object.prototype.hasOwnProperty.call(e, property.name || property);
}


function defineCollectionProperty(ref, property, target) {
    Object.defineProperty(target, property.name, {
        enumerable: property.enumerable,
        value: Collection.extend(target[property.name] || [], ref, property, target)
    });
}


function defineProperty(ref, property, target) {

    var inverseProperty = property.inverse;

    var _value = target[property.name];

    Object.defineProperty(target, property.name, {
        enumerable: property.enumerable,

        get: function() {
            return _value;
        },

        set: function(value) {

            // return if we already performed all changes
            if (value === _value) {
                return;
            }

            var old = _value;

            // temporary set null
            _value = null;

            if (old) {
                ref.unset(old, inverseProperty, target);
            }

            // set new value
            _value = value;

            // set inverse value
            ref.set(_value, inverseProperty, target);
        }
    });

}

/**
 * Creates a new references object defining two inversly related
 * attribute descriptors a and b.
 *
 * <p>
 *   When bound to an object using {@link Refs#bind} the references
 *   get activated and ensure that add and remove operations are applied
 *   reversely, too.
 * </p>
 *
 * <p>
 *   For attributes represented as collections {@link Refs} provides the
 *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
 *   that must be used to properly hook into the inverse change mechanism.
 * </p>
 *
 * @class Refs
 *
 * @classdesc A bi-directional reference between two attributes.
 *
 * @param {Refs.AttributeDescriptor} a property descriptor
 * @param {Refs.AttributeDescriptor} b property descriptor
 *
 * @example
 *
 * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
 *
 * var car = { name: 'toyota' };
 * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
 *
 * refs.bind(car, 'wheels');
 *
 * car.wheels // []
 * car.wheels.add(wheels[0]);
 * car.wheels.add(wheels[1]);
 *
 * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
 *
 * wheels[0].car // { name: 'toyota' };
 * car.wheels.remove(wheels[0]);
 *
 * wheels[0].car // undefined
 */
function Refs(a, b) {

    if (!(this instanceof Refs)) {
        return new Refs(a, b);
    }

    // link
    a.inverse = b;
    b.inverse = a;

    this.props = {};
    this.props[a.name] = a;
    this.props[b.name] = b;
}

/**
 * Binds one side of a bi-directional reference to a
 * target object.
 *
 * @memberOf Refs
 *
 * @param  {Object} target
 * @param  {String} property
 */
Refs.prototype.bind = function(target, property) {
    if (typeof property === 'string') {
        if (!this.props[property]) {
            throw new Error('no property <' + property + '> in ref');
        }
        property = this.props[property];
    }

    if (property.collection) {
        defineCollectionProperty(this, property, target);
    } else {
        defineProperty(this, property, target);
    }
};

Refs.prototype.ensureBound = function(target, property) {
    if (!hasOwnProperty(target, property)) {
        this.bind(target, property);
    }
};

Refs.prototype.unset = function(target, property, value) {

    if (target) {
        this.ensureBound(target, property);

        if (property.collection) {
            target[property.name].remove(value);
        } else {
            target[property.name] = undefined;
        }
    }
};

Refs.prototype.set = function(target, property, value) {

    if (target) {
        this.ensureBound(target, property);

        if (property.collection) {
            target[property.name].add(value);
        } else {
            target[property.name] = value;
        }
    }
};
//
//module.exports = Refs;


/**
 * An attribute descriptor to be used specify an attribute in a {@link Refs} instance
 *
 * @typedef {Object} Refs.AttributeDescriptor
 * @property {String} name
 * @property {boolean} [collection=false]
 * @property {boolean} [enumerable=false]
 */
'use strict';

//
var diRefs = new Refs({ name: 'bpmnElement', enumerable: true }, { name: 'di' });


function BpmnTreeWalker(handler) {

    // list of containers already walked
    var handledProcesses = [];

    // list of elements to handle deferred to ensure
    // prerequisites are drawn
    var deferred = [];

    ///// Helpers /////////////////////////////////

    function contextual(fn, ctx) {
        return function(e) {
            fn(e, ctx);
        };
    }

    function is(element, type) {
        return element.$instanceOf(type);
    }

    function visit(element, ctx) {

        var gfx = element.gfx;

        // avoid multiple rendering of elements
        if (gfx) {
            throw new Error('already rendered <' + element.id + '>');
        }

        // call handler
        return handler.element(element, ctx);
    }

    function visitRoot(element, diagram) {
        return handler.root(element, diagram);
    }

    function visitIfDi(element, ctx) {
        try {
            if (element.di) {
                return visit(element, ctx);
            }
        } catch (e) {
            logError(e.message, { element: element, error: e });
        }
    }

    function logError(message, context) {
        handler.error(message, context);
    }

    ////// DI handling ////////////////////////////

    function registerDi(di) {
        var bpmnElement = di.bpmnElement;

        if (bpmnElement) {
            diRefs.bind(bpmnElement, 'di');
            bpmnElement.di = di;
        } else {
            logError('no bpmnElement for <' + di.$type + '#' + di.id + '>', { element: di });
        }
    }

    function handleDiagram(diagram) {
        handlePlane(diagram.plane);
    }

    function handlePlane(plane) {
        registerDi(plane);

        _.forEach(plane.planeElement, handlePlaneElement);
    }

    function handlePlaneElement(planeElement) {
        registerDi(planeElement);
    }


    ////// Semantic handling //////////////////////

    function handleDefinitions(definitions, diagram) {
        // make sure we walk the correct bpmnElement

        var diagrams = definitions.diagrams;

        if (diagram && diagrams.indexOf(diagram) === -1) {
            throw new Error('diagram not part of bpmn:Definitions');
        }

        if (!diagram && diagrams && diagrams.length) {
            diagram = diagrams[0];
        }

        // no diagram -> nothing to import
        if (!diagram) {
            return;
        }

        // load DI from selected diagram only
        handleDiagram(diagram);

        var plane = diagram.plane,
            rootElement = plane.bpmnElement;

        if (!rootElement) {
            throw new Error('no rootElement referenced in BPMNPlane <' + diagram.plane.id + '>');
        }


        var ctx = visitRoot(rootElement, plane);

        if (is(rootElement, 'bpmn:Process')) {
            handleProcess(rootElement, ctx);
        } else if (is(rootElement, 'bpmn:Collaboration')) {
            handleCollaboration(rootElement, ctx);

            // force drawing of everything not yet drawn that is part of the target DI
            handleUnhandledProcesses(definitions.rootElements, ctx);
        } else {
            throw new Error('unsupported root element for bpmndi:Diagram <' + rootElement.$type + '>');
        }

        // handle all deferred elements
        handleDeferred(deferred);
    }

    function handleDeferred(deferred) {
        _.forEach(deferred, function(d) { d(); });
    }

    function handleProcess(process, context) {
        handleFlowElementsContainer(process, context);
        handleIoSpecification(process.ioSpecification, context);

        handleArtifacts(process.artifacts, context);

        // log process handled
        handledProcesses.push(process);
    }

    function handleUnhandledProcesses(rootElements) {

        // walk through all processes that have not yet been drawn and draw them
        // if they contain lanes with DI information.
        // we do this to pass the free-floating lane test cases in the MIWG test suite
        var processes = _.filter(rootElements, function(e) {
            return is(e, 'bpmn:Process') && e.laneSets && handledProcesses.indexOf(e) === -1;
        });

        processes.forEach(contextual(handleProcess));
    }

    function handleMessageFlow(messageFlow, context) {
        visitIfDi(messageFlow, context);
    }

    function handleMessageFlows(messageFlows, context) {
        if (messageFlows) {
            _.forEach(messageFlows, contextual(handleMessageFlow, context));
        }
    }

    function handleDataAssociation(association, context) {
        visitIfDi(association, context);
    }

    function handleDataInput(dataInput, context) {
        visitIfDi(dataInput, context);
    }

    function handleDataOutput(dataOutput, context) {
        visitIfDi(dataOutput, context);
    }

    function handleArtifact(artifact, context) {

        // bpmn:TextAnnotation
        // bpmn:Group
        // bpmn:Association

        visitIfDi(artifact, context);
    }

    function handleArtifacts(artifacts, context) {
        _.forEach(artifacts, contextual(handleArtifact, context));
    }

    function handleIoSpecification(ioSpecification, context) {

        if (!ioSpecification) {
            return;
        }

        _.forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));
        _.forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
    }

    function handleSubProcess(subProcess, context) {
        handleFlowElementsContainer(subProcess, context);
        handleArtifacts(subProcess.artifacts, context);
    }

    function handleFlowNode(flowNode, context) {
        var childCtx = visitIfDi(flowNode, context);

        if (is(flowNode, 'bpmn:SubProcess')) {
            handleSubProcess(flowNode, childCtx || context);
        }
    }

    function handleSequenceFlow(sequenceFlow, context) {
        visitIfDi(sequenceFlow, context);
    }

    function handleDataElement(dataObject, context) {
        visitIfDi(dataObject, context);
    }

    function handleBoundaryEvent(dataObject, context) {
        visitIfDi(dataObject, context);
    }

    function handleLane(lane, context) {
        var newContext = visitIfDi(lane, context);

        if (lane.childLaneSet) {
            handleLaneSet(lane.childLaneSet, newContext || context);
        } else {
            var filterList = _.filter(lane.flowNodeRef, function(e) {
                return e.$type !== 'bpmn:BoundaryEvent';
            });
            handleFlowElements(filterList, newContext || context);
        }
    }

    function handleLaneSet(laneSet, context) {
        _.forEach(laneSet.lanes, contextual(handleLane, context));
    }

    function handleLaneSets(laneSets, context) {
        _.forEach(laneSets, contextual(handleLaneSet, context));
    }

    function handleFlowElementsContainer(container, context) {

        if (container.laneSets) {
            handleLaneSets(container.laneSets, context);
            handleNonFlowNodes(container.flowElements);
        } else {
            handleFlowElements(container.flowElements, context);
        }
    }

    function handleNonFlowNodes(flowElements, context) {
        _.forEach(flowElements, function(e) {
            if (is(e, 'bpmn:SequenceFlow')) {
                deferred.push(function() {
                    handleSequenceFlow(e, context);
                });
            } else if (is(e, 'bpmn:BoundaryEvent')) {
                deferred.unshift(function() {
                    handleBoundaryEvent(e, context);
                });
            } else if (is(e, 'bpmn:DataObject')) {
                // SKIP (assume correct referencing via DataObjectReference)
            } else if (is(e, 'bpmn:DataStoreReference')) {
                handleDataElement(e, context);
            } else if (is(e, 'bpmn:DataObjectReference')) {
                handleDataElement(e, context);
            }
        });
    }

    function handleFlowElements(flowElements, context) {
        _.forEach(flowElements, function(e) {
            if (is(e, 'bpmn:SequenceFlow')) {
                deferred.push(function() {
                    handleSequenceFlow(e, context);
                });
            } else if (is(e, 'bpmn:BoundaryEvent')) {
                deferred.unshift(function() {
                    handleBoundaryEvent(e, context);
                });
            } else if (is(e, 'bpmn:FlowNode')) {
                handleFlowNode(e, context);

                if (is(e, 'bpmn:Activity')) {

                    handleIoSpecification(e.ioSpecification, context);

                    // defer handling of associations
                    deferred.push(function() {
                        _.forEach(e.dataInputAssociations, contextual(handleDataAssociation, context));
                        _.forEach(e.dataOutputAssociations, contextual(handleDataAssociation, context));
                    });
                }
            } else if (is(e, 'bpmn:DataObject')) {
                // SKIP (assume correct referencing via DataObjectReference)
            } else if (is(e, 'bpmn:DataStoreReference')) {
                handleDataElement(e, context);
            } else if (is(e, 'bpmn:DataObjectReference')) {
                handleDataElement(e, context);
            } else {
                logError(
                    'unrecognized flowElement <' + e.$type + '> in context ' + (context ? context.id : null),
                    { element: e, context: context });
            }
        });
    }

    function handleParticipant(participant, context) {
        var newCtx = visitIfDi(participant, context);

        var process = participant.processRef;
        if (process) {
            handleProcess(process, newCtx || context);
        }
    }

    function handleCollaboration(collaboration) {

        _.forEach(collaboration.participants, contextual(handleParticipant));

        handleArtifacts(collaboration.artifacts);

        handleMessageFlows(collaboration.messageFlows);
    }


    ///// API ////////////////////////////////

    return {
        handleDefinitions: handleDefinitions
    };
}

//module.exports = BpmnTreeWalker;
//var BpmnTreeWalker = require('./BpmnTreeWalker');


/**
 * Import the definitions into a diagram.
 *
 * Errors and warnings are reported through the specified callback.
 *
 * @param  {Diagram} diagram
 * @param  {ModdleElement} definitions
 * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done
 */
var importBpmnDiagram = function (definitions) {
    var error;
    this.participants = [];
    this.lanes = [];
    this.laneRelPosition = 0;
    this.eventMarkerMap = {
        'CATCH': {
            'bpmn:MessageEventDefinition': 'MESSAGECATCH',
            'bpmn:TimerEventDefinition': 'TIMER',
            'bpmn:ConditionalEventDefinition': 'CONDITIONAL',
            'bpmn:LinkEventDefinition': 'LINKCATCH',
            'bpmn:SignalEventDefinition': 'SIGNALCATCH',
            'bpmn:CompensateEventDefinition': 'COMPENSATIONTHROW'
        },
        'THROW': {
            'bpmn:MessageEventDefinition': 'MESSAGETHROW',
            'bpmn:TimerEventDefinition': 'TIMER',
            'bpmn:ConditionalEventDefinition': 'CONDITIONAL',
            'bpmn:CompensateEventDefinition': 'COMPENSATIONTHROW',
            'bpmn:SignalEventDefinition': 'SIGNALTHROW'
        }

    };
    this.taskType = {
        'bpmn:Task': 'NONE',
        'bpmn:SendTask': 'SENDTASK',
        'bpmn:ReceiveTask': 'RECEIVETASK',
        'bpmn:UserTask': 'USERTASK',
        'bpmn:ServiceTask': 'SERVICETASK',
        'bpmn:ScriptTask': 'SCRIPTTASK',
        'bpmn:ManualTask': 'MANUALTASK',
        'bpmn:BusinessRuleTask': 'BUSINESSRULE'
    }

    //eventBus.fire('import.start');
    try {
        PMDesigner.businessObject = definitions;
        this.parse(definitions);
    } catch (e) {
        error = e;
    }
    //eventBus.fire(error ? 'import.error' : 'import.success', { error: error, warnings: warnings });
    //done(error, warnings);
};
importBpmnDiagram.prototype.parse = function (definitions) {
    var self =  this, sidebarCanvas = [], i;

    var visitor = {

        root: function(element) {
            //var canvas = PMUI.getActiveCanvas();
            //
            if (element.$type === 'bpmn:Collaboration') {
                // TODO IF THERE IS COLLABORATIONS
                return self.addParticipant(element);


            } else {
                for (i = 0; i < PMDesigner.sidebar.length; i += 1) {
                    sidebarCanvas = sidebarCanvas.concat(PMDesigner.sidebar[i].getSelectors());
                    jQuery(".bpmn_shapes").append(PMDesigner.sidebar[i].getHTML());
                }
                sidebarCanvas.splice(15, 1);  //to remove lane selector
                // sidebarCanvas = sidebarCanvas + ',.mafe-event-start';
                sidebarCanvas = sidebarCanvas.concat('.mafe-event-start');
                sidebarCanvas = sidebarCanvas.concat('.pmui-pmactivity');
                sidebarCanvas = sidebarCanvas.concat('.mafe-event-end');


                var canvas =  PMDesigner.project.buildCanvas(sidebarCanvas, {name: 'Main'});
                PMUI.setActiveCanvas(canvas);
                jQuery("#p-center-layout").scroll(canvas.onScroll(canvas, jQuery("#p-center-layout")));

                element.id = canvas.getID();
                canvas.businessObject = element;

            }

            //return  importer.add(element);

        },

        element: function(element, parentShape) {

            return self.addElement(element, parentShape);

        },
        error: function(message, context) {
            console.log('add error');
            //warnings.push({ message: message, context: context });
        }
    };

    var walker = new BpmnTreeWalker(visitor);

    // import
    walker.handleDefinitions(definitions);
};

/**
 *  import bpmn participants
 * @param element
 * @returns {importBpmnDiagram}
 */
importBpmnDiagram.prototype.addParticipant = function (collaboration) {
    var canvas = PMUI.getActiveCanvas(),
        i,
        j,
        participants,
        participant,
        sidebarCanvas = [];
    participants = collaboration.participants;
    for (i = 0; i < participants.length; i += 1) {
        participant = participants[i];
        this.participants.push(participant);
        for (j = 0; j < PMDesigner.sidebar.length; j += 1) {
            sidebarCanvas = sidebarCanvas.concat(PMDesigner.sidebar[j].getSelectors());
            jQuery(".bpmn_shapes").append(PMDesigner.sidebar[j].getHTML());
        }
        sidebarCanvas.splice(15, 1);  //to remove lane selector
        // sidebarCanvas = sidebarCanvas + ',.mafe-event-start';
        sidebarCanvas = sidebarCanvas.concat('.mafe-event-start');
        sidebarCanvas = sidebarCanvas.concat('.pmui-pmactivity');
        sidebarCanvas = sidebarCanvas.concat('.mafe-event-end');


        var canvas =  PMDesigner.project.buildCanvas(sidebarCanvas, {name: 'Main'});
        canvas.businessObject = participant.processRef;
        canvas.businessObject.di = participant.$parent.di;
        PMUI.setActiveCanvas(canvas);
        canvas.buildingDiagram = true;
        jQuery("#p-center-layout").scroll(canvas.onScroll(canvas, jQuery("#p-center-layout")));
        //participant.participantObject = participant;
        //participant.businessObject = participant.processRef;
        //this.addElement(participant);
    }
    return this;
};

importBpmnDiagram.prototype.getOwnProperties = function (element) {
    var ownProp = false,
        parent,
        taskType,
        marker,
        behavior,
        typeMap = {
            'bpmn:Lane': 'LANE',
            'bpmn:Participant': 'POOL',
            'bpmn:StartEvent': 'START',
            'bpmn:EndEvent': 'END',
            'bpmn:Task': 'TASK',
            'bpmn:SendTask': 'TASK',
            'bpmn:ReceiveTask': 'TASK',
            'bpmn:UserTask': 'TASK',
            'bpmn:ServiceTask': 'TASK',
            'bpmn:ScriptTask': 'TASK',
            'bpmn:ManualTask': 'TASK',
            'bpmn:CallActivity': 'TASK',
            'bpmn:BusinessRuleTask': 'TASK',
            'bpmn:SubProcess': 'SUB_PROCESS',
            'bpmn:ExclusiveGateway': 'EXCLUSIVE',
            'bpmn:ParallelGateway': 'PARALLEL',
            'bpmn:InclusiveGateway': 'INCLUSIVE',
            'bpmn:EventBasedGateway': 'EVENTBASED',
            'bpmn:IntermediateCatchEvent': 'INTERMEDIATE',
            'bpmn:IntermediateThrowEvent': 'INTERMEDIATE',
            'bpmn:TextAnnotation': 'TEXT_ANNOTATION',
            'bpmn:DataStoreReference': 'DATASTORE',
            'bpmn:DataObjectReference': 'DATAOBJECT',
            'bpmn:Group': 'GROUP'
        };
    switch (typeMap[element.$type]) {
    case 'START':
        if (element.eventDefinitions && element.eventDefinitions[0]) {
            marker = this.eventMarkerMap['CATCH'][element.eventDefinitions[0].$type];
        }

        ownProp = {
            'evn_name': element.name,
            'evn_marker': marker ? marker : 'EMPTY',
        };
        break;
    case 'END':
        if (element.eventDefinitions && element.eventDefinitions[0]) {
            marker = this.eventMarkerMap['THROW'][element.eventDefinitions[0].$type];
        }
        ownProp = {
            'evn_name': element.name,
            'evn_marker': marker ? marker : 'EMPTY',
        };
        break;
    case 'INTERMEDIATE':
        behavior = (element.$type === 'bpmn:IntermediateCatchEvent') ? 'CATCH' : 'THROW';
        marker = this.eventMarkerMap[behavior][element.eventDefinitions[0].$type];
        ownProp = {
            'evn_behavior': behavior,
            'evn_marker': marker ? marker : 'MESSAGECATCH',
            'evn_name': element.name
        };
        break;
    case 'SUB_PROCESS':
        ownProp = {
            'act_name': element.name,
            'act_type': 'SUB_PROCESS'
        };
        break;
    case 'TASK':
        taskType = this.taskType[element.$type];
        ownProp = {
            'act_name': element.name,
            'act_task_type': taskType
        };
        break;
    case 'EXCLUSIVE':
        ownProp = {
            'gat_name': element.name
        };
        break;
    case 'PARALLEL':
        ownProp = {
            'gat_name': element.name,
            'gat_type': 'PARALLEL'
        };
        break;
    case 'INCLUSIVE':
        ownProp = {
            'gat_name': element.name,
            'gat_type': 'INCLUSIVE'
        };
        break;
    case 'EVENTBASED':
        ownProp = {
            'gat_name': element.name,
            'gat_type': 'EVENTBASED'
        };
        break;
    case 'POOL':
        ownProp = {
            'par_name': element.name
        };
        break;
    case 'LANE':
        this.lanes.push(element);
        parent = this.getParentData(element);
        this.laneRelPosition += 1;
        ownProp = {
            'lan_name': element.name,
            'bou_container': 'bpmnPool',
            'bou_element': parent.parentUid,
            'bou_rel_position': this.laneRelPosition,
            'bou_x': 40,
            'bou_y': element.di.bounds.y - parent.y
        };
        break;
    case 'GROUP':
    case 'TEXT_ANNOTATION':
        ownProp = {
            'art_name': element.text
        };
        break;
    case 'DATASTORE':
    case 'DATAOBJECT':
        ownProp = {
            'dat_name': element.name
        };
        break;
    }
    return {'properties': ownProp, 'type': typeMap[element.$type]};
};
/**
 * gets parent data
 * @param element
 * @param parentShape
 */
importBpmnDiagram.prototype.getParentData = function (element) {
    var i,
        participant,
        uid,
        canvas = PMUI.getActiveCanvas(),
        pool,
        currentProcess =  element.$parent.$parent;
    for (i = 0; i < this.participants.length; i += 1) {
        participant = this.participants[i];
        if (participant.processRef.id === currentProcess.id) {
            uid = participant.id;
            break;
        }
    }
    pool = canvas.customShapes.find('id', uid);
    return {parentUid: uid, container: pool.extendedType, y: pool.y};
};
importBpmnDiagram.prototype.getContainerShape = function (element) {
    var i,
        j,
        participant,
        uid = null,
        canvas = PMUI.getActiveCanvas(),
        container = null,
        refs,
        currentProcess =  element.$parent;
    if (element.$type !== 'bpmn:TextAnnotation') {
        for (i = 0; i < this.lanes.length; i += 1) {
            refs = this.lanes[i].get('flowNodeRef');
            for (j = 0; j < refs.length; j += 1) {
                if (refs[j].id === element.id) {
                    uid = this.lanes[i].id;
                    break;
                }
            }
        }
        if (!uid) {
            while (currentProcess.$parent.$parent) {
                currentProcess = currentProcess.$parent;
            }
            for (i = 0; i < this.participants.length; i += 1) {
                participant = this.participants[i];
                if (participant.processRef.id === currentProcess.id) {
                    uid = participant.id;
                    break;
                }
            }
        }
        container = canvas.customShapes.find('id', uid);
    }

    return container;
};
/**
 * import bpmn elements
 * @param element
 * @param parentShape
 */
importBpmnDiagram.prototype.addElement = function (element) {
    var canvas = PMUI.getActiveCanvas(),
        shape,
        conn,
        state,
        x,
        y,
        dest,
        origin,
        bounds = element.di.bounds,
        container,
        bouElement = null,
        bouType = "bpmnDiagram",
        conectionMap = {
            'bpmn:SequenceFlow': 'SEQUENCE',
            'bpmn:Association': 'ASSOCIATION',
            'bpmn:DataOutputAssociation': 'DATAASSOCIATION',
            'bpmn:DataInputAssociation': 'DATAASSOCIATION',
            'bpmn:MessageFlow': 'MESSAGE'
        },
        ownProp;

    ownProp = this.getOwnProperties(element);
    if (ownProp.properties) {
        container = this.getContainerShape(element);

        x = bounds.x;
        y = bounds.y;
        if (container) {
            bouElement = container.id;
            bouType = container.type;
            while (container) {
                x = x - container.getX();
                y = y - container.getY();
                container = container.parent;
            }
        }
        shape = {
            'bou_container': bouType,
            'bou_element': bouElement,
            'bou_height': bounds.height,
            'bou_width': bounds.width,
            'bou_x': x,
            'bou_y': y

        };
        $.extend(true, shape, ownProp.properties);
        canvas.loadShape(ownProp.type, shape, false);

        canvas.updatedElement = {
            id : (canvas.updatedElement && canvas.updatedElement.id) || null,
            type : (canvas.updatedElement && canvas.updatedElement.type) || null,
            relatedObject : canvas.updatedElement,
            relatedElements: []
        };
        canvas.items.insert(canvas.updatedElement);
        element.id = canvas.updatedElement.id;

        canvas.updatedElement.relatedObject.businessObject = element;
        if (element.$type === 'bpmn:Participant') {
            this.laneRelPosition = 0;
            element.processRef.id = 'pmui-' + PMUI.generateUniqueId();
            canvas.updatedElement.relatedObject.businessObject = element.processRef;
            canvas.updatedElement.relatedObject.participantObject = element;
        }

    }
    if (conectionMap[element.$type]) {
        if (element.$type === 'bpmn:DataInputAssociation') {
            //dest = element.targetRef ? element.targetRef.id : element.$parent.id;
            dest = element.$parent.id;
            origin = element.sourceRef ? element.sourceRef[0].id : element.$parent.id;
        } else if (element.$type === 'bpmn:DataOutputAssociation') {
            dest = element.targetRef ? element.targetRef.id : element.$parent.id;
            origin = element.$parent.id;
        }else {
            dest = element.targetRef ? element.targetRef.id : element.$parent.id;
            origin = element.sourceRef ? element.sourceRef.id : element.$parent.id;
        }
        state = this.getState(element);
        conn = {
            flo_condition: null,
            flo_element_dest: dest,
            flo_element_origin: origin,
            flo_is_inmediate: "1",
            flo_name: null,
            flo_state: state,
            flo_type: conectionMap[element.$type],
            flo_x1: state[0].x,
            flo_y1: state[0].y,
            flo_x2: state[state.length - 1].x,
            flo_y2: state[state.length - 1].y
        };

        canvas.loadFlow(conn, false);
        canvas.updatedElement = {
            id : (canvas.updatedElement && canvas.updatedElement.id) || null,
            type : (canvas.updatedElement && canvas.updatedElement.type) || null,
            relatedObject : canvas.updatedElement,
            relatedElements: []
        };
        canvas.items.insert(canvas.updatedElement);
        element.id = canvas.updatedElement.id;
        canvas.updatedElement.relatedObject.businessObject = element;


    }
};
/**
 * geting all states in xml file
 * @param element
 */
importBpmnDiagram.prototype.getState = function (element) {
    var state = [],
        waypoint = element.di.waypoint,
        i;
    for (i = 0; i < waypoint.length; i += 1) {
        state.push({x: waypoint[i].x - 1, y: waypoint[i].y});
    }
    return state;
};
//'use strict';
//
//var _ = require('lodash');

function BpmnFactory(moddle) {
  this._model = moddle;
}

BpmnFactory.$inject = [ 'moddle' ];


BpmnFactory.prototype._needsId = function(element) {
  return element.$instanceOf('bpmn:RootElement') ||
         element.$instanceOf('bpmn:FlowElement') ||
         element.$instanceOf('bpmn:Artifact') ||
         element.$instanceOf('bpmndi:BPMNShape') ||
         element.$instanceOf('bpmndi:BPMNEdge') ||
         element.$instanceOf('bpmndi:BPMNDiagram') ||
         element.$instanceOf('bpmndi:BPMNPlane');
};

//BpmnFactory.prototype._ensureId = function(element) {
//  if (!element.id && this._needsId(element)) {
//    //element.id = this._model.ids.next(element);
//    element.id = this._model.ids.next(element);
//  }
//};


BpmnFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});
  element.id = attrs.id;
  //this._ensureId(element);

  return element;
};


BpmnFactory.prototype.createDiLabel = function() {
  return this.create('bpmndi:BPMNLabel', {
    bounds: this.createDiBounds()
  });
};


BpmnFactory.prototype.createDiShape = function(semantic, bounds, attrs) {

  return this.create('bpmndi:BPMNShape', _.extend({
    bpmnElement: semantic,
    bounds: this.createDiBounds(bounds)
  }, attrs));
};


BpmnFactory.prototype.createDiBounds = function(bounds) {
  return this.create('dc:Bounds', bounds);
};


BpmnFactory.prototype.createDiWaypoints = function(waypoints) {
  return _.map(waypoints, function(pos) {
    return this.createDiWaypoint(pos);
  }, this);
};

BpmnFactory.prototype.createDiWaypoint = function(point) {
  return this.create('dc:Point', _.pick(point, [ 'x', 'y' ]));
};


BpmnFactory.prototype.createDiEdge = function(semantic, waypoints, attrs) {
  return this.create('bpmndi:BPMNEdge', _.extend({
    bpmnElement: semantic
  }, attrs));
};


//module.exports = BpmnFactory;
